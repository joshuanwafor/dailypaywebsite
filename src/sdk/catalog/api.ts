/* tslint:disable */
/* eslint-disable */
/**
 * OpenAPI definition
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: v0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

/**
 * 
 * @export
 * @interface AddressResponse
 */
export interface AddressResponse {
    /**
     * 
     * @type {string}
     * @memberof AddressResponse
     */
    'country'?: AddressResponseCountryEnum;
    /**
     * 
     * @type {string}
     * @memberof AddressResponse
     */
    'countryCode'?: string;
    /**
     * 
     * @type {string}
     * @memberof AddressResponse
     */
    'state'?: string;
    /**
     * 
     * @type {string}
     * @memberof AddressResponse
     */
    'city'?: string;
    /**
     * 
     * @type {string}
     * @memberof AddressResponse
     */
    'addressLine1'?: string;
    /**
     * 
     * @type {string}
     * @memberof AddressResponse
     */
    'addressLine2'?: string;
    /**
     * 
     * @type {string}
     * @memberof AddressResponse
     */
    'postalAddress'?: string;
    /**
     * 
     * @type {string}
     * @memberof AddressResponse
     */
    'zipCode'?: string;
}

export const AddressResponseCountryEnum = {
    Afghanistan: 'AFGHANISTAN',
    Albania: 'ALBANIA',
    Algeria: 'ALGERIA',
    Andorra: 'ANDORRA',
    Angola: 'ANGOLA',
    AntiguaAndBarbuda: 'ANTIGUA_AND_BARBUDA',
    Argentina: 'ARGENTINA',
    Armenia: 'ARMENIA',
    Australia: 'AUSTRALIA',
    Austria: 'AUSTRIA',
    Azerbaijan: 'AZERBAIJAN',
    Bahamas: 'BAHAMAS',
    Bahrain: 'BAHRAIN',
    Bangladesh: 'BANGLADESH',
    Barbados: 'BARBADOS',
    Belarus: 'BELARUS',
    Belgium: 'BELGIUM',
    Belize: 'BELIZE',
    Benin: 'BENIN',
    Bhutan: 'BHUTAN',
    Bolivia: 'BOLIVIA',
    BosniaAndHerzegovina: 'BOSNIA_AND_HERZEGOVINA',
    Botswana: 'BOTSWANA',
    Brazil: 'BRAZIL',
    Brunei: 'BRUNEI',
    Bulgaria: 'BULGARIA',
    BurkinaFaso: 'BURKINA_FASO',
    Burundi: 'BURUNDI',
    Cambodia: 'CAMBODIA',
    Cameroon: 'CAMEROON',
    Canada: 'CANADA',
    CapeVerde: 'CAPE_VERDE',
    CentralAfricanRepublic: 'CENTRAL_AFRICAN_REPUBLIC',
    Chad: 'CHAD',
    Chile: 'CHILE',
    China: 'CHINA',
    Colombia: 'COLOMBIA',
    Comoros: 'COMOROS',
    Congo: 'CONGO',
    CostaRica: 'COSTA_RICA',
    CoteDivoire: 'COTE_DIVOIRE',
    Croatia: 'CROATIA',
    Cuba: 'CUBA',
    Cyprus: 'CYPRUS',
    Czechia: 'CZECHIA',
    Denmark: 'DENMARK',
    Djibouti: 'DJIBOUTI',
    Dominica: 'DOMINICA',
    DominicanRepublic: 'DOMINICAN_REPUBLIC',
    Ecuador: 'ECUADOR',
    Egypt: 'EGYPT',
    ElSalvador: 'EL_SALVADOR',
    EquatorialGuinea: 'EQUATORIAL_GUINEA',
    Eritrea: 'ERITREA',
    Estonia: 'ESTONIA',
    Eswatini: 'ESWATINI',
    Ethiopia: 'ETHIOPIA',
    Fiji: 'FIJI',
    Finland: 'FINLAND',
    France: 'FRANCE',
    Gabon: 'GABON',
    Gambia: 'GAMBIA',
    Georgia: 'GEORGIA',
    Germany: 'GERMANY',
    Ghana: 'GHANA',
    Greece: 'GREECE',
    Grenada: 'GRENADA',
    Guatemala: 'GUATEMALA',
    Guinea: 'GUINEA',
    GuineaBissau: 'GUINEA_BISSAU',
    Guyana: 'GUYANA',
    Haiti: 'HAITI',
    Honduras: 'HONDURAS',
    Hungary: 'HUNGARY',
    Iceland: 'ICELAND',
    India: 'INDIA',
    Indonesia: 'INDONESIA',
    Iran: 'IRAN',
    Iraq: 'IRAQ',
    Ireland: 'IRELAND',
    Israel: 'ISRAEL',
    Italy: 'ITALY',
    Jamaica: 'JAMAICA',
    Japan: 'JAPAN',
    Jordan: 'JORDAN',
    Kazakhstan: 'KAZAKHSTAN',
    Kenya: 'KENYA',
    Kiribati: 'KIRIBATI',
    KoreaNorth: 'KOREA_NORTH',
    KoreaSouth: 'KOREA_SOUTH',
    Kosovo: 'KOSOVO',
    Kuwait: 'KUWAIT',
    Kyrgyzstan: 'KYRGYZSTAN',
    Laos: 'LAOS',
    Latvia: 'LATVIA',
    Lebanon: 'LEBANON',
    Lesotho: 'LESOTHO',
    Liberia: 'LIBERIA',
    Libya: 'LIBYA',
    Liechtenstein: 'LIECHTENSTEIN',
    Lithuania: 'LITHUANIA',
    Luxembourg: 'LUXEMBOURG',
    Madagascar: 'MADAGASCAR',
    Malawi: 'MALAWI',
    Malaysia: 'MALAYSIA',
    Maldives: 'MALDIVES',
    Mali: 'MALI',
    Malta: 'MALTA',
    MarshallIslands: 'MARSHALL_ISLANDS',
    Mauritania: 'MAURITANIA',
    Mauritius: 'MAURITIUS',
    Mexico: 'MEXICO',
    Micronesia: 'MICRONESIA',
    Moldova: 'MOLDOVA',
    Monaco: 'MONACO',
    Mongolia: 'MONGOLIA',
    Montenegro: 'MONTENEGRO',
    Morocco: 'MOROCCO',
    Mozambique: 'MOZAMBIQUE',
    Myanmar: 'MYANMAR',
    Namibia: 'NAMIBIA',
    Nauru: 'NAURU',
    Nepal: 'NEPAL',
    Netherlands: 'NETHERLANDS',
    NewZealand: 'NEW_ZEALAND',
    Nicaragua: 'NICARAGUA',
    Niger: 'NIGER',
    Nigeria: 'NIGERIA',
    NorthMacedonia: 'NORTH_MACEDONIA',
    Norway: 'NORWAY',
    Oman: 'OMAN',
    Pakistan: 'PAKISTAN',
    Palau: 'PALAU',
    Panama: 'PANAMA',
    PapuaNewGuinea: 'PAPUA_NEW_GUINEA',
    Paraguay: 'PARAGUAY',
    Peru: 'PERU',
    Philippines: 'PHILIPPINES',
    Poland: 'POLAND',
    Portugal: 'PORTUGAL',
    Qatar: 'QATAR',
    Romania: 'ROMANIA',
    Russia: 'RUSSIA',
    Rwanda: 'RWANDA',
    SaintKittsAndNevis: 'SAINT_KITTS_AND_NEVIS',
    SaintLucia: 'SAINT_LUCIA',
    SaintVincentAndTheGrenadines: 'SAINT_VINCENT_AND_THE_GRENADINES',
    Samoa: 'SAMOA',
    SanMarino: 'SAN_MARINO',
    SaoTomeAndPrincipe: 'SAO_TOME_AND_PRINCIPE',
    SaudiArabia: 'SAUDI_ARABIA',
    Senegal: 'SENEGAL',
    Serbia: 'SERBIA',
    Seychelles: 'SEYCHELLES',
    SierraLeone: 'SIERRA_LEONE',
    Singapore: 'SINGAPORE',
    Slovakia: 'SLOVAKIA',
    Slovenia: 'SLOVENIA',
    SolomonIslands: 'SOLOMON_ISLANDS',
    Somalia: 'SOMALIA',
    SouthAfrica: 'SOUTH_AFRICA',
    SouthSudan: 'SOUTH_SUDAN',
    Spain: 'SPAIN',
    SriLanka: 'SRI_LANKA',
    Sudan: 'SUDAN',
    Suriname: 'SURINAME',
    Sweden: 'SWEDEN',
    Switzerland: 'SWITZERLAND',
    Syria: 'SYRIA',
    Taiwan: 'TAIWAN',
    Tajikistan: 'TAJIKISTAN',
    Tanzania: 'TANZANIA',
    Thailand: 'THAILAND',
    TimorLeste: 'TIMOR_LESTE',
    Togo: 'TOGO',
    Tonga: 'TONGA',
    TrinidadAndTobago: 'TRINIDAD_AND_TOBAGO',
    Tunisia: 'TUNISIA',
    Turkey: 'TURKEY',
    Turkmenistan: 'TURKMENISTAN',
    Tuvalu: 'TUVALU',
    Uganda: 'UGANDA',
    Ukraine: 'UKRAINE',
    UnitedArabEmirates: 'UNITED_ARAB_EMIRATES',
    UnitedKingdom: 'UNITED_KINGDOM',
    UnitedStates: 'UNITED_STATES',
    Uruguay: 'URUGUAY',
    Uzbekistan: 'UZBEKISTAN',
    Vanuatu: 'VANUATU',
    VaticanCity: 'VATICAN_CITY',
    Venezuela: 'VENEZUELA',
    Vietnam: 'VIETNAM',
    Yemen: 'YEMEN',
    Zambia: 'ZAMBIA',
    Zimbabwe: 'ZIMBABWE'
} as const;

export type AddressResponseCountryEnum = typeof AddressResponseCountryEnum[keyof typeof AddressResponseCountryEnum];

/**
 * 
 * @export
 * @interface ApiResponseDto
 */
export interface ApiResponseDto {
    /**
     * 
     * @type {boolean}
     * @memberof ApiResponseDto
     */
    'success'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof ApiResponseDto
     */
    'code'?: number;
    /**
     * 
     * @type {string}
     * @memberof ApiResponseDto
     */
    'status'?: ApiResponseDtoStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof ApiResponseDto
     */
    'message'?: string;
    /**
     * 
     * @type {object}
     * @memberof ApiResponseDto
     */
    'data'?: object;
    /**
     * 
     * @type {{ [key: string]: object; }}
     * @memberof ApiResponseDto
     */
    'meta'?: { [key: string]: object; };
}

export const ApiResponseDtoStatusEnum = {
    _100Continue: '100 CONTINUE',
    _101SwitchingProtocols: '101 SWITCHING_PROTOCOLS',
    _102Processing: '102 PROCESSING',
    _103EarlyHints: '103 EARLY_HINTS',
    _103Checkpoint: '103 CHECKPOINT',
    _200Ok: '200 OK',
    _201Created: '201 CREATED',
    _202Accepted: '202 ACCEPTED',
    _203NonAuthoritativeInformation: '203 NON_AUTHORITATIVE_INFORMATION',
    _204NoContent: '204 NO_CONTENT',
    _205ResetContent: '205 RESET_CONTENT',
    _206PartialContent: '206 PARTIAL_CONTENT',
    _207MultiStatus: '207 MULTI_STATUS',
    _208AlreadyReported: '208 ALREADY_REPORTED',
    _226ImUsed: '226 IM_USED',
    _300MultipleChoices: '300 MULTIPLE_CHOICES',
    _301MovedPermanently: '301 MOVED_PERMANENTLY',
    _302Found: '302 FOUND',
    _302MovedTemporarily: '302 MOVED_TEMPORARILY',
    _303SeeOther: '303 SEE_OTHER',
    _304NotModified: '304 NOT_MODIFIED',
    _305UseProxy: '305 USE_PROXY',
    _307TemporaryRedirect: '307 TEMPORARY_REDIRECT',
    _308PermanentRedirect: '308 PERMANENT_REDIRECT',
    _400BadRequest: '400 BAD_REQUEST',
    _401Unauthorized: '401 UNAUTHORIZED',
    _402PaymentRequired: '402 PAYMENT_REQUIRED',
    _403Forbidden: '403 FORBIDDEN',
    _404NotFound: '404 NOT_FOUND',
    _405MethodNotAllowed: '405 METHOD_NOT_ALLOWED',
    _406NotAcceptable: '406 NOT_ACCEPTABLE',
    _407ProxyAuthenticationRequired: '407 PROXY_AUTHENTICATION_REQUIRED',
    _408RequestTimeout: '408 REQUEST_TIMEOUT',
    _409Conflict: '409 CONFLICT',
    _410Gone: '410 GONE',
    _411LengthRequired: '411 LENGTH_REQUIRED',
    _412PreconditionFailed: '412 PRECONDITION_FAILED',
    _413PayloadTooLarge: '413 PAYLOAD_TOO_LARGE',
    _413RequestEntityTooLarge: '413 REQUEST_ENTITY_TOO_LARGE',
    _414UriTooLong: '414 URI_TOO_LONG',
    _414RequestUriTooLong: '414 REQUEST_URI_TOO_LONG',
    _415UnsupportedMediaType: '415 UNSUPPORTED_MEDIA_TYPE',
    _416RequestedRangeNotSatisfiable: '416 REQUESTED_RANGE_NOT_SATISFIABLE',
    _417ExpectationFailed: '417 EXPECTATION_FAILED',
    _418IAmATeapot: '418 I_AM_A_TEAPOT',
    _419InsufficientSpaceOnResource: '419 INSUFFICIENT_SPACE_ON_RESOURCE',
    _420MethodFailure: '420 METHOD_FAILURE',
    _421DestinationLocked: '421 DESTINATION_LOCKED',
    _422UnprocessableEntity: '422 UNPROCESSABLE_ENTITY',
    _423Locked: '423 LOCKED',
    _424FailedDependency: '424 FAILED_DEPENDENCY',
    _425TooEarly: '425 TOO_EARLY',
    _426UpgradeRequired: '426 UPGRADE_REQUIRED',
    _428PreconditionRequired: '428 PRECONDITION_REQUIRED',
    _429TooManyRequests: '429 TOO_MANY_REQUESTS',
    _431RequestHeaderFieldsTooLarge: '431 REQUEST_HEADER_FIELDS_TOO_LARGE',
    _451UnavailableForLegalReasons: '451 UNAVAILABLE_FOR_LEGAL_REASONS',
    _500InternalServerError: '500 INTERNAL_SERVER_ERROR',
    _501NotImplemented: '501 NOT_IMPLEMENTED',
    _502BadGateway: '502 BAD_GATEWAY',
    _503ServiceUnavailable: '503 SERVICE_UNAVAILABLE',
    _504GatewayTimeout: '504 GATEWAY_TIMEOUT',
    _505HttpVersionNotSupported: '505 HTTP_VERSION_NOT_SUPPORTED',
    _506VariantAlsoNegotiates: '506 VARIANT_ALSO_NEGOTIATES',
    _507InsufficientStorage: '507 INSUFFICIENT_STORAGE',
    _508LoopDetected: '508 LOOP_DETECTED',
    _509BandwidthLimitExceeded: '509 BANDWIDTH_LIMIT_EXCEEDED',
    _510NotExtended: '510 NOT_EXTENDED',
    _511NetworkAuthenticationRequired: '511 NETWORK_AUTHENTICATION_REQUIRED'
} as const;

export type ApiResponseDtoStatusEnum = typeof ApiResponseDtoStatusEnum[keyof typeof ApiResponseDtoStatusEnum];

/**
 * 
 * @export
 * @interface ApiResponseDtoBvnVerificationResponse
 */
export interface ApiResponseDtoBvnVerificationResponse {
    /**
     * 
     * @type {boolean}
     * @memberof ApiResponseDtoBvnVerificationResponse
     */
    'success'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof ApiResponseDtoBvnVerificationResponse
     */
    'code'?: number;
    /**
     * 
     * @type {string}
     * @memberof ApiResponseDtoBvnVerificationResponse
     */
    'status'?: ApiResponseDtoBvnVerificationResponseStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof ApiResponseDtoBvnVerificationResponse
     */
    'message'?: string;
    /**
     * 
     * @type {BvnVerificationResponse}
     * @memberof ApiResponseDtoBvnVerificationResponse
     */
    'data'?: BvnVerificationResponse;
    /**
     * 
     * @type {{ [key: string]: object; }}
     * @memberof ApiResponseDtoBvnVerificationResponse
     */
    'meta'?: { [key: string]: object; };
}

export const ApiResponseDtoBvnVerificationResponseStatusEnum = {
    _100Continue: '100 CONTINUE',
    _101SwitchingProtocols: '101 SWITCHING_PROTOCOLS',
    _102Processing: '102 PROCESSING',
    _103EarlyHints: '103 EARLY_HINTS',
    _103Checkpoint: '103 CHECKPOINT',
    _200Ok: '200 OK',
    _201Created: '201 CREATED',
    _202Accepted: '202 ACCEPTED',
    _203NonAuthoritativeInformation: '203 NON_AUTHORITATIVE_INFORMATION',
    _204NoContent: '204 NO_CONTENT',
    _205ResetContent: '205 RESET_CONTENT',
    _206PartialContent: '206 PARTIAL_CONTENT',
    _207MultiStatus: '207 MULTI_STATUS',
    _208AlreadyReported: '208 ALREADY_REPORTED',
    _226ImUsed: '226 IM_USED',
    _300MultipleChoices: '300 MULTIPLE_CHOICES',
    _301MovedPermanently: '301 MOVED_PERMANENTLY',
    _302Found: '302 FOUND',
    _302MovedTemporarily: '302 MOVED_TEMPORARILY',
    _303SeeOther: '303 SEE_OTHER',
    _304NotModified: '304 NOT_MODIFIED',
    _305UseProxy: '305 USE_PROXY',
    _307TemporaryRedirect: '307 TEMPORARY_REDIRECT',
    _308PermanentRedirect: '308 PERMANENT_REDIRECT',
    _400BadRequest: '400 BAD_REQUEST',
    _401Unauthorized: '401 UNAUTHORIZED',
    _402PaymentRequired: '402 PAYMENT_REQUIRED',
    _403Forbidden: '403 FORBIDDEN',
    _404NotFound: '404 NOT_FOUND',
    _405MethodNotAllowed: '405 METHOD_NOT_ALLOWED',
    _406NotAcceptable: '406 NOT_ACCEPTABLE',
    _407ProxyAuthenticationRequired: '407 PROXY_AUTHENTICATION_REQUIRED',
    _408RequestTimeout: '408 REQUEST_TIMEOUT',
    _409Conflict: '409 CONFLICT',
    _410Gone: '410 GONE',
    _411LengthRequired: '411 LENGTH_REQUIRED',
    _412PreconditionFailed: '412 PRECONDITION_FAILED',
    _413PayloadTooLarge: '413 PAYLOAD_TOO_LARGE',
    _413RequestEntityTooLarge: '413 REQUEST_ENTITY_TOO_LARGE',
    _414UriTooLong: '414 URI_TOO_LONG',
    _414RequestUriTooLong: '414 REQUEST_URI_TOO_LONG',
    _415UnsupportedMediaType: '415 UNSUPPORTED_MEDIA_TYPE',
    _416RequestedRangeNotSatisfiable: '416 REQUESTED_RANGE_NOT_SATISFIABLE',
    _417ExpectationFailed: '417 EXPECTATION_FAILED',
    _418IAmATeapot: '418 I_AM_A_TEAPOT',
    _419InsufficientSpaceOnResource: '419 INSUFFICIENT_SPACE_ON_RESOURCE',
    _420MethodFailure: '420 METHOD_FAILURE',
    _421DestinationLocked: '421 DESTINATION_LOCKED',
    _422UnprocessableEntity: '422 UNPROCESSABLE_ENTITY',
    _423Locked: '423 LOCKED',
    _424FailedDependency: '424 FAILED_DEPENDENCY',
    _425TooEarly: '425 TOO_EARLY',
    _426UpgradeRequired: '426 UPGRADE_REQUIRED',
    _428PreconditionRequired: '428 PRECONDITION_REQUIRED',
    _429TooManyRequests: '429 TOO_MANY_REQUESTS',
    _431RequestHeaderFieldsTooLarge: '431 REQUEST_HEADER_FIELDS_TOO_LARGE',
    _451UnavailableForLegalReasons: '451 UNAVAILABLE_FOR_LEGAL_REASONS',
    _500InternalServerError: '500 INTERNAL_SERVER_ERROR',
    _501NotImplemented: '501 NOT_IMPLEMENTED',
    _502BadGateway: '502 BAD_GATEWAY',
    _503ServiceUnavailable: '503 SERVICE_UNAVAILABLE',
    _504GatewayTimeout: '504 GATEWAY_TIMEOUT',
    _505HttpVersionNotSupported: '505 HTTP_VERSION_NOT_SUPPORTED',
    _506VariantAlsoNegotiates: '506 VARIANT_ALSO_NEGOTIATES',
    _507InsufficientStorage: '507 INSUFFICIENT_STORAGE',
    _508LoopDetected: '508 LOOP_DETECTED',
    _509BandwidthLimitExceeded: '509 BANDWIDTH_LIMIT_EXCEEDED',
    _510NotExtended: '510 NOT_EXTENDED',
    _511NetworkAuthenticationRequired: '511 NETWORK_AUTHENTICATION_REQUIRED'
} as const;

export type ApiResponseDtoBvnVerificationResponseStatusEnum = typeof ApiResponseDtoBvnVerificationResponseStatusEnum[keyof typeof ApiResponseDtoBvnVerificationResponseStatusEnum];

/**
 * 
 * @export
 * @interface ApiResponseDtoDailyPayWalletMetrics
 */
export interface ApiResponseDtoDailyPayWalletMetrics {
    /**
     * 
     * @type {boolean}
     * @memberof ApiResponseDtoDailyPayWalletMetrics
     */
    'success'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof ApiResponseDtoDailyPayWalletMetrics
     */
    'code'?: number;
    /**
     * 
     * @type {string}
     * @memberof ApiResponseDtoDailyPayWalletMetrics
     */
    'status'?: ApiResponseDtoDailyPayWalletMetricsStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof ApiResponseDtoDailyPayWalletMetrics
     */
    'message'?: string;
    /**
     * 
     * @type {DailyPayWalletMetrics}
     * @memberof ApiResponseDtoDailyPayWalletMetrics
     */
    'data'?: DailyPayWalletMetrics;
    /**
     * 
     * @type {{ [key: string]: object; }}
     * @memberof ApiResponseDtoDailyPayWalletMetrics
     */
    'meta'?: { [key: string]: object; };
}

export const ApiResponseDtoDailyPayWalletMetricsStatusEnum = {
    _100Continue: '100 CONTINUE',
    _101SwitchingProtocols: '101 SWITCHING_PROTOCOLS',
    _102Processing: '102 PROCESSING',
    _103EarlyHints: '103 EARLY_HINTS',
    _103Checkpoint: '103 CHECKPOINT',
    _200Ok: '200 OK',
    _201Created: '201 CREATED',
    _202Accepted: '202 ACCEPTED',
    _203NonAuthoritativeInformation: '203 NON_AUTHORITATIVE_INFORMATION',
    _204NoContent: '204 NO_CONTENT',
    _205ResetContent: '205 RESET_CONTENT',
    _206PartialContent: '206 PARTIAL_CONTENT',
    _207MultiStatus: '207 MULTI_STATUS',
    _208AlreadyReported: '208 ALREADY_REPORTED',
    _226ImUsed: '226 IM_USED',
    _300MultipleChoices: '300 MULTIPLE_CHOICES',
    _301MovedPermanently: '301 MOVED_PERMANENTLY',
    _302Found: '302 FOUND',
    _302MovedTemporarily: '302 MOVED_TEMPORARILY',
    _303SeeOther: '303 SEE_OTHER',
    _304NotModified: '304 NOT_MODIFIED',
    _305UseProxy: '305 USE_PROXY',
    _307TemporaryRedirect: '307 TEMPORARY_REDIRECT',
    _308PermanentRedirect: '308 PERMANENT_REDIRECT',
    _400BadRequest: '400 BAD_REQUEST',
    _401Unauthorized: '401 UNAUTHORIZED',
    _402PaymentRequired: '402 PAYMENT_REQUIRED',
    _403Forbidden: '403 FORBIDDEN',
    _404NotFound: '404 NOT_FOUND',
    _405MethodNotAllowed: '405 METHOD_NOT_ALLOWED',
    _406NotAcceptable: '406 NOT_ACCEPTABLE',
    _407ProxyAuthenticationRequired: '407 PROXY_AUTHENTICATION_REQUIRED',
    _408RequestTimeout: '408 REQUEST_TIMEOUT',
    _409Conflict: '409 CONFLICT',
    _410Gone: '410 GONE',
    _411LengthRequired: '411 LENGTH_REQUIRED',
    _412PreconditionFailed: '412 PRECONDITION_FAILED',
    _413PayloadTooLarge: '413 PAYLOAD_TOO_LARGE',
    _413RequestEntityTooLarge: '413 REQUEST_ENTITY_TOO_LARGE',
    _414UriTooLong: '414 URI_TOO_LONG',
    _414RequestUriTooLong: '414 REQUEST_URI_TOO_LONG',
    _415UnsupportedMediaType: '415 UNSUPPORTED_MEDIA_TYPE',
    _416RequestedRangeNotSatisfiable: '416 REQUESTED_RANGE_NOT_SATISFIABLE',
    _417ExpectationFailed: '417 EXPECTATION_FAILED',
    _418IAmATeapot: '418 I_AM_A_TEAPOT',
    _419InsufficientSpaceOnResource: '419 INSUFFICIENT_SPACE_ON_RESOURCE',
    _420MethodFailure: '420 METHOD_FAILURE',
    _421DestinationLocked: '421 DESTINATION_LOCKED',
    _422UnprocessableEntity: '422 UNPROCESSABLE_ENTITY',
    _423Locked: '423 LOCKED',
    _424FailedDependency: '424 FAILED_DEPENDENCY',
    _425TooEarly: '425 TOO_EARLY',
    _426UpgradeRequired: '426 UPGRADE_REQUIRED',
    _428PreconditionRequired: '428 PRECONDITION_REQUIRED',
    _429TooManyRequests: '429 TOO_MANY_REQUESTS',
    _431RequestHeaderFieldsTooLarge: '431 REQUEST_HEADER_FIELDS_TOO_LARGE',
    _451UnavailableForLegalReasons: '451 UNAVAILABLE_FOR_LEGAL_REASONS',
    _500InternalServerError: '500 INTERNAL_SERVER_ERROR',
    _501NotImplemented: '501 NOT_IMPLEMENTED',
    _502BadGateway: '502 BAD_GATEWAY',
    _503ServiceUnavailable: '503 SERVICE_UNAVAILABLE',
    _504GatewayTimeout: '504 GATEWAY_TIMEOUT',
    _505HttpVersionNotSupported: '505 HTTP_VERSION_NOT_SUPPORTED',
    _506VariantAlsoNegotiates: '506 VARIANT_ALSO_NEGOTIATES',
    _507InsufficientStorage: '507 INSUFFICIENT_STORAGE',
    _508LoopDetected: '508 LOOP_DETECTED',
    _509BandwidthLimitExceeded: '509 BANDWIDTH_LIMIT_EXCEEDED',
    _510NotExtended: '510 NOT_EXTENDED',
    _511NetworkAuthenticationRequired: '511 NETWORK_AUTHENTICATION_REQUIRED'
} as const;

export type ApiResponseDtoDailyPayWalletMetricsStatusEnum = typeof ApiResponseDtoDailyPayWalletMetricsStatusEnum[keyof typeof ApiResponseDtoDailyPayWalletMetricsStatusEnum];

/**
 * 
 * @export
 * @interface ApiResponseDtoFileUploadResponse
 */
export interface ApiResponseDtoFileUploadResponse {
    /**
     * 
     * @type {boolean}
     * @memberof ApiResponseDtoFileUploadResponse
     */
    'success'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof ApiResponseDtoFileUploadResponse
     */
    'code'?: number;
    /**
     * 
     * @type {string}
     * @memberof ApiResponseDtoFileUploadResponse
     */
    'status'?: ApiResponseDtoFileUploadResponseStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof ApiResponseDtoFileUploadResponse
     */
    'message'?: string;
    /**
     * 
     * @type {FileUploadResponse}
     * @memberof ApiResponseDtoFileUploadResponse
     */
    'data'?: FileUploadResponse;
    /**
     * 
     * @type {{ [key: string]: object; }}
     * @memberof ApiResponseDtoFileUploadResponse
     */
    'meta'?: { [key: string]: object; };
}

export const ApiResponseDtoFileUploadResponseStatusEnum = {
    _100Continue: '100 CONTINUE',
    _101SwitchingProtocols: '101 SWITCHING_PROTOCOLS',
    _102Processing: '102 PROCESSING',
    _103EarlyHints: '103 EARLY_HINTS',
    _103Checkpoint: '103 CHECKPOINT',
    _200Ok: '200 OK',
    _201Created: '201 CREATED',
    _202Accepted: '202 ACCEPTED',
    _203NonAuthoritativeInformation: '203 NON_AUTHORITATIVE_INFORMATION',
    _204NoContent: '204 NO_CONTENT',
    _205ResetContent: '205 RESET_CONTENT',
    _206PartialContent: '206 PARTIAL_CONTENT',
    _207MultiStatus: '207 MULTI_STATUS',
    _208AlreadyReported: '208 ALREADY_REPORTED',
    _226ImUsed: '226 IM_USED',
    _300MultipleChoices: '300 MULTIPLE_CHOICES',
    _301MovedPermanently: '301 MOVED_PERMANENTLY',
    _302Found: '302 FOUND',
    _302MovedTemporarily: '302 MOVED_TEMPORARILY',
    _303SeeOther: '303 SEE_OTHER',
    _304NotModified: '304 NOT_MODIFIED',
    _305UseProxy: '305 USE_PROXY',
    _307TemporaryRedirect: '307 TEMPORARY_REDIRECT',
    _308PermanentRedirect: '308 PERMANENT_REDIRECT',
    _400BadRequest: '400 BAD_REQUEST',
    _401Unauthorized: '401 UNAUTHORIZED',
    _402PaymentRequired: '402 PAYMENT_REQUIRED',
    _403Forbidden: '403 FORBIDDEN',
    _404NotFound: '404 NOT_FOUND',
    _405MethodNotAllowed: '405 METHOD_NOT_ALLOWED',
    _406NotAcceptable: '406 NOT_ACCEPTABLE',
    _407ProxyAuthenticationRequired: '407 PROXY_AUTHENTICATION_REQUIRED',
    _408RequestTimeout: '408 REQUEST_TIMEOUT',
    _409Conflict: '409 CONFLICT',
    _410Gone: '410 GONE',
    _411LengthRequired: '411 LENGTH_REQUIRED',
    _412PreconditionFailed: '412 PRECONDITION_FAILED',
    _413PayloadTooLarge: '413 PAYLOAD_TOO_LARGE',
    _413RequestEntityTooLarge: '413 REQUEST_ENTITY_TOO_LARGE',
    _414UriTooLong: '414 URI_TOO_LONG',
    _414RequestUriTooLong: '414 REQUEST_URI_TOO_LONG',
    _415UnsupportedMediaType: '415 UNSUPPORTED_MEDIA_TYPE',
    _416RequestedRangeNotSatisfiable: '416 REQUESTED_RANGE_NOT_SATISFIABLE',
    _417ExpectationFailed: '417 EXPECTATION_FAILED',
    _418IAmATeapot: '418 I_AM_A_TEAPOT',
    _419InsufficientSpaceOnResource: '419 INSUFFICIENT_SPACE_ON_RESOURCE',
    _420MethodFailure: '420 METHOD_FAILURE',
    _421DestinationLocked: '421 DESTINATION_LOCKED',
    _422UnprocessableEntity: '422 UNPROCESSABLE_ENTITY',
    _423Locked: '423 LOCKED',
    _424FailedDependency: '424 FAILED_DEPENDENCY',
    _425TooEarly: '425 TOO_EARLY',
    _426UpgradeRequired: '426 UPGRADE_REQUIRED',
    _428PreconditionRequired: '428 PRECONDITION_REQUIRED',
    _429TooManyRequests: '429 TOO_MANY_REQUESTS',
    _431RequestHeaderFieldsTooLarge: '431 REQUEST_HEADER_FIELDS_TOO_LARGE',
    _451UnavailableForLegalReasons: '451 UNAVAILABLE_FOR_LEGAL_REASONS',
    _500InternalServerError: '500 INTERNAL_SERVER_ERROR',
    _501NotImplemented: '501 NOT_IMPLEMENTED',
    _502BadGateway: '502 BAD_GATEWAY',
    _503ServiceUnavailable: '503 SERVICE_UNAVAILABLE',
    _504GatewayTimeout: '504 GATEWAY_TIMEOUT',
    _505HttpVersionNotSupported: '505 HTTP_VERSION_NOT_SUPPORTED',
    _506VariantAlsoNegotiates: '506 VARIANT_ALSO_NEGOTIATES',
    _507InsufficientStorage: '507 INSUFFICIENT_STORAGE',
    _508LoopDetected: '508 LOOP_DETECTED',
    _509BandwidthLimitExceeded: '509 BANDWIDTH_LIMIT_EXCEEDED',
    _510NotExtended: '510 NOT_EXTENDED',
    _511NetworkAuthenticationRequired: '511 NETWORK_AUTHENTICATION_REQUIRED'
} as const;

export type ApiResponseDtoFileUploadResponseStatusEnum = typeof ApiResponseDtoFileUploadResponseStatusEnum[keyof typeof ApiResponseDtoFileUploadResponseStatusEnum];

/**
 * 
 * @export
 * @interface ApiResponseDtoHrLinkedInValidationResponse
 */
export interface ApiResponseDtoHrLinkedInValidationResponse {
    /**
     * 
     * @type {boolean}
     * @memberof ApiResponseDtoHrLinkedInValidationResponse
     */
    'success'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof ApiResponseDtoHrLinkedInValidationResponse
     */
    'code'?: number;
    /**
     * 
     * @type {string}
     * @memberof ApiResponseDtoHrLinkedInValidationResponse
     */
    'status'?: ApiResponseDtoHrLinkedInValidationResponseStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof ApiResponseDtoHrLinkedInValidationResponse
     */
    'message'?: string;
    /**
     * 
     * @type {HrLinkedInValidationResponse}
     * @memberof ApiResponseDtoHrLinkedInValidationResponse
     */
    'data'?: HrLinkedInValidationResponse;
    /**
     * 
     * @type {{ [key: string]: object; }}
     * @memberof ApiResponseDtoHrLinkedInValidationResponse
     */
    'meta'?: { [key: string]: object; };
}

export const ApiResponseDtoHrLinkedInValidationResponseStatusEnum = {
    _100Continue: '100 CONTINUE',
    _101SwitchingProtocols: '101 SWITCHING_PROTOCOLS',
    _102Processing: '102 PROCESSING',
    _103EarlyHints: '103 EARLY_HINTS',
    _103Checkpoint: '103 CHECKPOINT',
    _200Ok: '200 OK',
    _201Created: '201 CREATED',
    _202Accepted: '202 ACCEPTED',
    _203NonAuthoritativeInformation: '203 NON_AUTHORITATIVE_INFORMATION',
    _204NoContent: '204 NO_CONTENT',
    _205ResetContent: '205 RESET_CONTENT',
    _206PartialContent: '206 PARTIAL_CONTENT',
    _207MultiStatus: '207 MULTI_STATUS',
    _208AlreadyReported: '208 ALREADY_REPORTED',
    _226ImUsed: '226 IM_USED',
    _300MultipleChoices: '300 MULTIPLE_CHOICES',
    _301MovedPermanently: '301 MOVED_PERMANENTLY',
    _302Found: '302 FOUND',
    _302MovedTemporarily: '302 MOVED_TEMPORARILY',
    _303SeeOther: '303 SEE_OTHER',
    _304NotModified: '304 NOT_MODIFIED',
    _305UseProxy: '305 USE_PROXY',
    _307TemporaryRedirect: '307 TEMPORARY_REDIRECT',
    _308PermanentRedirect: '308 PERMANENT_REDIRECT',
    _400BadRequest: '400 BAD_REQUEST',
    _401Unauthorized: '401 UNAUTHORIZED',
    _402PaymentRequired: '402 PAYMENT_REQUIRED',
    _403Forbidden: '403 FORBIDDEN',
    _404NotFound: '404 NOT_FOUND',
    _405MethodNotAllowed: '405 METHOD_NOT_ALLOWED',
    _406NotAcceptable: '406 NOT_ACCEPTABLE',
    _407ProxyAuthenticationRequired: '407 PROXY_AUTHENTICATION_REQUIRED',
    _408RequestTimeout: '408 REQUEST_TIMEOUT',
    _409Conflict: '409 CONFLICT',
    _410Gone: '410 GONE',
    _411LengthRequired: '411 LENGTH_REQUIRED',
    _412PreconditionFailed: '412 PRECONDITION_FAILED',
    _413PayloadTooLarge: '413 PAYLOAD_TOO_LARGE',
    _413RequestEntityTooLarge: '413 REQUEST_ENTITY_TOO_LARGE',
    _414UriTooLong: '414 URI_TOO_LONG',
    _414RequestUriTooLong: '414 REQUEST_URI_TOO_LONG',
    _415UnsupportedMediaType: '415 UNSUPPORTED_MEDIA_TYPE',
    _416RequestedRangeNotSatisfiable: '416 REQUESTED_RANGE_NOT_SATISFIABLE',
    _417ExpectationFailed: '417 EXPECTATION_FAILED',
    _418IAmATeapot: '418 I_AM_A_TEAPOT',
    _419InsufficientSpaceOnResource: '419 INSUFFICIENT_SPACE_ON_RESOURCE',
    _420MethodFailure: '420 METHOD_FAILURE',
    _421DestinationLocked: '421 DESTINATION_LOCKED',
    _422UnprocessableEntity: '422 UNPROCESSABLE_ENTITY',
    _423Locked: '423 LOCKED',
    _424FailedDependency: '424 FAILED_DEPENDENCY',
    _425TooEarly: '425 TOO_EARLY',
    _426UpgradeRequired: '426 UPGRADE_REQUIRED',
    _428PreconditionRequired: '428 PRECONDITION_REQUIRED',
    _429TooManyRequests: '429 TOO_MANY_REQUESTS',
    _431RequestHeaderFieldsTooLarge: '431 REQUEST_HEADER_FIELDS_TOO_LARGE',
    _451UnavailableForLegalReasons: '451 UNAVAILABLE_FOR_LEGAL_REASONS',
    _500InternalServerError: '500 INTERNAL_SERVER_ERROR',
    _501NotImplemented: '501 NOT_IMPLEMENTED',
    _502BadGateway: '502 BAD_GATEWAY',
    _503ServiceUnavailable: '503 SERVICE_UNAVAILABLE',
    _504GatewayTimeout: '504 GATEWAY_TIMEOUT',
    _505HttpVersionNotSupported: '505 HTTP_VERSION_NOT_SUPPORTED',
    _506VariantAlsoNegotiates: '506 VARIANT_ALSO_NEGOTIATES',
    _507InsufficientStorage: '507 INSUFFICIENT_STORAGE',
    _508LoopDetected: '508 LOOP_DETECTED',
    _509BandwidthLimitExceeded: '509 BANDWIDTH_LIMIT_EXCEEDED',
    _510NotExtended: '510 NOT_EXTENDED',
    _511NetworkAuthenticationRequired: '511 NETWORK_AUTHENTICATION_REQUIRED'
} as const;

export type ApiResponseDtoHrLinkedInValidationResponseStatusEnum = typeof ApiResponseDtoHrLinkedInValidationResponseStatusEnum[keyof typeof ApiResponseDtoHrLinkedInValidationResponseStatusEnum];

/**
 * 
 * @export
 * @interface ApiResponseDtoJobResponse
 */
export interface ApiResponseDtoJobResponse {
    /**
     * 
     * @type {boolean}
     * @memberof ApiResponseDtoJobResponse
     */
    'success'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof ApiResponseDtoJobResponse
     */
    'code'?: number;
    /**
     * 
     * @type {string}
     * @memberof ApiResponseDtoJobResponse
     */
    'status'?: ApiResponseDtoJobResponseStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof ApiResponseDtoJobResponse
     */
    'message'?: string;
    /**
     * 
     * @type {JobResponse}
     * @memberof ApiResponseDtoJobResponse
     */
    'data'?: JobResponse;
    /**
     * 
     * @type {{ [key: string]: object; }}
     * @memberof ApiResponseDtoJobResponse
     */
    'meta'?: { [key: string]: object; };
}

export const ApiResponseDtoJobResponseStatusEnum = {
    _100Continue: '100 CONTINUE',
    _101SwitchingProtocols: '101 SWITCHING_PROTOCOLS',
    _102Processing: '102 PROCESSING',
    _103EarlyHints: '103 EARLY_HINTS',
    _103Checkpoint: '103 CHECKPOINT',
    _200Ok: '200 OK',
    _201Created: '201 CREATED',
    _202Accepted: '202 ACCEPTED',
    _203NonAuthoritativeInformation: '203 NON_AUTHORITATIVE_INFORMATION',
    _204NoContent: '204 NO_CONTENT',
    _205ResetContent: '205 RESET_CONTENT',
    _206PartialContent: '206 PARTIAL_CONTENT',
    _207MultiStatus: '207 MULTI_STATUS',
    _208AlreadyReported: '208 ALREADY_REPORTED',
    _226ImUsed: '226 IM_USED',
    _300MultipleChoices: '300 MULTIPLE_CHOICES',
    _301MovedPermanently: '301 MOVED_PERMANENTLY',
    _302Found: '302 FOUND',
    _302MovedTemporarily: '302 MOVED_TEMPORARILY',
    _303SeeOther: '303 SEE_OTHER',
    _304NotModified: '304 NOT_MODIFIED',
    _305UseProxy: '305 USE_PROXY',
    _307TemporaryRedirect: '307 TEMPORARY_REDIRECT',
    _308PermanentRedirect: '308 PERMANENT_REDIRECT',
    _400BadRequest: '400 BAD_REQUEST',
    _401Unauthorized: '401 UNAUTHORIZED',
    _402PaymentRequired: '402 PAYMENT_REQUIRED',
    _403Forbidden: '403 FORBIDDEN',
    _404NotFound: '404 NOT_FOUND',
    _405MethodNotAllowed: '405 METHOD_NOT_ALLOWED',
    _406NotAcceptable: '406 NOT_ACCEPTABLE',
    _407ProxyAuthenticationRequired: '407 PROXY_AUTHENTICATION_REQUIRED',
    _408RequestTimeout: '408 REQUEST_TIMEOUT',
    _409Conflict: '409 CONFLICT',
    _410Gone: '410 GONE',
    _411LengthRequired: '411 LENGTH_REQUIRED',
    _412PreconditionFailed: '412 PRECONDITION_FAILED',
    _413PayloadTooLarge: '413 PAYLOAD_TOO_LARGE',
    _413RequestEntityTooLarge: '413 REQUEST_ENTITY_TOO_LARGE',
    _414UriTooLong: '414 URI_TOO_LONG',
    _414RequestUriTooLong: '414 REQUEST_URI_TOO_LONG',
    _415UnsupportedMediaType: '415 UNSUPPORTED_MEDIA_TYPE',
    _416RequestedRangeNotSatisfiable: '416 REQUESTED_RANGE_NOT_SATISFIABLE',
    _417ExpectationFailed: '417 EXPECTATION_FAILED',
    _418IAmATeapot: '418 I_AM_A_TEAPOT',
    _419InsufficientSpaceOnResource: '419 INSUFFICIENT_SPACE_ON_RESOURCE',
    _420MethodFailure: '420 METHOD_FAILURE',
    _421DestinationLocked: '421 DESTINATION_LOCKED',
    _422UnprocessableEntity: '422 UNPROCESSABLE_ENTITY',
    _423Locked: '423 LOCKED',
    _424FailedDependency: '424 FAILED_DEPENDENCY',
    _425TooEarly: '425 TOO_EARLY',
    _426UpgradeRequired: '426 UPGRADE_REQUIRED',
    _428PreconditionRequired: '428 PRECONDITION_REQUIRED',
    _429TooManyRequests: '429 TOO_MANY_REQUESTS',
    _431RequestHeaderFieldsTooLarge: '431 REQUEST_HEADER_FIELDS_TOO_LARGE',
    _451UnavailableForLegalReasons: '451 UNAVAILABLE_FOR_LEGAL_REASONS',
    _500InternalServerError: '500 INTERNAL_SERVER_ERROR',
    _501NotImplemented: '501 NOT_IMPLEMENTED',
    _502BadGateway: '502 BAD_GATEWAY',
    _503ServiceUnavailable: '503 SERVICE_UNAVAILABLE',
    _504GatewayTimeout: '504 GATEWAY_TIMEOUT',
    _505HttpVersionNotSupported: '505 HTTP_VERSION_NOT_SUPPORTED',
    _506VariantAlsoNegotiates: '506 VARIANT_ALSO_NEGOTIATES',
    _507InsufficientStorage: '507 INSUFFICIENT_STORAGE',
    _508LoopDetected: '508 LOOP_DETECTED',
    _509BandwidthLimitExceeded: '509 BANDWIDTH_LIMIT_EXCEEDED',
    _510NotExtended: '510 NOT_EXTENDED',
    _511NetworkAuthenticationRequired: '511 NETWORK_AUTHENTICATION_REQUIRED'
} as const;

export type ApiResponseDtoJobResponseStatusEnum = typeof ApiResponseDtoJobResponseStatusEnum[keyof typeof ApiResponseDtoJobResponseStatusEnum];

/**
 * 
 * @export
 * @interface ApiResponseDtoKycResponse
 */
export interface ApiResponseDtoKycResponse {
    /**
     * 
     * @type {boolean}
     * @memberof ApiResponseDtoKycResponse
     */
    'success'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof ApiResponseDtoKycResponse
     */
    'code'?: number;
    /**
     * 
     * @type {string}
     * @memberof ApiResponseDtoKycResponse
     */
    'status'?: ApiResponseDtoKycResponseStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof ApiResponseDtoKycResponse
     */
    'message'?: string;
    /**
     * 
     * @type {KycResponse}
     * @memberof ApiResponseDtoKycResponse
     */
    'data'?: KycResponse;
    /**
     * 
     * @type {{ [key: string]: object; }}
     * @memberof ApiResponseDtoKycResponse
     */
    'meta'?: { [key: string]: object; };
}

export const ApiResponseDtoKycResponseStatusEnum = {
    _100Continue: '100 CONTINUE',
    _101SwitchingProtocols: '101 SWITCHING_PROTOCOLS',
    _102Processing: '102 PROCESSING',
    _103EarlyHints: '103 EARLY_HINTS',
    _103Checkpoint: '103 CHECKPOINT',
    _200Ok: '200 OK',
    _201Created: '201 CREATED',
    _202Accepted: '202 ACCEPTED',
    _203NonAuthoritativeInformation: '203 NON_AUTHORITATIVE_INFORMATION',
    _204NoContent: '204 NO_CONTENT',
    _205ResetContent: '205 RESET_CONTENT',
    _206PartialContent: '206 PARTIAL_CONTENT',
    _207MultiStatus: '207 MULTI_STATUS',
    _208AlreadyReported: '208 ALREADY_REPORTED',
    _226ImUsed: '226 IM_USED',
    _300MultipleChoices: '300 MULTIPLE_CHOICES',
    _301MovedPermanently: '301 MOVED_PERMANENTLY',
    _302Found: '302 FOUND',
    _302MovedTemporarily: '302 MOVED_TEMPORARILY',
    _303SeeOther: '303 SEE_OTHER',
    _304NotModified: '304 NOT_MODIFIED',
    _305UseProxy: '305 USE_PROXY',
    _307TemporaryRedirect: '307 TEMPORARY_REDIRECT',
    _308PermanentRedirect: '308 PERMANENT_REDIRECT',
    _400BadRequest: '400 BAD_REQUEST',
    _401Unauthorized: '401 UNAUTHORIZED',
    _402PaymentRequired: '402 PAYMENT_REQUIRED',
    _403Forbidden: '403 FORBIDDEN',
    _404NotFound: '404 NOT_FOUND',
    _405MethodNotAllowed: '405 METHOD_NOT_ALLOWED',
    _406NotAcceptable: '406 NOT_ACCEPTABLE',
    _407ProxyAuthenticationRequired: '407 PROXY_AUTHENTICATION_REQUIRED',
    _408RequestTimeout: '408 REQUEST_TIMEOUT',
    _409Conflict: '409 CONFLICT',
    _410Gone: '410 GONE',
    _411LengthRequired: '411 LENGTH_REQUIRED',
    _412PreconditionFailed: '412 PRECONDITION_FAILED',
    _413PayloadTooLarge: '413 PAYLOAD_TOO_LARGE',
    _413RequestEntityTooLarge: '413 REQUEST_ENTITY_TOO_LARGE',
    _414UriTooLong: '414 URI_TOO_LONG',
    _414RequestUriTooLong: '414 REQUEST_URI_TOO_LONG',
    _415UnsupportedMediaType: '415 UNSUPPORTED_MEDIA_TYPE',
    _416RequestedRangeNotSatisfiable: '416 REQUESTED_RANGE_NOT_SATISFIABLE',
    _417ExpectationFailed: '417 EXPECTATION_FAILED',
    _418IAmATeapot: '418 I_AM_A_TEAPOT',
    _419InsufficientSpaceOnResource: '419 INSUFFICIENT_SPACE_ON_RESOURCE',
    _420MethodFailure: '420 METHOD_FAILURE',
    _421DestinationLocked: '421 DESTINATION_LOCKED',
    _422UnprocessableEntity: '422 UNPROCESSABLE_ENTITY',
    _423Locked: '423 LOCKED',
    _424FailedDependency: '424 FAILED_DEPENDENCY',
    _425TooEarly: '425 TOO_EARLY',
    _426UpgradeRequired: '426 UPGRADE_REQUIRED',
    _428PreconditionRequired: '428 PRECONDITION_REQUIRED',
    _429TooManyRequests: '429 TOO_MANY_REQUESTS',
    _431RequestHeaderFieldsTooLarge: '431 REQUEST_HEADER_FIELDS_TOO_LARGE',
    _451UnavailableForLegalReasons: '451 UNAVAILABLE_FOR_LEGAL_REASONS',
    _500InternalServerError: '500 INTERNAL_SERVER_ERROR',
    _501NotImplemented: '501 NOT_IMPLEMENTED',
    _502BadGateway: '502 BAD_GATEWAY',
    _503ServiceUnavailable: '503 SERVICE_UNAVAILABLE',
    _504GatewayTimeout: '504 GATEWAY_TIMEOUT',
    _505HttpVersionNotSupported: '505 HTTP_VERSION_NOT_SUPPORTED',
    _506VariantAlsoNegotiates: '506 VARIANT_ALSO_NEGOTIATES',
    _507InsufficientStorage: '507 INSUFFICIENT_STORAGE',
    _508LoopDetected: '508 LOOP_DETECTED',
    _509BandwidthLimitExceeded: '509 BANDWIDTH_LIMIT_EXCEEDED',
    _510NotExtended: '510 NOT_EXTENDED',
    _511NetworkAuthenticationRequired: '511 NETWORK_AUTHENTICATION_REQUIRED'
} as const;

export type ApiResponseDtoKycResponseStatusEnum = typeof ApiResponseDtoKycResponseStatusEnum[keyof typeof ApiResponseDtoKycResponseStatusEnum];

/**
 * 
 * @export
 * @interface ApiResponseDtoKycStatusResponse
 */
export interface ApiResponseDtoKycStatusResponse {
    /**
     * 
     * @type {boolean}
     * @memberof ApiResponseDtoKycStatusResponse
     */
    'success'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof ApiResponseDtoKycStatusResponse
     */
    'code'?: number;
    /**
     * 
     * @type {string}
     * @memberof ApiResponseDtoKycStatusResponse
     */
    'status'?: ApiResponseDtoKycStatusResponseStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof ApiResponseDtoKycStatusResponse
     */
    'message'?: string;
    /**
     * 
     * @type {KycStatusResponse}
     * @memberof ApiResponseDtoKycStatusResponse
     */
    'data'?: KycStatusResponse;
    /**
     * 
     * @type {{ [key: string]: object; }}
     * @memberof ApiResponseDtoKycStatusResponse
     */
    'meta'?: { [key: string]: object; };
}

export const ApiResponseDtoKycStatusResponseStatusEnum = {
    _100Continue: '100 CONTINUE',
    _101SwitchingProtocols: '101 SWITCHING_PROTOCOLS',
    _102Processing: '102 PROCESSING',
    _103EarlyHints: '103 EARLY_HINTS',
    _103Checkpoint: '103 CHECKPOINT',
    _200Ok: '200 OK',
    _201Created: '201 CREATED',
    _202Accepted: '202 ACCEPTED',
    _203NonAuthoritativeInformation: '203 NON_AUTHORITATIVE_INFORMATION',
    _204NoContent: '204 NO_CONTENT',
    _205ResetContent: '205 RESET_CONTENT',
    _206PartialContent: '206 PARTIAL_CONTENT',
    _207MultiStatus: '207 MULTI_STATUS',
    _208AlreadyReported: '208 ALREADY_REPORTED',
    _226ImUsed: '226 IM_USED',
    _300MultipleChoices: '300 MULTIPLE_CHOICES',
    _301MovedPermanently: '301 MOVED_PERMANENTLY',
    _302Found: '302 FOUND',
    _302MovedTemporarily: '302 MOVED_TEMPORARILY',
    _303SeeOther: '303 SEE_OTHER',
    _304NotModified: '304 NOT_MODIFIED',
    _305UseProxy: '305 USE_PROXY',
    _307TemporaryRedirect: '307 TEMPORARY_REDIRECT',
    _308PermanentRedirect: '308 PERMANENT_REDIRECT',
    _400BadRequest: '400 BAD_REQUEST',
    _401Unauthorized: '401 UNAUTHORIZED',
    _402PaymentRequired: '402 PAYMENT_REQUIRED',
    _403Forbidden: '403 FORBIDDEN',
    _404NotFound: '404 NOT_FOUND',
    _405MethodNotAllowed: '405 METHOD_NOT_ALLOWED',
    _406NotAcceptable: '406 NOT_ACCEPTABLE',
    _407ProxyAuthenticationRequired: '407 PROXY_AUTHENTICATION_REQUIRED',
    _408RequestTimeout: '408 REQUEST_TIMEOUT',
    _409Conflict: '409 CONFLICT',
    _410Gone: '410 GONE',
    _411LengthRequired: '411 LENGTH_REQUIRED',
    _412PreconditionFailed: '412 PRECONDITION_FAILED',
    _413PayloadTooLarge: '413 PAYLOAD_TOO_LARGE',
    _413RequestEntityTooLarge: '413 REQUEST_ENTITY_TOO_LARGE',
    _414UriTooLong: '414 URI_TOO_LONG',
    _414RequestUriTooLong: '414 REQUEST_URI_TOO_LONG',
    _415UnsupportedMediaType: '415 UNSUPPORTED_MEDIA_TYPE',
    _416RequestedRangeNotSatisfiable: '416 REQUESTED_RANGE_NOT_SATISFIABLE',
    _417ExpectationFailed: '417 EXPECTATION_FAILED',
    _418IAmATeapot: '418 I_AM_A_TEAPOT',
    _419InsufficientSpaceOnResource: '419 INSUFFICIENT_SPACE_ON_RESOURCE',
    _420MethodFailure: '420 METHOD_FAILURE',
    _421DestinationLocked: '421 DESTINATION_LOCKED',
    _422UnprocessableEntity: '422 UNPROCESSABLE_ENTITY',
    _423Locked: '423 LOCKED',
    _424FailedDependency: '424 FAILED_DEPENDENCY',
    _425TooEarly: '425 TOO_EARLY',
    _426UpgradeRequired: '426 UPGRADE_REQUIRED',
    _428PreconditionRequired: '428 PRECONDITION_REQUIRED',
    _429TooManyRequests: '429 TOO_MANY_REQUESTS',
    _431RequestHeaderFieldsTooLarge: '431 REQUEST_HEADER_FIELDS_TOO_LARGE',
    _451UnavailableForLegalReasons: '451 UNAVAILABLE_FOR_LEGAL_REASONS',
    _500InternalServerError: '500 INTERNAL_SERVER_ERROR',
    _501NotImplemented: '501 NOT_IMPLEMENTED',
    _502BadGateway: '502 BAD_GATEWAY',
    _503ServiceUnavailable: '503 SERVICE_UNAVAILABLE',
    _504GatewayTimeout: '504 GATEWAY_TIMEOUT',
    _505HttpVersionNotSupported: '505 HTTP_VERSION_NOT_SUPPORTED',
    _506VariantAlsoNegotiates: '506 VARIANT_ALSO_NEGOTIATES',
    _507InsufficientStorage: '507 INSUFFICIENT_STORAGE',
    _508LoopDetected: '508 LOOP_DETECTED',
    _509BandwidthLimitExceeded: '509 BANDWIDTH_LIMIT_EXCEEDED',
    _510NotExtended: '510 NOT_EXTENDED',
    _511NetworkAuthenticationRequired: '511 NETWORK_AUTHENTICATION_REQUIRED'
} as const;

export type ApiResponseDtoKycStatusResponseStatusEnum = typeof ApiResponseDtoKycStatusResponseStatusEnum[keyof typeof ApiResponseDtoKycStatusResponseStatusEnum];

/**
 * 
 * @export
 * @interface ApiResponseDtoListBank
 */
export interface ApiResponseDtoListBank {
    /**
     * 
     * @type {boolean}
     * @memberof ApiResponseDtoListBank
     */
    'success'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof ApiResponseDtoListBank
     */
    'code'?: number;
    /**
     * 
     * @type {string}
     * @memberof ApiResponseDtoListBank
     */
    'status'?: ApiResponseDtoListBankStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof ApiResponseDtoListBank
     */
    'message'?: string;
    /**
     * 
     * @type {Array<Bank>}
     * @memberof ApiResponseDtoListBank
     */
    'data'?: Array<Bank>;
    /**
     * 
     * @type {{ [key: string]: object; }}
     * @memberof ApiResponseDtoListBank
     */
    'meta'?: { [key: string]: object; };
}

export const ApiResponseDtoListBankStatusEnum = {
    _100Continue: '100 CONTINUE',
    _101SwitchingProtocols: '101 SWITCHING_PROTOCOLS',
    _102Processing: '102 PROCESSING',
    _103EarlyHints: '103 EARLY_HINTS',
    _103Checkpoint: '103 CHECKPOINT',
    _200Ok: '200 OK',
    _201Created: '201 CREATED',
    _202Accepted: '202 ACCEPTED',
    _203NonAuthoritativeInformation: '203 NON_AUTHORITATIVE_INFORMATION',
    _204NoContent: '204 NO_CONTENT',
    _205ResetContent: '205 RESET_CONTENT',
    _206PartialContent: '206 PARTIAL_CONTENT',
    _207MultiStatus: '207 MULTI_STATUS',
    _208AlreadyReported: '208 ALREADY_REPORTED',
    _226ImUsed: '226 IM_USED',
    _300MultipleChoices: '300 MULTIPLE_CHOICES',
    _301MovedPermanently: '301 MOVED_PERMANENTLY',
    _302Found: '302 FOUND',
    _302MovedTemporarily: '302 MOVED_TEMPORARILY',
    _303SeeOther: '303 SEE_OTHER',
    _304NotModified: '304 NOT_MODIFIED',
    _305UseProxy: '305 USE_PROXY',
    _307TemporaryRedirect: '307 TEMPORARY_REDIRECT',
    _308PermanentRedirect: '308 PERMANENT_REDIRECT',
    _400BadRequest: '400 BAD_REQUEST',
    _401Unauthorized: '401 UNAUTHORIZED',
    _402PaymentRequired: '402 PAYMENT_REQUIRED',
    _403Forbidden: '403 FORBIDDEN',
    _404NotFound: '404 NOT_FOUND',
    _405MethodNotAllowed: '405 METHOD_NOT_ALLOWED',
    _406NotAcceptable: '406 NOT_ACCEPTABLE',
    _407ProxyAuthenticationRequired: '407 PROXY_AUTHENTICATION_REQUIRED',
    _408RequestTimeout: '408 REQUEST_TIMEOUT',
    _409Conflict: '409 CONFLICT',
    _410Gone: '410 GONE',
    _411LengthRequired: '411 LENGTH_REQUIRED',
    _412PreconditionFailed: '412 PRECONDITION_FAILED',
    _413PayloadTooLarge: '413 PAYLOAD_TOO_LARGE',
    _413RequestEntityTooLarge: '413 REQUEST_ENTITY_TOO_LARGE',
    _414UriTooLong: '414 URI_TOO_LONG',
    _414RequestUriTooLong: '414 REQUEST_URI_TOO_LONG',
    _415UnsupportedMediaType: '415 UNSUPPORTED_MEDIA_TYPE',
    _416RequestedRangeNotSatisfiable: '416 REQUESTED_RANGE_NOT_SATISFIABLE',
    _417ExpectationFailed: '417 EXPECTATION_FAILED',
    _418IAmATeapot: '418 I_AM_A_TEAPOT',
    _419InsufficientSpaceOnResource: '419 INSUFFICIENT_SPACE_ON_RESOURCE',
    _420MethodFailure: '420 METHOD_FAILURE',
    _421DestinationLocked: '421 DESTINATION_LOCKED',
    _422UnprocessableEntity: '422 UNPROCESSABLE_ENTITY',
    _423Locked: '423 LOCKED',
    _424FailedDependency: '424 FAILED_DEPENDENCY',
    _425TooEarly: '425 TOO_EARLY',
    _426UpgradeRequired: '426 UPGRADE_REQUIRED',
    _428PreconditionRequired: '428 PRECONDITION_REQUIRED',
    _429TooManyRequests: '429 TOO_MANY_REQUESTS',
    _431RequestHeaderFieldsTooLarge: '431 REQUEST_HEADER_FIELDS_TOO_LARGE',
    _451UnavailableForLegalReasons: '451 UNAVAILABLE_FOR_LEGAL_REASONS',
    _500InternalServerError: '500 INTERNAL_SERVER_ERROR',
    _501NotImplemented: '501 NOT_IMPLEMENTED',
    _502BadGateway: '502 BAD_GATEWAY',
    _503ServiceUnavailable: '503 SERVICE_UNAVAILABLE',
    _504GatewayTimeout: '504 GATEWAY_TIMEOUT',
    _505HttpVersionNotSupported: '505 HTTP_VERSION_NOT_SUPPORTED',
    _506VariantAlsoNegotiates: '506 VARIANT_ALSO_NEGOTIATES',
    _507InsufficientStorage: '507 INSUFFICIENT_STORAGE',
    _508LoopDetected: '508 LOOP_DETECTED',
    _509BandwidthLimitExceeded: '509 BANDWIDTH_LIMIT_EXCEEDED',
    _510NotExtended: '510 NOT_EXTENDED',
    _511NetworkAuthenticationRequired: '511 NETWORK_AUTHENTICATION_REQUIRED'
} as const;

export type ApiResponseDtoListBankStatusEnum = typeof ApiResponseDtoListBankStatusEnum[keyof typeof ApiResponseDtoListBankStatusEnum];

/**
 * 
 * @export
 * @interface ApiResponseDtoListCountry
 */
export interface ApiResponseDtoListCountry {
    /**
     * 
     * @type {boolean}
     * @memberof ApiResponseDtoListCountry
     */
    'success'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof ApiResponseDtoListCountry
     */
    'code'?: number;
    /**
     * 
     * @type {string}
     * @memberof ApiResponseDtoListCountry
     */
    'status'?: ApiResponseDtoListCountryStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof ApiResponseDtoListCountry
     */
    'message'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof ApiResponseDtoListCountry
     */
    'data'?: Array<ApiResponseDtoListCountryDataEnum>;
    /**
     * 
     * @type {{ [key: string]: object; }}
     * @memberof ApiResponseDtoListCountry
     */
    'meta'?: { [key: string]: object; };
}

export const ApiResponseDtoListCountryStatusEnum = {
    _100Continue: '100 CONTINUE',
    _101SwitchingProtocols: '101 SWITCHING_PROTOCOLS',
    _102Processing: '102 PROCESSING',
    _103EarlyHints: '103 EARLY_HINTS',
    _103Checkpoint: '103 CHECKPOINT',
    _200Ok: '200 OK',
    _201Created: '201 CREATED',
    _202Accepted: '202 ACCEPTED',
    _203NonAuthoritativeInformation: '203 NON_AUTHORITATIVE_INFORMATION',
    _204NoContent: '204 NO_CONTENT',
    _205ResetContent: '205 RESET_CONTENT',
    _206PartialContent: '206 PARTIAL_CONTENT',
    _207MultiStatus: '207 MULTI_STATUS',
    _208AlreadyReported: '208 ALREADY_REPORTED',
    _226ImUsed: '226 IM_USED',
    _300MultipleChoices: '300 MULTIPLE_CHOICES',
    _301MovedPermanently: '301 MOVED_PERMANENTLY',
    _302Found: '302 FOUND',
    _302MovedTemporarily: '302 MOVED_TEMPORARILY',
    _303SeeOther: '303 SEE_OTHER',
    _304NotModified: '304 NOT_MODIFIED',
    _305UseProxy: '305 USE_PROXY',
    _307TemporaryRedirect: '307 TEMPORARY_REDIRECT',
    _308PermanentRedirect: '308 PERMANENT_REDIRECT',
    _400BadRequest: '400 BAD_REQUEST',
    _401Unauthorized: '401 UNAUTHORIZED',
    _402PaymentRequired: '402 PAYMENT_REQUIRED',
    _403Forbidden: '403 FORBIDDEN',
    _404NotFound: '404 NOT_FOUND',
    _405MethodNotAllowed: '405 METHOD_NOT_ALLOWED',
    _406NotAcceptable: '406 NOT_ACCEPTABLE',
    _407ProxyAuthenticationRequired: '407 PROXY_AUTHENTICATION_REQUIRED',
    _408RequestTimeout: '408 REQUEST_TIMEOUT',
    _409Conflict: '409 CONFLICT',
    _410Gone: '410 GONE',
    _411LengthRequired: '411 LENGTH_REQUIRED',
    _412PreconditionFailed: '412 PRECONDITION_FAILED',
    _413PayloadTooLarge: '413 PAYLOAD_TOO_LARGE',
    _413RequestEntityTooLarge: '413 REQUEST_ENTITY_TOO_LARGE',
    _414UriTooLong: '414 URI_TOO_LONG',
    _414RequestUriTooLong: '414 REQUEST_URI_TOO_LONG',
    _415UnsupportedMediaType: '415 UNSUPPORTED_MEDIA_TYPE',
    _416RequestedRangeNotSatisfiable: '416 REQUESTED_RANGE_NOT_SATISFIABLE',
    _417ExpectationFailed: '417 EXPECTATION_FAILED',
    _418IAmATeapot: '418 I_AM_A_TEAPOT',
    _419InsufficientSpaceOnResource: '419 INSUFFICIENT_SPACE_ON_RESOURCE',
    _420MethodFailure: '420 METHOD_FAILURE',
    _421DestinationLocked: '421 DESTINATION_LOCKED',
    _422UnprocessableEntity: '422 UNPROCESSABLE_ENTITY',
    _423Locked: '423 LOCKED',
    _424FailedDependency: '424 FAILED_DEPENDENCY',
    _425TooEarly: '425 TOO_EARLY',
    _426UpgradeRequired: '426 UPGRADE_REQUIRED',
    _428PreconditionRequired: '428 PRECONDITION_REQUIRED',
    _429TooManyRequests: '429 TOO_MANY_REQUESTS',
    _431RequestHeaderFieldsTooLarge: '431 REQUEST_HEADER_FIELDS_TOO_LARGE',
    _451UnavailableForLegalReasons: '451 UNAVAILABLE_FOR_LEGAL_REASONS',
    _500InternalServerError: '500 INTERNAL_SERVER_ERROR',
    _501NotImplemented: '501 NOT_IMPLEMENTED',
    _502BadGateway: '502 BAD_GATEWAY',
    _503ServiceUnavailable: '503 SERVICE_UNAVAILABLE',
    _504GatewayTimeout: '504 GATEWAY_TIMEOUT',
    _505HttpVersionNotSupported: '505 HTTP_VERSION_NOT_SUPPORTED',
    _506VariantAlsoNegotiates: '506 VARIANT_ALSO_NEGOTIATES',
    _507InsufficientStorage: '507 INSUFFICIENT_STORAGE',
    _508LoopDetected: '508 LOOP_DETECTED',
    _509BandwidthLimitExceeded: '509 BANDWIDTH_LIMIT_EXCEEDED',
    _510NotExtended: '510 NOT_EXTENDED',
    _511NetworkAuthenticationRequired: '511 NETWORK_AUTHENTICATION_REQUIRED'
} as const;

export type ApiResponseDtoListCountryStatusEnum = typeof ApiResponseDtoListCountryStatusEnum[keyof typeof ApiResponseDtoListCountryStatusEnum];
export const ApiResponseDtoListCountryDataEnum = {
    Afghanistan: 'AFGHANISTAN',
    Albania: 'ALBANIA',
    Algeria: 'ALGERIA',
    Andorra: 'ANDORRA',
    Angola: 'ANGOLA',
    AntiguaAndBarbuda: 'ANTIGUA_AND_BARBUDA',
    Argentina: 'ARGENTINA',
    Armenia: 'ARMENIA',
    Australia: 'AUSTRALIA',
    Austria: 'AUSTRIA',
    Azerbaijan: 'AZERBAIJAN',
    Bahamas: 'BAHAMAS',
    Bahrain: 'BAHRAIN',
    Bangladesh: 'BANGLADESH',
    Barbados: 'BARBADOS',
    Belarus: 'BELARUS',
    Belgium: 'BELGIUM',
    Belize: 'BELIZE',
    Benin: 'BENIN',
    Bhutan: 'BHUTAN',
    Bolivia: 'BOLIVIA',
    BosniaAndHerzegovina: 'BOSNIA_AND_HERZEGOVINA',
    Botswana: 'BOTSWANA',
    Brazil: 'BRAZIL',
    Brunei: 'BRUNEI',
    Bulgaria: 'BULGARIA',
    BurkinaFaso: 'BURKINA_FASO',
    Burundi: 'BURUNDI',
    Cambodia: 'CAMBODIA',
    Cameroon: 'CAMEROON',
    Canada: 'CANADA',
    CapeVerde: 'CAPE_VERDE',
    CentralAfricanRepublic: 'CENTRAL_AFRICAN_REPUBLIC',
    Chad: 'CHAD',
    Chile: 'CHILE',
    China: 'CHINA',
    Colombia: 'COLOMBIA',
    Comoros: 'COMOROS',
    Congo: 'CONGO',
    CostaRica: 'COSTA_RICA',
    CoteDivoire: 'COTE_DIVOIRE',
    Croatia: 'CROATIA',
    Cuba: 'CUBA',
    Cyprus: 'CYPRUS',
    Czechia: 'CZECHIA',
    Denmark: 'DENMARK',
    Djibouti: 'DJIBOUTI',
    Dominica: 'DOMINICA',
    DominicanRepublic: 'DOMINICAN_REPUBLIC',
    Ecuador: 'ECUADOR',
    Egypt: 'EGYPT',
    ElSalvador: 'EL_SALVADOR',
    EquatorialGuinea: 'EQUATORIAL_GUINEA',
    Eritrea: 'ERITREA',
    Estonia: 'ESTONIA',
    Eswatini: 'ESWATINI',
    Ethiopia: 'ETHIOPIA',
    Fiji: 'FIJI',
    Finland: 'FINLAND',
    France: 'FRANCE',
    Gabon: 'GABON',
    Gambia: 'GAMBIA',
    Georgia: 'GEORGIA',
    Germany: 'GERMANY',
    Ghana: 'GHANA',
    Greece: 'GREECE',
    Grenada: 'GRENADA',
    Guatemala: 'GUATEMALA',
    Guinea: 'GUINEA',
    GuineaBissau: 'GUINEA_BISSAU',
    Guyana: 'GUYANA',
    Haiti: 'HAITI',
    Honduras: 'HONDURAS',
    Hungary: 'HUNGARY',
    Iceland: 'ICELAND',
    India: 'INDIA',
    Indonesia: 'INDONESIA',
    Iran: 'IRAN',
    Iraq: 'IRAQ',
    Ireland: 'IRELAND',
    Israel: 'ISRAEL',
    Italy: 'ITALY',
    Jamaica: 'JAMAICA',
    Japan: 'JAPAN',
    Jordan: 'JORDAN',
    Kazakhstan: 'KAZAKHSTAN',
    Kenya: 'KENYA',
    Kiribati: 'KIRIBATI',
    KoreaNorth: 'KOREA_NORTH',
    KoreaSouth: 'KOREA_SOUTH',
    Kosovo: 'KOSOVO',
    Kuwait: 'KUWAIT',
    Kyrgyzstan: 'KYRGYZSTAN',
    Laos: 'LAOS',
    Latvia: 'LATVIA',
    Lebanon: 'LEBANON',
    Lesotho: 'LESOTHO',
    Liberia: 'LIBERIA',
    Libya: 'LIBYA',
    Liechtenstein: 'LIECHTENSTEIN',
    Lithuania: 'LITHUANIA',
    Luxembourg: 'LUXEMBOURG',
    Madagascar: 'MADAGASCAR',
    Malawi: 'MALAWI',
    Malaysia: 'MALAYSIA',
    Maldives: 'MALDIVES',
    Mali: 'MALI',
    Malta: 'MALTA',
    MarshallIslands: 'MARSHALL_ISLANDS',
    Mauritania: 'MAURITANIA',
    Mauritius: 'MAURITIUS',
    Mexico: 'MEXICO',
    Micronesia: 'MICRONESIA',
    Moldova: 'MOLDOVA',
    Monaco: 'MONACO',
    Mongolia: 'MONGOLIA',
    Montenegro: 'MONTENEGRO',
    Morocco: 'MOROCCO',
    Mozambique: 'MOZAMBIQUE',
    Myanmar: 'MYANMAR',
    Namibia: 'NAMIBIA',
    Nauru: 'NAURU',
    Nepal: 'NEPAL',
    Netherlands: 'NETHERLANDS',
    NewZealand: 'NEW_ZEALAND',
    Nicaragua: 'NICARAGUA',
    Niger: 'NIGER',
    Nigeria: 'NIGERIA',
    NorthMacedonia: 'NORTH_MACEDONIA',
    Norway: 'NORWAY',
    Oman: 'OMAN',
    Pakistan: 'PAKISTAN',
    Palau: 'PALAU',
    Panama: 'PANAMA',
    PapuaNewGuinea: 'PAPUA_NEW_GUINEA',
    Paraguay: 'PARAGUAY',
    Peru: 'PERU',
    Philippines: 'PHILIPPINES',
    Poland: 'POLAND',
    Portugal: 'PORTUGAL',
    Qatar: 'QATAR',
    Romania: 'ROMANIA',
    Russia: 'RUSSIA',
    Rwanda: 'RWANDA',
    SaintKittsAndNevis: 'SAINT_KITTS_AND_NEVIS',
    SaintLucia: 'SAINT_LUCIA',
    SaintVincentAndTheGrenadines: 'SAINT_VINCENT_AND_THE_GRENADINES',
    Samoa: 'SAMOA',
    SanMarino: 'SAN_MARINO',
    SaoTomeAndPrincipe: 'SAO_TOME_AND_PRINCIPE',
    SaudiArabia: 'SAUDI_ARABIA',
    Senegal: 'SENEGAL',
    Serbia: 'SERBIA',
    Seychelles: 'SEYCHELLES',
    SierraLeone: 'SIERRA_LEONE',
    Singapore: 'SINGAPORE',
    Slovakia: 'SLOVAKIA',
    Slovenia: 'SLOVENIA',
    SolomonIslands: 'SOLOMON_ISLANDS',
    Somalia: 'SOMALIA',
    SouthAfrica: 'SOUTH_AFRICA',
    SouthSudan: 'SOUTH_SUDAN',
    Spain: 'SPAIN',
    SriLanka: 'SRI_LANKA',
    Sudan: 'SUDAN',
    Suriname: 'SURINAME',
    Sweden: 'SWEDEN',
    Switzerland: 'SWITZERLAND',
    Syria: 'SYRIA',
    Taiwan: 'TAIWAN',
    Tajikistan: 'TAJIKISTAN',
    Tanzania: 'TANZANIA',
    Thailand: 'THAILAND',
    TimorLeste: 'TIMOR_LESTE',
    Togo: 'TOGO',
    Tonga: 'TONGA',
    TrinidadAndTobago: 'TRINIDAD_AND_TOBAGO',
    Tunisia: 'TUNISIA',
    Turkey: 'TURKEY',
    Turkmenistan: 'TURKMENISTAN',
    Tuvalu: 'TUVALU',
    Uganda: 'UGANDA',
    Ukraine: 'UKRAINE',
    UnitedArabEmirates: 'UNITED_ARAB_EMIRATES',
    UnitedKingdom: 'UNITED_KINGDOM',
    UnitedStates: 'UNITED_STATES',
    Uruguay: 'URUGUAY',
    Uzbekistan: 'UZBEKISTAN',
    Vanuatu: 'VANUATU',
    VaticanCity: 'VATICAN_CITY',
    Venezuela: 'VENEZUELA',
    Vietnam: 'VIETNAM',
    Yemen: 'YEMEN',
    Zambia: 'ZAMBIA',
    Zimbabwe: 'ZIMBABWE'
} as const;

export type ApiResponseDtoListCountryDataEnum = typeof ApiResponseDtoListCountryDataEnum[keyof typeof ApiResponseDtoListCountryDataEnum];

/**
 * 
 * @export
 * @interface ApiResponseDtoListLanguage
 */
export interface ApiResponseDtoListLanguage {
    /**
     * 
     * @type {boolean}
     * @memberof ApiResponseDtoListLanguage
     */
    'success'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof ApiResponseDtoListLanguage
     */
    'code'?: number;
    /**
     * 
     * @type {string}
     * @memberof ApiResponseDtoListLanguage
     */
    'status'?: ApiResponseDtoListLanguageStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof ApiResponseDtoListLanguage
     */
    'message'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof ApiResponseDtoListLanguage
     */
    'data'?: Array<ApiResponseDtoListLanguageDataEnum>;
    /**
     * 
     * @type {{ [key: string]: object; }}
     * @memberof ApiResponseDtoListLanguage
     */
    'meta'?: { [key: string]: object; };
}

export const ApiResponseDtoListLanguageStatusEnum = {
    _100Continue: '100 CONTINUE',
    _101SwitchingProtocols: '101 SWITCHING_PROTOCOLS',
    _102Processing: '102 PROCESSING',
    _103EarlyHints: '103 EARLY_HINTS',
    _103Checkpoint: '103 CHECKPOINT',
    _200Ok: '200 OK',
    _201Created: '201 CREATED',
    _202Accepted: '202 ACCEPTED',
    _203NonAuthoritativeInformation: '203 NON_AUTHORITATIVE_INFORMATION',
    _204NoContent: '204 NO_CONTENT',
    _205ResetContent: '205 RESET_CONTENT',
    _206PartialContent: '206 PARTIAL_CONTENT',
    _207MultiStatus: '207 MULTI_STATUS',
    _208AlreadyReported: '208 ALREADY_REPORTED',
    _226ImUsed: '226 IM_USED',
    _300MultipleChoices: '300 MULTIPLE_CHOICES',
    _301MovedPermanently: '301 MOVED_PERMANENTLY',
    _302Found: '302 FOUND',
    _302MovedTemporarily: '302 MOVED_TEMPORARILY',
    _303SeeOther: '303 SEE_OTHER',
    _304NotModified: '304 NOT_MODIFIED',
    _305UseProxy: '305 USE_PROXY',
    _307TemporaryRedirect: '307 TEMPORARY_REDIRECT',
    _308PermanentRedirect: '308 PERMANENT_REDIRECT',
    _400BadRequest: '400 BAD_REQUEST',
    _401Unauthorized: '401 UNAUTHORIZED',
    _402PaymentRequired: '402 PAYMENT_REQUIRED',
    _403Forbidden: '403 FORBIDDEN',
    _404NotFound: '404 NOT_FOUND',
    _405MethodNotAllowed: '405 METHOD_NOT_ALLOWED',
    _406NotAcceptable: '406 NOT_ACCEPTABLE',
    _407ProxyAuthenticationRequired: '407 PROXY_AUTHENTICATION_REQUIRED',
    _408RequestTimeout: '408 REQUEST_TIMEOUT',
    _409Conflict: '409 CONFLICT',
    _410Gone: '410 GONE',
    _411LengthRequired: '411 LENGTH_REQUIRED',
    _412PreconditionFailed: '412 PRECONDITION_FAILED',
    _413PayloadTooLarge: '413 PAYLOAD_TOO_LARGE',
    _413RequestEntityTooLarge: '413 REQUEST_ENTITY_TOO_LARGE',
    _414UriTooLong: '414 URI_TOO_LONG',
    _414RequestUriTooLong: '414 REQUEST_URI_TOO_LONG',
    _415UnsupportedMediaType: '415 UNSUPPORTED_MEDIA_TYPE',
    _416RequestedRangeNotSatisfiable: '416 REQUESTED_RANGE_NOT_SATISFIABLE',
    _417ExpectationFailed: '417 EXPECTATION_FAILED',
    _418IAmATeapot: '418 I_AM_A_TEAPOT',
    _419InsufficientSpaceOnResource: '419 INSUFFICIENT_SPACE_ON_RESOURCE',
    _420MethodFailure: '420 METHOD_FAILURE',
    _421DestinationLocked: '421 DESTINATION_LOCKED',
    _422UnprocessableEntity: '422 UNPROCESSABLE_ENTITY',
    _423Locked: '423 LOCKED',
    _424FailedDependency: '424 FAILED_DEPENDENCY',
    _425TooEarly: '425 TOO_EARLY',
    _426UpgradeRequired: '426 UPGRADE_REQUIRED',
    _428PreconditionRequired: '428 PRECONDITION_REQUIRED',
    _429TooManyRequests: '429 TOO_MANY_REQUESTS',
    _431RequestHeaderFieldsTooLarge: '431 REQUEST_HEADER_FIELDS_TOO_LARGE',
    _451UnavailableForLegalReasons: '451 UNAVAILABLE_FOR_LEGAL_REASONS',
    _500InternalServerError: '500 INTERNAL_SERVER_ERROR',
    _501NotImplemented: '501 NOT_IMPLEMENTED',
    _502BadGateway: '502 BAD_GATEWAY',
    _503ServiceUnavailable: '503 SERVICE_UNAVAILABLE',
    _504GatewayTimeout: '504 GATEWAY_TIMEOUT',
    _505HttpVersionNotSupported: '505 HTTP_VERSION_NOT_SUPPORTED',
    _506VariantAlsoNegotiates: '506 VARIANT_ALSO_NEGOTIATES',
    _507InsufficientStorage: '507 INSUFFICIENT_STORAGE',
    _508LoopDetected: '508 LOOP_DETECTED',
    _509BandwidthLimitExceeded: '509 BANDWIDTH_LIMIT_EXCEEDED',
    _510NotExtended: '510 NOT_EXTENDED',
    _511NetworkAuthenticationRequired: '511 NETWORK_AUTHENTICATION_REQUIRED'
} as const;

export type ApiResponseDtoListLanguageStatusEnum = typeof ApiResponseDtoListLanguageStatusEnum[keyof typeof ApiResponseDtoListLanguageStatusEnum];
export const ApiResponseDtoListLanguageDataEnum = {
    Afrikaans: 'AFRIKAANS',
    Albanian: 'ALBANIAN',
    Amharic: 'AMHARIC',
    Arabic: 'ARABIC',
    ArabicEgyptian: 'ARABIC_EGYPTIAN',
    Armenian: 'ARMENIAN',
    Azerbaijani: 'AZERBAIJANI',
    Balochi: 'BALOCHI',
    Basque: 'BASQUE',
    Belarusian: 'BELARUSIAN',
    Bengali: 'BENGALI',
    Bhojpuri: 'BHOJPURI',
    Bosnian: 'BOSNIAN',
    Breton: 'BRETON',
    Bulgarian: 'BULGARIAN',
    Burmese: 'BURMESE',
    Chewa: 'CHEWA',
    Chhattisgarhi: 'CHHATTISGARHI',
    Chopi: 'CHOPI',
    Croatian: 'CROATIAN',
    Czech: 'CZECH',
    Danish: 'DANISH',
    Dhundhari: 'DHUNDHARI',
    Dutch: 'DUTCH',
    English: 'ENGLISH',
    Estonian: 'ESTONIAN',
    Faroese: 'FAROESE',
    Farsi: 'FARSI',
    Finnish: 'FINNISH',
    French: 'FRENCH',
    Fula: 'FULA',
    Ganda: 'GANDA',
    Georgian: 'GEORGIAN',
    German: 'GERMAN',
    Greek: 'GREEK',
    Greenlandic: 'GREENLANDIC',
    Gujarati: 'GUJARATI',
    HaitianCreole: 'HAITIAN_CREOLE',
    Hausa: 'HAUSA',
    Herero: 'HERERO',
    Hiligaynon: 'HILIGAYNON',
    Hindi: 'HINDI',
    Hmong: 'HMONG',
    Hungarian: 'HUNGARIAN',
    Icelandic: 'ICELANDIC',
    Igbo: 'IGBO',
    Ilocano: 'ILOCANO',
    Indonesian: 'INDONESIAN',
    Irish: 'IRISH',
    Italian: 'ITALIAN',
    Javanese: 'JAVANESE',
    Japanese: 'JAPANESE',
    Kabyle: 'KABYLE',
    Kannada: 'KANNADA',
    Kazakh: 'KAZAKH',
    Kikongo: 'KIKONGO',
    Kinyarwanda: 'KINYARWANDA',
    Kirundi: 'KIRUNDI',
    Konkani: 'KONKANI',
    Korean: 'KOREAN',
    Kurdish: 'KURDISH',
    Latvian: 'LATVIAN',
    Lingala: 'LINGALA',
    Lithuanian: 'LITHUANIAN',
    Luxembourgish: 'LUXEMBOURGISH',
    Macedonian: 'MACEDONIAN',
    Maithili: 'MAITHILI',
    Malay: 'MALAY',
    Malayalam: 'MALAYALAM',
    Maltese: 'MALTESE',
    Mandarin: 'MANDARIN',
    Marathi: 'MARATHI',
    Mongolian: 'MONGOLIAN',
    Mossi: 'MOSSI',
    Nama: 'NAMA',
    Ndebele: 'NDEBELE',
    Nepali: 'NEPALI',
    Norwegian: 'NORWEGIAN',
    Oriya: 'ORIYA',
    Oshiwambo: 'OSHIWAMBO',
    Pashto: 'PASHTO',
    Persian: 'PERSIAN',
    Polish: 'POLISH',
    Portuguese: 'PORTUGUESE',
    Quechua: 'QUECHUA',
    Romanian: 'ROMANIAN',
    Ronga: 'RONGA',
    Russian: 'RUSSIAN',
    Sami: 'SAMI',
    San: 'SAN',
    ScotsGaelic: 'SCOTS_GAELIC',
    Serbian: 'SERBIAN',
    SerboCroatian: 'SERBO_CROATIAN',
    Shona: 'SHONA',
    Sinhala: 'SINHALA',
    Slovak: 'SLOVAK',
    Somali: 'SOMALI',
    Soninke: 'SONINKE',
    Sotho: 'SOTHO',
    SouthernMin: 'SOUTHERN_MIN',
    Spanish: 'SPANISH',
    Sundanese: 'SUNDANESE',
    Swahili: 'SWAHILI',
    Swazi: 'SWAZI',
    Swedish: 'SWEDISH',
    Tamashek: 'TAMASHEK',
    Tamil: 'TAMIL',
    Tatar: 'TATAR',
    Telugu: 'TELUGU',
    Thai: 'THAI',
    Tigrinya: 'TIGRINYA',
    Tswa: 'TSWA',
    Tswana: 'TSWANA',
    Turkish: 'TURKISH',
    Uyghur: 'UYGHUR',
    Urdu: 'URDU',
    Uzbek: 'UZBEK',
    Venda: 'VENDA',
    Vietnamese: 'VIETNAMESE',
    Welsh: 'WELSH',
    Wolof: 'WOLOF',
    Xhosa: 'XHOSA',
    Yoruba: 'YORUBA',
    Yue: 'YUE',
    Zulu: 'ZULU'
} as const;

export type ApiResponseDtoListLanguageDataEnum = typeof ApiResponseDtoListLanguageDataEnum[keyof typeof ApiResponseDtoListLanguageDataEnum];

/**
 * 
 * @export
 * @interface ApiResponseDtoListOrganizationType
 */
export interface ApiResponseDtoListOrganizationType {
    /**
     * 
     * @type {boolean}
     * @memberof ApiResponseDtoListOrganizationType
     */
    'success'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof ApiResponseDtoListOrganizationType
     */
    'code'?: number;
    /**
     * 
     * @type {string}
     * @memberof ApiResponseDtoListOrganizationType
     */
    'status'?: ApiResponseDtoListOrganizationTypeStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof ApiResponseDtoListOrganizationType
     */
    'message'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof ApiResponseDtoListOrganizationType
     */
    'data'?: Array<ApiResponseDtoListOrganizationTypeDataEnum>;
    /**
     * 
     * @type {{ [key: string]: object; }}
     * @memberof ApiResponseDtoListOrganizationType
     */
    'meta'?: { [key: string]: object; };
}

export const ApiResponseDtoListOrganizationTypeStatusEnum = {
    _100Continue: '100 CONTINUE',
    _101SwitchingProtocols: '101 SWITCHING_PROTOCOLS',
    _102Processing: '102 PROCESSING',
    _103EarlyHints: '103 EARLY_HINTS',
    _103Checkpoint: '103 CHECKPOINT',
    _200Ok: '200 OK',
    _201Created: '201 CREATED',
    _202Accepted: '202 ACCEPTED',
    _203NonAuthoritativeInformation: '203 NON_AUTHORITATIVE_INFORMATION',
    _204NoContent: '204 NO_CONTENT',
    _205ResetContent: '205 RESET_CONTENT',
    _206PartialContent: '206 PARTIAL_CONTENT',
    _207MultiStatus: '207 MULTI_STATUS',
    _208AlreadyReported: '208 ALREADY_REPORTED',
    _226ImUsed: '226 IM_USED',
    _300MultipleChoices: '300 MULTIPLE_CHOICES',
    _301MovedPermanently: '301 MOVED_PERMANENTLY',
    _302Found: '302 FOUND',
    _302MovedTemporarily: '302 MOVED_TEMPORARILY',
    _303SeeOther: '303 SEE_OTHER',
    _304NotModified: '304 NOT_MODIFIED',
    _305UseProxy: '305 USE_PROXY',
    _307TemporaryRedirect: '307 TEMPORARY_REDIRECT',
    _308PermanentRedirect: '308 PERMANENT_REDIRECT',
    _400BadRequest: '400 BAD_REQUEST',
    _401Unauthorized: '401 UNAUTHORIZED',
    _402PaymentRequired: '402 PAYMENT_REQUIRED',
    _403Forbidden: '403 FORBIDDEN',
    _404NotFound: '404 NOT_FOUND',
    _405MethodNotAllowed: '405 METHOD_NOT_ALLOWED',
    _406NotAcceptable: '406 NOT_ACCEPTABLE',
    _407ProxyAuthenticationRequired: '407 PROXY_AUTHENTICATION_REQUIRED',
    _408RequestTimeout: '408 REQUEST_TIMEOUT',
    _409Conflict: '409 CONFLICT',
    _410Gone: '410 GONE',
    _411LengthRequired: '411 LENGTH_REQUIRED',
    _412PreconditionFailed: '412 PRECONDITION_FAILED',
    _413PayloadTooLarge: '413 PAYLOAD_TOO_LARGE',
    _413RequestEntityTooLarge: '413 REQUEST_ENTITY_TOO_LARGE',
    _414UriTooLong: '414 URI_TOO_LONG',
    _414RequestUriTooLong: '414 REQUEST_URI_TOO_LONG',
    _415UnsupportedMediaType: '415 UNSUPPORTED_MEDIA_TYPE',
    _416RequestedRangeNotSatisfiable: '416 REQUESTED_RANGE_NOT_SATISFIABLE',
    _417ExpectationFailed: '417 EXPECTATION_FAILED',
    _418IAmATeapot: '418 I_AM_A_TEAPOT',
    _419InsufficientSpaceOnResource: '419 INSUFFICIENT_SPACE_ON_RESOURCE',
    _420MethodFailure: '420 METHOD_FAILURE',
    _421DestinationLocked: '421 DESTINATION_LOCKED',
    _422UnprocessableEntity: '422 UNPROCESSABLE_ENTITY',
    _423Locked: '423 LOCKED',
    _424FailedDependency: '424 FAILED_DEPENDENCY',
    _425TooEarly: '425 TOO_EARLY',
    _426UpgradeRequired: '426 UPGRADE_REQUIRED',
    _428PreconditionRequired: '428 PRECONDITION_REQUIRED',
    _429TooManyRequests: '429 TOO_MANY_REQUESTS',
    _431RequestHeaderFieldsTooLarge: '431 REQUEST_HEADER_FIELDS_TOO_LARGE',
    _451UnavailableForLegalReasons: '451 UNAVAILABLE_FOR_LEGAL_REASONS',
    _500InternalServerError: '500 INTERNAL_SERVER_ERROR',
    _501NotImplemented: '501 NOT_IMPLEMENTED',
    _502BadGateway: '502 BAD_GATEWAY',
    _503ServiceUnavailable: '503 SERVICE_UNAVAILABLE',
    _504GatewayTimeout: '504 GATEWAY_TIMEOUT',
    _505HttpVersionNotSupported: '505 HTTP_VERSION_NOT_SUPPORTED',
    _506VariantAlsoNegotiates: '506 VARIANT_ALSO_NEGOTIATES',
    _507InsufficientStorage: '507 INSUFFICIENT_STORAGE',
    _508LoopDetected: '508 LOOP_DETECTED',
    _509BandwidthLimitExceeded: '509 BANDWIDTH_LIMIT_EXCEEDED',
    _510NotExtended: '510 NOT_EXTENDED',
    _511NetworkAuthenticationRequired: '511 NETWORK_AUTHENTICATION_REQUIRED'
} as const;

export type ApiResponseDtoListOrganizationTypeStatusEnum = typeof ApiResponseDtoListOrganizationTypeStatusEnum[keyof typeof ApiResponseDtoListOrganizationTypeStatusEnum];
export const ApiResponseDtoListOrganizationTypeDataEnum = {
    Private: 'PRIVATE',
    Government: 'GOVERNMENT',
    Ngo: 'NGO'
} as const;

export type ApiResponseDtoListOrganizationTypeDataEnum = typeof ApiResponseDtoListOrganizationTypeDataEnum[keyof typeof ApiResponseDtoListOrganizationTypeDataEnum];

/**
 * 
 * @export
 * @interface ApiResponseDtoListString
 */
export interface ApiResponseDtoListString {
    /**
     * 
     * @type {boolean}
     * @memberof ApiResponseDtoListString
     */
    'success'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof ApiResponseDtoListString
     */
    'code'?: number;
    /**
     * 
     * @type {string}
     * @memberof ApiResponseDtoListString
     */
    'status'?: ApiResponseDtoListStringStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof ApiResponseDtoListString
     */
    'message'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof ApiResponseDtoListString
     */
    'data'?: Array<string>;
    /**
     * 
     * @type {{ [key: string]: object; }}
     * @memberof ApiResponseDtoListString
     */
    'meta'?: { [key: string]: object; };
}

export const ApiResponseDtoListStringStatusEnum = {
    _100Continue: '100 CONTINUE',
    _101SwitchingProtocols: '101 SWITCHING_PROTOCOLS',
    _102Processing: '102 PROCESSING',
    _103EarlyHints: '103 EARLY_HINTS',
    _103Checkpoint: '103 CHECKPOINT',
    _200Ok: '200 OK',
    _201Created: '201 CREATED',
    _202Accepted: '202 ACCEPTED',
    _203NonAuthoritativeInformation: '203 NON_AUTHORITATIVE_INFORMATION',
    _204NoContent: '204 NO_CONTENT',
    _205ResetContent: '205 RESET_CONTENT',
    _206PartialContent: '206 PARTIAL_CONTENT',
    _207MultiStatus: '207 MULTI_STATUS',
    _208AlreadyReported: '208 ALREADY_REPORTED',
    _226ImUsed: '226 IM_USED',
    _300MultipleChoices: '300 MULTIPLE_CHOICES',
    _301MovedPermanently: '301 MOVED_PERMANENTLY',
    _302Found: '302 FOUND',
    _302MovedTemporarily: '302 MOVED_TEMPORARILY',
    _303SeeOther: '303 SEE_OTHER',
    _304NotModified: '304 NOT_MODIFIED',
    _305UseProxy: '305 USE_PROXY',
    _307TemporaryRedirect: '307 TEMPORARY_REDIRECT',
    _308PermanentRedirect: '308 PERMANENT_REDIRECT',
    _400BadRequest: '400 BAD_REQUEST',
    _401Unauthorized: '401 UNAUTHORIZED',
    _402PaymentRequired: '402 PAYMENT_REQUIRED',
    _403Forbidden: '403 FORBIDDEN',
    _404NotFound: '404 NOT_FOUND',
    _405MethodNotAllowed: '405 METHOD_NOT_ALLOWED',
    _406NotAcceptable: '406 NOT_ACCEPTABLE',
    _407ProxyAuthenticationRequired: '407 PROXY_AUTHENTICATION_REQUIRED',
    _408RequestTimeout: '408 REQUEST_TIMEOUT',
    _409Conflict: '409 CONFLICT',
    _410Gone: '410 GONE',
    _411LengthRequired: '411 LENGTH_REQUIRED',
    _412PreconditionFailed: '412 PRECONDITION_FAILED',
    _413PayloadTooLarge: '413 PAYLOAD_TOO_LARGE',
    _413RequestEntityTooLarge: '413 REQUEST_ENTITY_TOO_LARGE',
    _414UriTooLong: '414 URI_TOO_LONG',
    _414RequestUriTooLong: '414 REQUEST_URI_TOO_LONG',
    _415UnsupportedMediaType: '415 UNSUPPORTED_MEDIA_TYPE',
    _416RequestedRangeNotSatisfiable: '416 REQUESTED_RANGE_NOT_SATISFIABLE',
    _417ExpectationFailed: '417 EXPECTATION_FAILED',
    _418IAmATeapot: '418 I_AM_A_TEAPOT',
    _419InsufficientSpaceOnResource: '419 INSUFFICIENT_SPACE_ON_RESOURCE',
    _420MethodFailure: '420 METHOD_FAILURE',
    _421DestinationLocked: '421 DESTINATION_LOCKED',
    _422UnprocessableEntity: '422 UNPROCESSABLE_ENTITY',
    _423Locked: '423 LOCKED',
    _424FailedDependency: '424 FAILED_DEPENDENCY',
    _425TooEarly: '425 TOO_EARLY',
    _426UpgradeRequired: '426 UPGRADE_REQUIRED',
    _428PreconditionRequired: '428 PRECONDITION_REQUIRED',
    _429TooManyRequests: '429 TOO_MANY_REQUESTS',
    _431RequestHeaderFieldsTooLarge: '431 REQUEST_HEADER_FIELDS_TOO_LARGE',
    _451UnavailableForLegalReasons: '451 UNAVAILABLE_FOR_LEGAL_REASONS',
    _500InternalServerError: '500 INTERNAL_SERVER_ERROR',
    _501NotImplemented: '501 NOT_IMPLEMENTED',
    _502BadGateway: '502 BAD_GATEWAY',
    _503ServiceUnavailable: '503 SERVICE_UNAVAILABLE',
    _504GatewayTimeout: '504 GATEWAY_TIMEOUT',
    _505HttpVersionNotSupported: '505 HTTP_VERSION_NOT_SUPPORTED',
    _506VariantAlsoNegotiates: '506 VARIANT_ALSO_NEGOTIATES',
    _507InsufficientStorage: '507 INSUFFICIENT_STORAGE',
    _508LoopDetected: '508 LOOP_DETECTED',
    _509BandwidthLimitExceeded: '509 BANDWIDTH_LIMIT_EXCEEDED',
    _510NotExtended: '510 NOT_EXTENDED',
    _511NetworkAuthenticationRequired: '511 NETWORK_AUTHENTICATION_REQUIRED'
} as const;

export type ApiResponseDtoListStringStatusEnum = typeof ApiResponseDtoListStringStatusEnum[keyof typeof ApiResponseDtoListStringStatusEnum];

/**
 * 
 * @export
 * @interface ApiResponseDtoListTransactionResponse
 */
export interface ApiResponseDtoListTransactionResponse {
    /**
     * 
     * @type {boolean}
     * @memberof ApiResponseDtoListTransactionResponse
     */
    'success'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof ApiResponseDtoListTransactionResponse
     */
    'code'?: number;
    /**
     * 
     * @type {string}
     * @memberof ApiResponseDtoListTransactionResponse
     */
    'status'?: ApiResponseDtoListTransactionResponseStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof ApiResponseDtoListTransactionResponse
     */
    'message'?: string;
    /**
     * 
     * @type {Array<TransactionResponse>}
     * @memberof ApiResponseDtoListTransactionResponse
     */
    'data'?: Array<TransactionResponse>;
    /**
     * 
     * @type {{ [key: string]: object; }}
     * @memberof ApiResponseDtoListTransactionResponse
     */
    'meta'?: { [key: string]: object; };
}

export const ApiResponseDtoListTransactionResponseStatusEnum = {
    _100Continue: '100 CONTINUE',
    _101SwitchingProtocols: '101 SWITCHING_PROTOCOLS',
    _102Processing: '102 PROCESSING',
    _103EarlyHints: '103 EARLY_HINTS',
    _103Checkpoint: '103 CHECKPOINT',
    _200Ok: '200 OK',
    _201Created: '201 CREATED',
    _202Accepted: '202 ACCEPTED',
    _203NonAuthoritativeInformation: '203 NON_AUTHORITATIVE_INFORMATION',
    _204NoContent: '204 NO_CONTENT',
    _205ResetContent: '205 RESET_CONTENT',
    _206PartialContent: '206 PARTIAL_CONTENT',
    _207MultiStatus: '207 MULTI_STATUS',
    _208AlreadyReported: '208 ALREADY_REPORTED',
    _226ImUsed: '226 IM_USED',
    _300MultipleChoices: '300 MULTIPLE_CHOICES',
    _301MovedPermanently: '301 MOVED_PERMANENTLY',
    _302Found: '302 FOUND',
    _302MovedTemporarily: '302 MOVED_TEMPORARILY',
    _303SeeOther: '303 SEE_OTHER',
    _304NotModified: '304 NOT_MODIFIED',
    _305UseProxy: '305 USE_PROXY',
    _307TemporaryRedirect: '307 TEMPORARY_REDIRECT',
    _308PermanentRedirect: '308 PERMANENT_REDIRECT',
    _400BadRequest: '400 BAD_REQUEST',
    _401Unauthorized: '401 UNAUTHORIZED',
    _402PaymentRequired: '402 PAYMENT_REQUIRED',
    _403Forbidden: '403 FORBIDDEN',
    _404NotFound: '404 NOT_FOUND',
    _405MethodNotAllowed: '405 METHOD_NOT_ALLOWED',
    _406NotAcceptable: '406 NOT_ACCEPTABLE',
    _407ProxyAuthenticationRequired: '407 PROXY_AUTHENTICATION_REQUIRED',
    _408RequestTimeout: '408 REQUEST_TIMEOUT',
    _409Conflict: '409 CONFLICT',
    _410Gone: '410 GONE',
    _411LengthRequired: '411 LENGTH_REQUIRED',
    _412PreconditionFailed: '412 PRECONDITION_FAILED',
    _413PayloadTooLarge: '413 PAYLOAD_TOO_LARGE',
    _413RequestEntityTooLarge: '413 REQUEST_ENTITY_TOO_LARGE',
    _414UriTooLong: '414 URI_TOO_LONG',
    _414RequestUriTooLong: '414 REQUEST_URI_TOO_LONG',
    _415UnsupportedMediaType: '415 UNSUPPORTED_MEDIA_TYPE',
    _416RequestedRangeNotSatisfiable: '416 REQUESTED_RANGE_NOT_SATISFIABLE',
    _417ExpectationFailed: '417 EXPECTATION_FAILED',
    _418IAmATeapot: '418 I_AM_A_TEAPOT',
    _419InsufficientSpaceOnResource: '419 INSUFFICIENT_SPACE_ON_RESOURCE',
    _420MethodFailure: '420 METHOD_FAILURE',
    _421DestinationLocked: '421 DESTINATION_LOCKED',
    _422UnprocessableEntity: '422 UNPROCESSABLE_ENTITY',
    _423Locked: '423 LOCKED',
    _424FailedDependency: '424 FAILED_DEPENDENCY',
    _425TooEarly: '425 TOO_EARLY',
    _426UpgradeRequired: '426 UPGRADE_REQUIRED',
    _428PreconditionRequired: '428 PRECONDITION_REQUIRED',
    _429TooManyRequests: '429 TOO_MANY_REQUESTS',
    _431RequestHeaderFieldsTooLarge: '431 REQUEST_HEADER_FIELDS_TOO_LARGE',
    _451UnavailableForLegalReasons: '451 UNAVAILABLE_FOR_LEGAL_REASONS',
    _500InternalServerError: '500 INTERNAL_SERVER_ERROR',
    _501NotImplemented: '501 NOT_IMPLEMENTED',
    _502BadGateway: '502 BAD_GATEWAY',
    _503ServiceUnavailable: '503 SERVICE_UNAVAILABLE',
    _504GatewayTimeout: '504 GATEWAY_TIMEOUT',
    _505HttpVersionNotSupported: '505 HTTP_VERSION_NOT_SUPPORTED',
    _506VariantAlsoNegotiates: '506 VARIANT_ALSO_NEGOTIATES',
    _507InsufficientStorage: '507 INSUFFICIENT_STORAGE',
    _508LoopDetected: '508 LOOP_DETECTED',
    _509BandwidthLimitExceeded: '509 BANDWIDTH_LIMIT_EXCEEDED',
    _510NotExtended: '510 NOT_EXTENDED',
    _511NetworkAuthenticationRequired: '511 NETWORK_AUTHENTICATION_REQUIRED'
} as const;

export type ApiResponseDtoListTransactionResponseStatusEnum = typeof ApiResponseDtoListTransactionResponseStatusEnum[keyof typeof ApiResponseDtoListTransactionResponseStatusEnum];

/**
 * 
 * @export
 * @interface ApiResponseDtoListUsersResponse
 */
export interface ApiResponseDtoListUsersResponse {
    /**
     * 
     * @type {boolean}
     * @memberof ApiResponseDtoListUsersResponse
     */
    'success'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof ApiResponseDtoListUsersResponse
     */
    'code'?: number;
    /**
     * 
     * @type {string}
     * @memberof ApiResponseDtoListUsersResponse
     */
    'status'?: ApiResponseDtoListUsersResponseStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof ApiResponseDtoListUsersResponse
     */
    'message'?: string;
    /**
     * 
     * @type {Array<UsersResponse>}
     * @memberof ApiResponseDtoListUsersResponse
     */
    'data'?: Array<UsersResponse>;
    /**
     * 
     * @type {{ [key: string]: object; }}
     * @memberof ApiResponseDtoListUsersResponse
     */
    'meta'?: { [key: string]: object; };
}

export const ApiResponseDtoListUsersResponseStatusEnum = {
    _100Continue: '100 CONTINUE',
    _101SwitchingProtocols: '101 SWITCHING_PROTOCOLS',
    _102Processing: '102 PROCESSING',
    _103EarlyHints: '103 EARLY_HINTS',
    _103Checkpoint: '103 CHECKPOINT',
    _200Ok: '200 OK',
    _201Created: '201 CREATED',
    _202Accepted: '202 ACCEPTED',
    _203NonAuthoritativeInformation: '203 NON_AUTHORITATIVE_INFORMATION',
    _204NoContent: '204 NO_CONTENT',
    _205ResetContent: '205 RESET_CONTENT',
    _206PartialContent: '206 PARTIAL_CONTENT',
    _207MultiStatus: '207 MULTI_STATUS',
    _208AlreadyReported: '208 ALREADY_REPORTED',
    _226ImUsed: '226 IM_USED',
    _300MultipleChoices: '300 MULTIPLE_CHOICES',
    _301MovedPermanently: '301 MOVED_PERMANENTLY',
    _302Found: '302 FOUND',
    _302MovedTemporarily: '302 MOVED_TEMPORARILY',
    _303SeeOther: '303 SEE_OTHER',
    _304NotModified: '304 NOT_MODIFIED',
    _305UseProxy: '305 USE_PROXY',
    _307TemporaryRedirect: '307 TEMPORARY_REDIRECT',
    _308PermanentRedirect: '308 PERMANENT_REDIRECT',
    _400BadRequest: '400 BAD_REQUEST',
    _401Unauthorized: '401 UNAUTHORIZED',
    _402PaymentRequired: '402 PAYMENT_REQUIRED',
    _403Forbidden: '403 FORBIDDEN',
    _404NotFound: '404 NOT_FOUND',
    _405MethodNotAllowed: '405 METHOD_NOT_ALLOWED',
    _406NotAcceptable: '406 NOT_ACCEPTABLE',
    _407ProxyAuthenticationRequired: '407 PROXY_AUTHENTICATION_REQUIRED',
    _408RequestTimeout: '408 REQUEST_TIMEOUT',
    _409Conflict: '409 CONFLICT',
    _410Gone: '410 GONE',
    _411LengthRequired: '411 LENGTH_REQUIRED',
    _412PreconditionFailed: '412 PRECONDITION_FAILED',
    _413PayloadTooLarge: '413 PAYLOAD_TOO_LARGE',
    _413RequestEntityTooLarge: '413 REQUEST_ENTITY_TOO_LARGE',
    _414UriTooLong: '414 URI_TOO_LONG',
    _414RequestUriTooLong: '414 REQUEST_URI_TOO_LONG',
    _415UnsupportedMediaType: '415 UNSUPPORTED_MEDIA_TYPE',
    _416RequestedRangeNotSatisfiable: '416 REQUESTED_RANGE_NOT_SATISFIABLE',
    _417ExpectationFailed: '417 EXPECTATION_FAILED',
    _418IAmATeapot: '418 I_AM_A_TEAPOT',
    _419InsufficientSpaceOnResource: '419 INSUFFICIENT_SPACE_ON_RESOURCE',
    _420MethodFailure: '420 METHOD_FAILURE',
    _421DestinationLocked: '421 DESTINATION_LOCKED',
    _422UnprocessableEntity: '422 UNPROCESSABLE_ENTITY',
    _423Locked: '423 LOCKED',
    _424FailedDependency: '424 FAILED_DEPENDENCY',
    _425TooEarly: '425 TOO_EARLY',
    _426UpgradeRequired: '426 UPGRADE_REQUIRED',
    _428PreconditionRequired: '428 PRECONDITION_REQUIRED',
    _429TooManyRequests: '429 TOO_MANY_REQUESTS',
    _431RequestHeaderFieldsTooLarge: '431 REQUEST_HEADER_FIELDS_TOO_LARGE',
    _451UnavailableForLegalReasons: '451 UNAVAILABLE_FOR_LEGAL_REASONS',
    _500InternalServerError: '500 INTERNAL_SERVER_ERROR',
    _501NotImplemented: '501 NOT_IMPLEMENTED',
    _502BadGateway: '502 BAD_GATEWAY',
    _503ServiceUnavailable: '503 SERVICE_UNAVAILABLE',
    _504GatewayTimeout: '504 GATEWAY_TIMEOUT',
    _505HttpVersionNotSupported: '505 HTTP_VERSION_NOT_SUPPORTED',
    _506VariantAlsoNegotiates: '506 VARIANT_ALSO_NEGOTIATES',
    _507InsufficientStorage: '507 INSUFFICIENT_STORAGE',
    _508LoopDetected: '508 LOOP_DETECTED',
    _509BandwidthLimitExceeded: '509 BANDWIDTH_LIMIT_EXCEEDED',
    _510NotExtended: '510 NOT_EXTENDED',
    _511NetworkAuthenticationRequired: '511 NETWORK_AUTHENTICATION_REQUIRED'
} as const;

export type ApiResponseDtoListUsersResponseStatusEnum = typeof ApiResponseDtoListUsersResponseStatusEnum[keyof typeof ApiResponseDtoListUsersResponseStatusEnum];

/**
 * 
 * @export
 * @interface ApiResponseDtoMainWalletMetrics
 */
export interface ApiResponseDtoMainWalletMetrics {
    /**
     * 
     * @type {boolean}
     * @memberof ApiResponseDtoMainWalletMetrics
     */
    'success'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof ApiResponseDtoMainWalletMetrics
     */
    'code'?: number;
    /**
     * 
     * @type {string}
     * @memberof ApiResponseDtoMainWalletMetrics
     */
    'status'?: ApiResponseDtoMainWalletMetricsStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof ApiResponseDtoMainWalletMetrics
     */
    'message'?: string;
    /**
     * 
     * @type {MainWalletMetrics}
     * @memberof ApiResponseDtoMainWalletMetrics
     */
    'data'?: MainWalletMetrics;
    /**
     * 
     * @type {{ [key: string]: object; }}
     * @memberof ApiResponseDtoMainWalletMetrics
     */
    'meta'?: { [key: string]: object; };
}

export const ApiResponseDtoMainWalletMetricsStatusEnum = {
    _100Continue: '100 CONTINUE',
    _101SwitchingProtocols: '101 SWITCHING_PROTOCOLS',
    _102Processing: '102 PROCESSING',
    _103EarlyHints: '103 EARLY_HINTS',
    _103Checkpoint: '103 CHECKPOINT',
    _200Ok: '200 OK',
    _201Created: '201 CREATED',
    _202Accepted: '202 ACCEPTED',
    _203NonAuthoritativeInformation: '203 NON_AUTHORITATIVE_INFORMATION',
    _204NoContent: '204 NO_CONTENT',
    _205ResetContent: '205 RESET_CONTENT',
    _206PartialContent: '206 PARTIAL_CONTENT',
    _207MultiStatus: '207 MULTI_STATUS',
    _208AlreadyReported: '208 ALREADY_REPORTED',
    _226ImUsed: '226 IM_USED',
    _300MultipleChoices: '300 MULTIPLE_CHOICES',
    _301MovedPermanently: '301 MOVED_PERMANENTLY',
    _302Found: '302 FOUND',
    _302MovedTemporarily: '302 MOVED_TEMPORARILY',
    _303SeeOther: '303 SEE_OTHER',
    _304NotModified: '304 NOT_MODIFIED',
    _305UseProxy: '305 USE_PROXY',
    _307TemporaryRedirect: '307 TEMPORARY_REDIRECT',
    _308PermanentRedirect: '308 PERMANENT_REDIRECT',
    _400BadRequest: '400 BAD_REQUEST',
    _401Unauthorized: '401 UNAUTHORIZED',
    _402PaymentRequired: '402 PAYMENT_REQUIRED',
    _403Forbidden: '403 FORBIDDEN',
    _404NotFound: '404 NOT_FOUND',
    _405MethodNotAllowed: '405 METHOD_NOT_ALLOWED',
    _406NotAcceptable: '406 NOT_ACCEPTABLE',
    _407ProxyAuthenticationRequired: '407 PROXY_AUTHENTICATION_REQUIRED',
    _408RequestTimeout: '408 REQUEST_TIMEOUT',
    _409Conflict: '409 CONFLICT',
    _410Gone: '410 GONE',
    _411LengthRequired: '411 LENGTH_REQUIRED',
    _412PreconditionFailed: '412 PRECONDITION_FAILED',
    _413PayloadTooLarge: '413 PAYLOAD_TOO_LARGE',
    _413RequestEntityTooLarge: '413 REQUEST_ENTITY_TOO_LARGE',
    _414UriTooLong: '414 URI_TOO_LONG',
    _414RequestUriTooLong: '414 REQUEST_URI_TOO_LONG',
    _415UnsupportedMediaType: '415 UNSUPPORTED_MEDIA_TYPE',
    _416RequestedRangeNotSatisfiable: '416 REQUESTED_RANGE_NOT_SATISFIABLE',
    _417ExpectationFailed: '417 EXPECTATION_FAILED',
    _418IAmATeapot: '418 I_AM_A_TEAPOT',
    _419InsufficientSpaceOnResource: '419 INSUFFICIENT_SPACE_ON_RESOURCE',
    _420MethodFailure: '420 METHOD_FAILURE',
    _421DestinationLocked: '421 DESTINATION_LOCKED',
    _422UnprocessableEntity: '422 UNPROCESSABLE_ENTITY',
    _423Locked: '423 LOCKED',
    _424FailedDependency: '424 FAILED_DEPENDENCY',
    _425TooEarly: '425 TOO_EARLY',
    _426UpgradeRequired: '426 UPGRADE_REQUIRED',
    _428PreconditionRequired: '428 PRECONDITION_REQUIRED',
    _429TooManyRequests: '429 TOO_MANY_REQUESTS',
    _431RequestHeaderFieldsTooLarge: '431 REQUEST_HEADER_FIELDS_TOO_LARGE',
    _451UnavailableForLegalReasons: '451 UNAVAILABLE_FOR_LEGAL_REASONS',
    _500InternalServerError: '500 INTERNAL_SERVER_ERROR',
    _501NotImplemented: '501 NOT_IMPLEMENTED',
    _502BadGateway: '502 BAD_GATEWAY',
    _503ServiceUnavailable: '503 SERVICE_UNAVAILABLE',
    _504GatewayTimeout: '504 GATEWAY_TIMEOUT',
    _505HttpVersionNotSupported: '505 HTTP_VERSION_NOT_SUPPORTED',
    _506VariantAlsoNegotiates: '506 VARIANT_ALSO_NEGOTIATES',
    _507InsufficientStorage: '507 INSUFFICIENT_STORAGE',
    _508LoopDetected: '508 LOOP_DETECTED',
    _509BandwidthLimitExceeded: '509 BANDWIDTH_LIMIT_EXCEEDED',
    _510NotExtended: '510 NOT_EXTENDED',
    _511NetworkAuthenticationRequired: '511 NETWORK_AUTHENTICATION_REQUIRED'
} as const;

export type ApiResponseDtoMainWalletMetricsStatusEnum = typeof ApiResponseDtoMainWalletMetricsStatusEnum[keyof typeof ApiResponseDtoMainWalletMetricsStatusEnum];

/**
 * 
 * @export
 * @interface ApiResponseDtoNameEnquiryDataResponse
 */
export interface ApiResponseDtoNameEnquiryDataResponse {
    /**
     * 
     * @type {boolean}
     * @memberof ApiResponseDtoNameEnquiryDataResponse
     */
    'success'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof ApiResponseDtoNameEnquiryDataResponse
     */
    'code'?: number;
    /**
     * 
     * @type {string}
     * @memberof ApiResponseDtoNameEnquiryDataResponse
     */
    'status'?: ApiResponseDtoNameEnquiryDataResponseStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof ApiResponseDtoNameEnquiryDataResponse
     */
    'message'?: string;
    /**
     * 
     * @type {NameEnquiryDataResponse}
     * @memberof ApiResponseDtoNameEnquiryDataResponse
     */
    'data'?: NameEnquiryDataResponse;
    /**
     * 
     * @type {{ [key: string]: object; }}
     * @memberof ApiResponseDtoNameEnquiryDataResponse
     */
    'meta'?: { [key: string]: object; };
}

export const ApiResponseDtoNameEnquiryDataResponseStatusEnum = {
    _100Continue: '100 CONTINUE',
    _101SwitchingProtocols: '101 SWITCHING_PROTOCOLS',
    _102Processing: '102 PROCESSING',
    _103EarlyHints: '103 EARLY_HINTS',
    _103Checkpoint: '103 CHECKPOINT',
    _200Ok: '200 OK',
    _201Created: '201 CREATED',
    _202Accepted: '202 ACCEPTED',
    _203NonAuthoritativeInformation: '203 NON_AUTHORITATIVE_INFORMATION',
    _204NoContent: '204 NO_CONTENT',
    _205ResetContent: '205 RESET_CONTENT',
    _206PartialContent: '206 PARTIAL_CONTENT',
    _207MultiStatus: '207 MULTI_STATUS',
    _208AlreadyReported: '208 ALREADY_REPORTED',
    _226ImUsed: '226 IM_USED',
    _300MultipleChoices: '300 MULTIPLE_CHOICES',
    _301MovedPermanently: '301 MOVED_PERMANENTLY',
    _302Found: '302 FOUND',
    _302MovedTemporarily: '302 MOVED_TEMPORARILY',
    _303SeeOther: '303 SEE_OTHER',
    _304NotModified: '304 NOT_MODIFIED',
    _305UseProxy: '305 USE_PROXY',
    _307TemporaryRedirect: '307 TEMPORARY_REDIRECT',
    _308PermanentRedirect: '308 PERMANENT_REDIRECT',
    _400BadRequest: '400 BAD_REQUEST',
    _401Unauthorized: '401 UNAUTHORIZED',
    _402PaymentRequired: '402 PAYMENT_REQUIRED',
    _403Forbidden: '403 FORBIDDEN',
    _404NotFound: '404 NOT_FOUND',
    _405MethodNotAllowed: '405 METHOD_NOT_ALLOWED',
    _406NotAcceptable: '406 NOT_ACCEPTABLE',
    _407ProxyAuthenticationRequired: '407 PROXY_AUTHENTICATION_REQUIRED',
    _408RequestTimeout: '408 REQUEST_TIMEOUT',
    _409Conflict: '409 CONFLICT',
    _410Gone: '410 GONE',
    _411LengthRequired: '411 LENGTH_REQUIRED',
    _412PreconditionFailed: '412 PRECONDITION_FAILED',
    _413PayloadTooLarge: '413 PAYLOAD_TOO_LARGE',
    _413RequestEntityTooLarge: '413 REQUEST_ENTITY_TOO_LARGE',
    _414UriTooLong: '414 URI_TOO_LONG',
    _414RequestUriTooLong: '414 REQUEST_URI_TOO_LONG',
    _415UnsupportedMediaType: '415 UNSUPPORTED_MEDIA_TYPE',
    _416RequestedRangeNotSatisfiable: '416 REQUESTED_RANGE_NOT_SATISFIABLE',
    _417ExpectationFailed: '417 EXPECTATION_FAILED',
    _418IAmATeapot: '418 I_AM_A_TEAPOT',
    _419InsufficientSpaceOnResource: '419 INSUFFICIENT_SPACE_ON_RESOURCE',
    _420MethodFailure: '420 METHOD_FAILURE',
    _421DestinationLocked: '421 DESTINATION_LOCKED',
    _422UnprocessableEntity: '422 UNPROCESSABLE_ENTITY',
    _423Locked: '423 LOCKED',
    _424FailedDependency: '424 FAILED_DEPENDENCY',
    _425TooEarly: '425 TOO_EARLY',
    _426UpgradeRequired: '426 UPGRADE_REQUIRED',
    _428PreconditionRequired: '428 PRECONDITION_REQUIRED',
    _429TooManyRequests: '429 TOO_MANY_REQUESTS',
    _431RequestHeaderFieldsTooLarge: '431 REQUEST_HEADER_FIELDS_TOO_LARGE',
    _451UnavailableForLegalReasons: '451 UNAVAILABLE_FOR_LEGAL_REASONS',
    _500InternalServerError: '500 INTERNAL_SERVER_ERROR',
    _501NotImplemented: '501 NOT_IMPLEMENTED',
    _502BadGateway: '502 BAD_GATEWAY',
    _503ServiceUnavailable: '503 SERVICE_UNAVAILABLE',
    _504GatewayTimeout: '504 GATEWAY_TIMEOUT',
    _505HttpVersionNotSupported: '505 HTTP_VERSION_NOT_SUPPORTED',
    _506VariantAlsoNegotiates: '506 VARIANT_ALSO_NEGOTIATES',
    _507InsufficientStorage: '507 INSUFFICIENT_STORAGE',
    _508LoopDetected: '508 LOOP_DETECTED',
    _509BandwidthLimitExceeded: '509 BANDWIDTH_LIMIT_EXCEEDED',
    _510NotExtended: '510 NOT_EXTENDED',
    _511NetworkAuthenticationRequired: '511 NETWORK_AUTHENTICATION_REQUIRED'
} as const;

export type ApiResponseDtoNameEnquiryDataResponseStatusEnum = typeof ApiResponseDtoNameEnquiryDataResponseStatusEnum[keyof typeof ApiResponseDtoNameEnquiryDataResponseStatusEnum];

/**
 * 
 * @export
 * @interface ApiResponseDtoNinVerificationResponse
 */
export interface ApiResponseDtoNinVerificationResponse {
    /**
     * 
     * @type {boolean}
     * @memberof ApiResponseDtoNinVerificationResponse
     */
    'success'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof ApiResponseDtoNinVerificationResponse
     */
    'code'?: number;
    /**
     * 
     * @type {string}
     * @memberof ApiResponseDtoNinVerificationResponse
     */
    'status'?: ApiResponseDtoNinVerificationResponseStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof ApiResponseDtoNinVerificationResponse
     */
    'message'?: string;
    /**
     * 
     * @type {NinVerificationResponse}
     * @memberof ApiResponseDtoNinVerificationResponse
     */
    'data'?: NinVerificationResponse;
    /**
     * 
     * @type {{ [key: string]: object; }}
     * @memberof ApiResponseDtoNinVerificationResponse
     */
    'meta'?: { [key: string]: object; };
}

export const ApiResponseDtoNinVerificationResponseStatusEnum = {
    _100Continue: '100 CONTINUE',
    _101SwitchingProtocols: '101 SWITCHING_PROTOCOLS',
    _102Processing: '102 PROCESSING',
    _103EarlyHints: '103 EARLY_HINTS',
    _103Checkpoint: '103 CHECKPOINT',
    _200Ok: '200 OK',
    _201Created: '201 CREATED',
    _202Accepted: '202 ACCEPTED',
    _203NonAuthoritativeInformation: '203 NON_AUTHORITATIVE_INFORMATION',
    _204NoContent: '204 NO_CONTENT',
    _205ResetContent: '205 RESET_CONTENT',
    _206PartialContent: '206 PARTIAL_CONTENT',
    _207MultiStatus: '207 MULTI_STATUS',
    _208AlreadyReported: '208 ALREADY_REPORTED',
    _226ImUsed: '226 IM_USED',
    _300MultipleChoices: '300 MULTIPLE_CHOICES',
    _301MovedPermanently: '301 MOVED_PERMANENTLY',
    _302Found: '302 FOUND',
    _302MovedTemporarily: '302 MOVED_TEMPORARILY',
    _303SeeOther: '303 SEE_OTHER',
    _304NotModified: '304 NOT_MODIFIED',
    _305UseProxy: '305 USE_PROXY',
    _307TemporaryRedirect: '307 TEMPORARY_REDIRECT',
    _308PermanentRedirect: '308 PERMANENT_REDIRECT',
    _400BadRequest: '400 BAD_REQUEST',
    _401Unauthorized: '401 UNAUTHORIZED',
    _402PaymentRequired: '402 PAYMENT_REQUIRED',
    _403Forbidden: '403 FORBIDDEN',
    _404NotFound: '404 NOT_FOUND',
    _405MethodNotAllowed: '405 METHOD_NOT_ALLOWED',
    _406NotAcceptable: '406 NOT_ACCEPTABLE',
    _407ProxyAuthenticationRequired: '407 PROXY_AUTHENTICATION_REQUIRED',
    _408RequestTimeout: '408 REQUEST_TIMEOUT',
    _409Conflict: '409 CONFLICT',
    _410Gone: '410 GONE',
    _411LengthRequired: '411 LENGTH_REQUIRED',
    _412PreconditionFailed: '412 PRECONDITION_FAILED',
    _413PayloadTooLarge: '413 PAYLOAD_TOO_LARGE',
    _413RequestEntityTooLarge: '413 REQUEST_ENTITY_TOO_LARGE',
    _414UriTooLong: '414 URI_TOO_LONG',
    _414RequestUriTooLong: '414 REQUEST_URI_TOO_LONG',
    _415UnsupportedMediaType: '415 UNSUPPORTED_MEDIA_TYPE',
    _416RequestedRangeNotSatisfiable: '416 REQUESTED_RANGE_NOT_SATISFIABLE',
    _417ExpectationFailed: '417 EXPECTATION_FAILED',
    _418IAmATeapot: '418 I_AM_A_TEAPOT',
    _419InsufficientSpaceOnResource: '419 INSUFFICIENT_SPACE_ON_RESOURCE',
    _420MethodFailure: '420 METHOD_FAILURE',
    _421DestinationLocked: '421 DESTINATION_LOCKED',
    _422UnprocessableEntity: '422 UNPROCESSABLE_ENTITY',
    _423Locked: '423 LOCKED',
    _424FailedDependency: '424 FAILED_DEPENDENCY',
    _425TooEarly: '425 TOO_EARLY',
    _426UpgradeRequired: '426 UPGRADE_REQUIRED',
    _428PreconditionRequired: '428 PRECONDITION_REQUIRED',
    _429TooManyRequests: '429 TOO_MANY_REQUESTS',
    _431RequestHeaderFieldsTooLarge: '431 REQUEST_HEADER_FIELDS_TOO_LARGE',
    _451UnavailableForLegalReasons: '451 UNAVAILABLE_FOR_LEGAL_REASONS',
    _500InternalServerError: '500 INTERNAL_SERVER_ERROR',
    _501NotImplemented: '501 NOT_IMPLEMENTED',
    _502BadGateway: '502 BAD_GATEWAY',
    _503ServiceUnavailable: '503 SERVICE_UNAVAILABLE',
    _504GatewayTimeout: '504 GATEWAY_TIMEOUT',
    _505HttpVersionNotSupported: '505 HTTP_VERSION_NOT_SUPPORTED',
    _506VariantAlsoNegotiates: '506 VARIANT_ALSO_NEGOTIATES',
    _507InsufficientStorage: '507 INSUFFICIENT_STORAGE',
    _508LoopDetected: '508 LOOP_DETECTED',
    _509BandwidthLimitExceeded: '509 BANDWIDTH_LIMIT_EXCEEDED',
    _510NotExtended: '510 NOT_EXTENDED',
    _511NetworkAuthenticationRequired: '511 NETWORK_AUTHENTICATION_REQUIRED'
} as const;

export type ApiResponseDtoNinVerificationResponseStatusEnum = typeof ApiResponseDtoNinVerificationResponseStatusEnum[keyof typeof ApiResponseDtoNinVerificationResponseStatusEnum];

/**
 * 
 * @export
 * @interface ApiResponseDtoSignInResponse
 */
export interface ApiResponseDtoSignInResponse {
    /**
     * 
     * @type {boolean}
     * @memberof ApiResponseDtoSignInResponse
     */
    'success'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof ApiResponseDtoSignInResponse
     */
    'code'?: number;
    /**
     * 
     * @type {string}
     * @memberof ApiResponseDtoSignInResponse
     */
    'status'?: ApiResponseDtoSignInResponseStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof ApiResponseDtoSignInResponse
     */
    'message'?: string;
    /**
     * 
     * @type {SignInResponse}
     * @memberof ApiResponseDtoSignInResponse
     */
    'data'?: SignInResponse;
    /**
     * 
     * @type {{ [key: string]: object; }}
     * @memberof ApiResponseDtoSignInResponse
     */
    'meta'?: { [key: string]: object; };
}

export const ApiResponseDtoSignInResponseStatusEnum = {
    _100Continue: '100 CONTINUE',
    _101SwitchingProtocols: '101 SWITCHING_PROTOCOLS',
    _102Processing: '102 PROCESSING',
    _103EarlyHints: '103 EARLY_HINTS',
    _103Checkpoint: '103 CHECKPOINT',
    _200Ok: '200 OK',
    _201Created: '201 CREATED',
    _202Accepted: '202 ACCEPTED',
    _203NonAuthoritativeInformation: '203 NON_AUTHORITATIVE_INFORMATION',
    _204NoContent: '204 NO_CONTENT',
    _205ResetContent: '205 RESET_CONTENT',
    _206PartialContent: '206 PARTIAL_CONTENT',
    _207MultiStatus: '207 MULTI_STATUS',
    _208AlreadyReported: '208 ALREADY_REPORTED',
    _226ImUsed: '226 IM_USED',
    _300MultipleChoices: '300 MULTIPLE_CHOICES',
    _301MovedPermanently: '301 MOVED_PERMANENTLY',
    _302Found: '302 FOUND',
    _302MovedTemporarily: '302 MOVED_TEMPORARILY',
    _303SeeOther: '303 SEE_OTHER',
    _304NotModified: '304 NOT_MODIFIED',
    _305UseProxy: '305 USE_PROXY',
    _307TemporaryRedirect: '307 TEMPORARY_REDIRECT',
    _308PermanentRedirect: '308 PERMANENT_REDIRECT',
    _400BadRequest: '400 BAD_REQUEST',
    _401Unauthorized: '401 UNAUTHORIZED',
    _402PaymentRequired: '402 PAYMENT_REQUIRED',
    _403Forbidden: '403 FORBIDDEN',
    _404NotFound: '404 NOT_FOUND',
    _405MethodNotAllowed: '405 METHOD_NOT_ALLOWED',
    _406NotAcceptable: '406 NOT_ACCEPTABLE',
    _407ProxyAuthenticationRequired: '407 PROXY_AUTHENTICATION_REQUIRED',
    _408RequestTimeout: '408 REQUEST_TIMEOUT',
    _409Conflict: '409 CONFLICT',
    _410Gone: '410 GONE',
    _411LengthRequired: '411 LENGTH_REQUIRED',
    _412PreconditionFailed: '412 PRECONDITION_FAILED',
    _413PayloadTooLarge: '413 PAYLOAD_TOO_LARGE',
    _413RequestEntityTooLarge: '413 REQUEST_ENTITY_TOO_LARGE',
    _414UriTooLong: '414 URI_TOO_LONG',
    _414RequestUriTooLong: '414 REQUEST_URI_TOO_LONG',
    _415UnsupportedMediaType: '415 UNSUPPORTED_MEDIA_TYPE',
    _416RequestedRangeNotSatisfiable: '416 REQUESTED_RANGE_NOT_SATISFIABLE',
    _417ExpectationFailed: '417 EXPECTATION_FAILED',
    _418IAmATeapot: '418 I_AM_A_TEAPOT',
    _419InsufficientSpaceOnResource: '419 INSUFFICIENT_SPACE_ON_RESOURCE',
    _420MethodFailure: '420 METHOD_FAILURE',
    _421DestinationLocked: '421 DESTINATION_LOCKED',
    _422UnprocessableEntity: '422 UNPROCESSABLE_ENTITY',
    _423Locked: '423 LOCKED',
    _424FailedDependency: '424 FAILED_DEPENDENCY',
    _425TooEarly: '425 TOO_EARLY',
    _426UpgradeRequired: '426 UPGRADE_REQUIRED',
    _428PreconditionRequired: '428 PRECONDITION_REQUIRED',
    _429TooManyRequests: '429 TOO_MANY_REQUESTS',
    _431RequestHeaderFieldsTooLarge: '431 REQUEST_HEADER_FIELDS_TOO_LARGE',
    _451UnavailableForLegalReasons: '451 UNAVAILABLE_FOR_LEGAL_REASONS',
    _500InternalServerError: '500 INTERNAL_SERVER_ERROR',
    _501NotImplemented: '501 NOT_IMPLEMENTED',
    _502BadGateway: '502 BAD_GATEWAY',
    _503ServiceUnavailable: '503 SERVICE_UNAVAILABLE',
    _504GatewayTimeout: '504 GATEWAY_TIMEOUT',
    _505HttpVersionNotSupported: '505 HTTP_VERSION_NOT_SUPPORTED',
    _506VariantAlsoNegotiates: '506 VARIANT_ALSO_NEGOTIATES',
    _507InsufficientStorage: '507 INSUFFICIENT_STORAGE',
    _508LoopDetected: '508 LOOP_DETECTED',
    _509BandwidthLimitExceeded: '509 BANDWIDTH_LIMIT_EXCEEDED',
    _510NotExtended: '510 NOT_EXTENDED',
    _511NetworkAuthenticationRequired: '511 NETWORK_AUTHENTICATION_REQUIRED'
} as const;

export type ApiResponseDtoSignInResponseStatusEnum = typeof ApiResponseDtoSignInResponseStatusEnum[keyof typeof ApiResponseDtoSignInResponseStatusEnum];

/**
 * 
 * @export
 * @interface ApiResponseDtoTransactionResponse
 */
export interface ApiResponseDtoTransactionResponse {
    /**
     * 
     * @type {boolean}
     * @memberof ApiResponseDtoTransactionResponse
     */
    'success'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof ApiResponseDtoTransactionResponse
     */
    'code'?: number;
    /**
     * 
     * @type {string}
     * @memberof ApiResponseDtoTransactionResponse
     */
    'status'?: ApiResponseDtoTransactionResponseStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof ApiResponseDtoTransactionResponse
     */
    'message'?: string;
    /**
     * 
     * @type {TransactionResponse}
     * @memberof ApiResponseDtoTransactionResponse
     */
    'data'?: TransactionResponse;
    /**
     * 
     * @type {{ [key: string]: object; }}
     * @memberof ApiResponseDtoTransactionResponse
     */
    'meta'?: { [key: string]: object; };
}

export const ApiResponseDtoTransactionResponseStatusEnum = {
    _100Continue: '100 CONTINUE',
    _101SwitchingProtocols: '101 SWITCHING_PROTOCOLS',
    _102Processing: '102 PROCESSING',
    _103EarlyHints: '103 EARLY_HINTS',
    _103Checkpoint: '103 CHECKPOINT',
    _200Ok: '200 OK',
    _201Created: '201 CREATED',
    _202Accepted: '202 ACCEPTED',
    _203NonAuthoritativeInformation: '203 NON_AUTHORITATIVE_INFORMATION',
    _204NoContent: '204 NO_CONTENT',
    _205ResetContent: '205 RESET_CONTENT',
    _206PartialContent: '206 PARTIAL_CONTENT',
    _207MultiStatus: '207 MULTI_STATUS',
    _208AlreadyReported: '208 ALREADY_REPORTED',
    _226ImUsed: '226 IM_USED',
    _300MultipleChoices: '300 MULTIPLE_CHOICES',
    _301MovedPermanently: '301 MOVED_PERMANENTLY',
    _302Found: '302 FOUND',
    _302MovedTemporarily: '302 MOVED_TEMPORARILY',
    _303SeeOther: '303 SEE_OTHER',
    _304NotModified: '304 NOT_MODIFIED',
    _305UseProxy: '305 USE_PROXY',
    _307TemporaryRedirect: '307 TEMPORARY_REDIRECT',
    _308PermanentRedirect: '308 PERMANENT_REDIRECT',
    _400BadRequest: '400 BAD_REQUEST',
    _401Unauthorized: '401 UNAUTHORIZED',
    _402PaymentRequired: '402 PAYMENT_REQUIRED',
    _403Forbidden: '403 FORBIDDEN',
    _404NotFound: '404 NOT_FOUND',
    _405MethodNotAllowed: '405 METHOD_NOT_ALLOWED',
    _406NotAcceptable: '406 NOT_ACCEPTABLE',
    _407ProxyAuthenticationRequired: '407 PROXY_AUTHENTICATION_REQUIRED',
    _408RequestTimeout: '408 REQUEST_TIMEOUT',
    _409Conflict: '409 CONFLICT',
    _410Gone: '410 GONE',
    _411LengthRequired: '411 LENGTH_REQUIRED',
    _412PreconditionFailed: '412 PRECONDITION_FAILED',
    _413PayloadTooLarge: '413 PAYLOAD_TOO_LARGE',
    _413RequestEntityTooLarge: '413 REQUEST_ENTITY_TOO_LARGE',
    _414UriTooLong: '414 URI_TOO_LONG',
    _414RequestUriTooLong: '414 REQUEST_URI_TOO_LONG',
    _415UnsupportedMediaType: '415 UNSUPPORTED_MEDIA_TYPE',
    _416RequestedRangeNotSatisfiable: '416 REQUESTED_RANGE_NOT_SATISFIABLE',
    _417ExpectationFailed: '417 EXPECTATION_FAILED',
    _418IAmATeapot: '418 I_AM_A_TEAPOT',
    _419InsufficientSpaceOnResource: '419 INSUFFICIENT_SPACE_ON_RESOURCE',
    _420MethodFailure: '420 METHOD_FAILURE',
    _421DestinationLocked: '421 DESTINATION_LOCKED',
    _422UnprocessableEntity: '422 UNPROCESSABLE_ENTITY',
    _423Locked: '423 LOCKED',
    _424FailedDependency: '424 FAILED_DEPENDENCY',
    _425TooEarly: '425 TOO_EARLY',
    _426UpgradeRequired: '426 UPGRADE_REQUIRED',
    _428PreconditionRequired: '428 PRECONDITION_REQUIRED',
    _429TooManyRequests: '429 TOO_MANY_REQUESTS',
    _431RequestHeaderFieldsTooLarge: '431 REQUEST_HEADER_FIELDS_TOO_LARGE',
    _451UnavailableForLegalReasons: '451 UNAVAILABLE_FOR_LEGAL_REASONS',
    _500InternalServerError: '500 INTERNAL_SERVER_ERROR',
    _501NotImplemented: '501 NOT_IMPLEMENTED',
    _502BadGateway: '502 BAD_GATEWAY',
    _503ServiceUnavailable: '503 SERVICE_UNAVAILABLE',
    _504GatewayTimeout: '504 GATEWAY_TIMEOUT',
    _505HttpVersionNotSupported: '505 HTTP_VERSION_NOT_SUPPORTED',
    _506VariantAlsoNegotiates: '506 VARIANT_ALSO_NEGOTIATES',
    _507InsufficientStorage: '507 INSUFFICIENT_STORAGE',
    _508LoopDetected: '508 LOOP_DETECTED',
    _509BandwidthLimitExceeded: '509 BANDWIDTH_LIMIT_EXCEEDED',
    _510NotExtended: '510 NOT_EXTENDED',
    _511NetworkAuthenticationRequired: '511 NETWORK_AUTHENTICATION_REQUIRED'
} as const;

export type ApiResponseDtoTransactionResponseStatusEnum = typeof ApiResponseDtoTransactionResponseStatusEnum[keyof typeof ApiResponseDtoTransactionResponseStatusEnum];

/**
 * 
 * @export
 * @interface ApiResponseDtoUsersResponse
 */
export interface ApiResponseDtoUsersResponse {
    /**
     * 
     * @type {boolean}
     * @memberof ApiResponseDtoUsersResponse
     */
    'success'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof ApiResponseDtoUsersResponse
     */
    'code'?: number;
    /**
     * 
     * @type {string}
     * @memberof ApiResponseDtoUsersResponse
     */
    'status'?: ApiResponseDtoUsersResponseStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof ApiResponseDtoUsersResponse
     */
    'message'?: string;
    /**
     * 
     * @type {UsersResponse}
     * @memberof ApiResponseDtoUsersResponse
     */
    'data'?: UsersResponse;
    /**
     * 
     * @type {{ [key: string]: object; }}
     * @memberof ApiResponseDtoUsersResponse
     */
    'meta'?: { [key: string]: object; };
}

export const ApiResponseDtoUsersResponseStatusEnum = {
    _100Continue: '100 CONTINUE',
    _101SwitchingProtocols: '101 SWITCHING_PROTOCOLS',
    _102Processing: '102 PROCESSING',
    _103EarlyHints: '103 EARLY_HINTS',
    _103Checkpoint: '103 CHECKPOINT',
    _200Ok: '200 OK',
    _201Created: '201 CREATED',
    _202Accepted: '202 ACCEPTED',
    _203NonAuthoritativeInformation: '203 NON_AUTHORITATIVE_INFORMATION',
    _204NoContent: '204 NO_CONTENT',
    _205ResetContent: '205 RESET_CONTENT',
    _206PartialContent: '206 PARTIAL_CONTENT',
    _207MultiStatus: '207 MULTI_STATUS',
    _208AlreadyReported: '208 ALREADY_REPORTED',
    _226ImUsed: '226 IM_USED',
    _300MultipleChoices: '300 MULTIPLE_CHOICES',
    _301MovedPermanently: '301 MOVED_PERMANENTLY',
    _302Found: '302 FOUND',
    _302MovedTemporarily: '302 MOVED_TEMPORARILY',
    _303SeeOther: '303 SEE_OTHER',
    _304NotModified: '304 NOT_MODIFIED',
    _305UseProxy: '305 USE_PROXY',
    _307TemporaryRedirect: '307 TEMPORARY_REDIRECT',
    _308PermanentRedirect: '308 PERMANENT_REDIRECT',
    _400BadRequest: '400 BAD_REQUEST',
    _401Unauthorized: '401 UNAUTHORIZED',
    _402PaymentRequired: '402 PAYMENT_REQUIRED',
    _403Forbidden: '403 FORBIDDEN',
    _404NotFound: '404 NOT_FOUND',
    _405MethodNotAllowed: '405 METHOD_NOT_ALLOWED',
    _406NotAcceptable: '406 NOT_ACCEPTABLE',
    _407ProxyAuthenticationRequired: '407 PROXY_AUTHENTICATION_REQUIRED',
    _408RequestTimeout: '408 REQUEST_TIMEOUT',
    _409Conflict: '409 CONFLICT',
    _410Gone: '410 GONE',
    _411LengthRequired: '411 LENGTH_REQUIRED',
    _412PreconditionFailed: '412 PRECONDITION_FAILED',
    _413PayloadTooLarge: '413 PAYLOAD_TOO_LARGE',
    _413RequestEntityTooLarge: '413 REQUEST_ENTITY_TOO_LARGE',
    _414UriTooLong: '414 URI_TOO_LONG',
    _414RequestUriTooLong: '414 REQUEST_URI_TOO_LONG',
    _415UnsupportedMediaType: '415 UNSUPPORTED_MEDIA_TYPE',
    _416RequestedRangeNotSatisfiable: '416 REQUESTED_RANGE_NOT_SATISFIABLE',
    _417ExpectationFailed: '417 EXPECTATION_FAILED',
    _418IAmATeapot: '418 I_AM_A_TEAPOT',
    _419InsufficientSpaceOnResource: '419 INSUFFICIENT_SPACE_ON_RESOURCE',
    _420MethodFailure: '420 METHOD_FAILURE',
    _421DestinationLocked: '421 DESTINATION_LOCKED',
    _422UnprocessableEntity: '422 UNPROCESSABLE_ENTITY',
    _423Locked: '423 LOCKED',
    _424FailedDependency: '424 FAILED_DEPENDENCY',
    _425TooEarly: '425 TOO_EARLY',
    _426UpgradeRequired: '426 UPGRADE_REQUIRED',
    _428PreconditionRequired: '428 PRECONDITION_REQUIRED',
    _429TooManyRequests: '429 TOO_MANY_REQUESTS',
    _431RequestHeaderFieldsTooLarge: '431 REQUEST_HEADER_FIELDS_TOO_LARGE',
    _451UnavailableForLegalReasons: '451 UNAVAILABLE_FOR_LEGAL_REASONS',
    _500InternalServerError: '500 INTERNAL_SERVER_ERROR',
    _501NotImplemented: '501 NOT_IMPLEMENTED',
    _502BadGateway: '502 BAD_GATEWAY',
    _503ServiceUnavailable: '503 SERVICE_UNAVAILABLE',
    _504GatewayTimeout: '504 GATEWAY_TIMEOUT',
    _505HttpVersionNotSupported: '505 HTTP_VERSION_NOT_SUPPORTED',
    _506VariantAlsoNegotiates: '506 VARIANT_ALSO_NEGOTIATES',
    _507InsufficientStorage: '507 INSUFFICIENT_STORAGE',
    _508LoopDetected: '508 LOOP_DETECTED',
    _509BandwidthLimitExceeded: '509 BANDWIDTH_LIMIT_EXCEEDED',
    _510NotExtended: '510 NOT_EXTENDED',
    _511NetworkAuthenticationRequired: '511 NETWORK_AUTHENTICATION_REQUIRED'
} as const;

export type ApiResponseDtoUsersResponseStatusEnum = typeof ApiResponseDtoUsersResponseStatusEnum[keyof typeof ApiResponseDtoUsersResponseStatusEnum];

/**
 * 
 * @export
 * @interface ApiResponseDtoValidateHrEmailResponse
 */
export interface ApiResponseDtoValidateHrEmailResponse {
    /**
     * 
     * @type {boolean}
     * @memberof ApiResponseDtoValidateHrEmailResponse
     */
    'success'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof ApiResponseDtoValidateHrEmailResponse
     */
    'code'?: number;
    /**
     * 
     * @type {string}
     * @memberof ApiResponseDtoValidateHrEmailResponse
     */
    'status'?: ApiResponseDtoValidateHrEmailResponseStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof ApiResponseDtoValidateHrEmailResponse
     */
    'message'?: string;
    /**
     * 
     * @type {ValidateHrEmailResponse}
     * @memberof ApiResponseDtoValidateHrEmailResponse
     */
    'data'?: ValidateHrEmailResponse;
    /**
     * 
     * @type {{ [key: string]: object; }}
     * @memberof ApiResponseDtoValidateHrEmailResponse
     */
    'meta'?: { [key: string]: object; };
}

export const ApiResponseDtoValidateHrEmailResponseStatusEnum = {
    _100Continue: '100 CONTINUE',
    _101SwitchingProtocols: '101 SWITCHING_PROTOCOLS',
    _102Processing: '102 PROCESSING',
    _103EarlyHints: '103 EARLY_HINTS',
    _103Checkpoint: '103 CHECKPOINT',
    _200Ok: '200 OK',
    _201Created: '201 CREATED',
    _202Accepted: '202 ACCEPTED',
    _203NonAuthoritativeInformation: '203 NON_AUTHORITATIVE_INFORMATION',
    _204NoContent: '204 NO_CONTENT',
    _205ResetContent: '205 RESET_CONTENT',
    _206PartialContent: '206 PARTIAL_CONTENT',
    _207MultiStatus: '207 MULTI_STATUS',
    _208AlreadyReported: '208 ALREADY_REPORTED',
    _226ImUsed: '226 IM_USED',
    _300MultipleChoices: '300 MULTIPLE_CHOICES',
    _301MovedPermanently: '301 MOVED_PERMANENTLY',
    _302Found: '302 FOUND',
    _302MovedTemporarily: '302 MOVED_TEMPORARILY',
    _303SeeOther: '303 SEE_OTHER',
    _304NotModified: '304 NOT_MODIFIED',
    _305UseProxy: '305 USE_PROXY',
    _307TemporaryRedirect: '307 TEMPORARY_REDIRECT',
    _308PermanentRedirect: '308 PERMANENT_REDIRECT',
    _400BadRequest: '400 BAD_REQUEST',
    _401Unauthorized: '401 UNAUTHORIZED',
    _402PaymentRequired: '402 PAYMENT_REQUIRED',
    _403Forbidden: '403 FORBIDDEN',
    _404NotFound: '404 NOT_FOUND',
    _405MethodNotAllowed: '405 METHOD_NOT_ALLOWED',
    _406NotAcceptable: '406 NOT_ACCEPTABLE',
    _407ProxyAuthenticationRequired: '407 PROXY_AUTHENTICATION_REQUIRED',
    _408RequestTimeout: '408 REQUEST_TIMEOUT',
    _409Conflict: '409 CONFLICT',
    _410Gone: '410 GONE',
    _411LengthRequired: '411 LENGTH_REQUIRED',
    _412PreconditionFailed: '412 PRECONDITION_FAILED',
    _413PayloadTooLarge: '413 PAYLOAD_TOO_LARGE',
    _413RequestEntityTooLarge: '413 REQUEST_ENTITY_TOO_LARGE',
    _414UriTooLong: '414 URI_TOO_LONG',
    _414RequestUriTooLong: '414 REQUEST_URI_TOO_LONG',
    _415UnsupportedMediaType: '415 UNSUPPORTED_MEDIA_TYPE',
    _416RequestedRangeNotSatisfiable: '416 REQUESTED_RANGE_NOT_SATISFIABLE',
    _417ExpectationFailed: '417 EXPECTATION_FAILED',
    _418IAmATeapot: '418 I_AM_A_TEAPOT',
    _419InsufficientSpaceOnResource: '419 INSUFFICIENT_SPACE_ON_RESOURCE',
    _420MethodFailure: '420 METHOD_FAILURE',
    _421DestinationLocked: '421 DESTINATION_LOCKED',
    _422UnprocessableEntity: '422 UNPROCESSABLE_ENTITY',
    _423Locked: '423 LOCKED',
    _424FailedDependency: '424 FAILED_DEPENDENCY',
    _425TooEarly: '425 TOO_EARLY',
    _426UpgradeRequired: '426 UPGRADE_REQUIRED',
    _428PreconditionRequired: '428 PRECONDITION_REQUIRED',
    _429TooManyRequests: '429 TOO_MANY_REQUESTS',
    _431RequestHeaderFieldsTooLarge: '431 REQUEST_HEADER_FIELDS_TOO_LARGE',
    _451UnavailableForLegalReasons: '451 UNAVAILABLE_FOR_LEGAL_REASONS',
    _500InternalServerError: '500 INTERNAL_SERVER_ERROR',
    _501NotImplemented: '501 NOT_IMPLEMENTED',
    _502BadGateway: '502 BAD_GATEWAY',
    _503ServiceUnavailable: '503 SERVICE_UNAVAILABLE',
    _504GatewayTimeout: '504 GATEWAY_TIMEOUT',
    _505HttpVersionNotSupported: '505 HTTP_VERSION_NOT_SUPPORTED',
    _506VariantAlsoNegotiates: '506 VARIANT_ALSO_NEGOTIATES',
    _507InsufficientStorage: '507 INSUFFICIENT_STORAGE',
    _508LoopDetected: '508 LOOP_DETECTED',
    _509BandwidthLimitExceeded: '509 BANDWIDTH_LIMIT_EXCEEDED',
    _510NotExtended: '510 NOT_EXTENDED',
    _511NetworkAuthenticationRequired: '511 NETWORK_AUTHENTICATION_REQUIRED'
} as const;

export type ApiResponseDtoValidateHrEmailResponseStatusEnum = typeof ApiResponseDtoValidateHrEmailResponseStatusEnum[keyof typeof ApiResponseDtoValidateHrEmailResponseStatusEnum];

/**
 * 
 * @export
 * @interface ApiResponseDtoWalletResponse
 */
export interface ApiResponseDtoWalletResponse {
    /**
     * 
     * @type {boolean}
     * @memberof ApiResponseDtoWalletResponse
     */
    'success'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof ApiResponseDtoWalletResponse
     */
    'code'?: number;
    /**
     * 
     * @type {string}
     * @memberof ApiResponseDtoWalletResponse
     */
    'status'?: ApiResponseDtoWalletResponseStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof ApiResponseDtoWalletResponse
     */
    'message'?: string;
    /**
     * 
     * @type {WalletResponse}
     * @memberof ApiResponseDtoWalletResponse
     */
    'data'?: WalletResponse;
    /**
     * 
     * @type {{ [key: string]: object; }}
     * @memberof ApiResponseDtoWalletResponse
     */
    'meta'?: { [key: string]: object; };
}

export const ApiResponseDtoWalletResponseStatusEnum = {
    _100Continue: '100 CONTINUE',
    _101SwitchingProtocols: '101 SWITCHING_PROTOCOLS',
    _102Processing: '102 PROCESSING',
    _103EarlyHints: '103 EARLY_HINTS',
    _103Checkpoint: '103 CHECKPOINT',
    _200Ok: '200 OK',
    _201Created: '201 CREATED',
    _202Accepted: '202 ACCEPTED',
    _203NonAuthoritativeInformation: '203 NON_AUTHORITATIVE_INFORMATION',
    _204NoContent: '204 NO_CONTENT',
    _205ResetContent: '205 RESET_CONTENT',
    _206PartialContent: '206 PARTIAL_CONTENT',
    _207MultiStatus: '207 MULTI_STATUS',
    _208AlreadyReported: '208 ALREADY_REPORTED',
    _226ImUsed: '226 IM_USED',
    _300MultipleChoices: '300 MULTIPLE_CHOICES',
    _301MovedPermanently: '301 MOVED_PERMANENTLY',
    _302Found: '302 FOUND',
    _302MovedTemporarily: '302 MOVED_TEMPORARILY',
    _303SeeOther: '303 SEE_OTHER',
    _304NotModified: '304 NOT_MODIFIED',
    _305UseProxy: '305 USE_PROXY',
    _307TemporaryRedirect: '307 TEMPORARY_REDIRECT',
    _308PermanentRedirect: '308 PERMANENT_REDIRECT',
    _400BadRequest: '400 BAD_REQUEST',
    _401Unauthorized: '401 UNAUTHORIZED',
    _402PaymentRequired: '402 PAYMENT_REQUIRED',
    _403Forbidden: '403 FORBIDDEN',
    _404NotFound: '404 NOT_FOUND',
    _405MethodNotAllowed: '405 METHOD_NOT_ALLOWED',
    _406NotAcceptable: '406 NOT_ACCEPTABLE',
    _407ProxyAuthenticationRequired: '407 PROXY_AUTHENTICATION_REQUIRED',
    _408RequestTimeout: '408 REQUEST_TIMEOUT',
    _409Conflict: '409 CONFLICT',
    _410Gone: '410 GONE',
    _411LengthRequired: '411 LENGTH_REQUIRED',
    _412PreconditionFailed: '412 PRECONDITION_FAILED',
    _413PayloadTooLarge: '413 PAYLOAD_TOO_LARGE',
    _413RequestEntityTooLarge: '413 REQUEST_ENTITY_TOO_LARGE',
    _414UriTooLong: '414 URI_TOO_LONG',
    _414RequestUriTooLong: '414 REQUEST_URI_TOO_LONG',
    _415UnsupportedMediaType: '415 UNSUPPORTED_MEDIA_TYPE',
    _416RequestedRangeNotSatisfiable: '416 REQUESTED_RANGE_NOT_SATISFIABLE',
    _417ExpectationFailed: '417 EXPECTATION_FAILED',
    _418IAmATeapot: '418 I_AM_A_TEAPOT',
    _419InsufficientSpaceOnResource: '419 INSUFFICIENT_SPACE_ON_RESOURCE',
    _420MethodFailure: '420 METHOD_FAILURE',
    _421DestinationLocked: '421 DESTINATION_LOCKED',
    _422UnprocessableEntity: '422 UNPROCESSABLE_ENTITY',
    _423Locked: '423 LOCKED',
    _424FailedDependency: '424 FAILED_DEPENDENCY',
    _425TooEarly: '425 TOO_EARLY',
    _426UpgradeRequired: '426 UPGRADE_REQUIRED',
    _428PreconditionRequired: '428 PRECONDITION_REQUIRED',
    _429TooManyRequests: '429 TOO_MANY_REQUESTS',
    _431RequestHeaderFieldsTooLarge: '431 REQUEST_HEADER_FIELDS_TOO_LARGE',
    _451UnavailableForLegalReasons: '451 UNAVAILABLE_FOR_LEGAL_REASONS',
    _500InternalServerError: '500 INTERNAL_SERVER_ERROR',
    _501NotImplemented: '501 NOT_IMPLEMENTED',
    _502BadGateway: '502 BAD_GATEWAY',
    _503ServiceUnavailable: '503 SERVICE_UNAVAILABLE',
    _504GatewayTimeout: '504 GATEWAY_TIMEOUT',
    _505HttpVersionNotSupported: '505 HTTP_VERSION_NOT_SUPPORTED',
    _506VariantAlsoNegotiates: '506 VARIANT_ALSO_NEGOTIATES',
    _507InsufficientStorage: '507 INSUFFICIENT_STORAGE',
    _508LoopDetected: '508 LOOP_DETECTED',
    _509BandwidthLimitExceeded: '509 BANDWIDTH_LIMIT_EXCEEDED',
    _510NotExtended: '510 NOT_EXTENDED',
    _511NetworkAuthenticationRequired: '511 NETWORK_AUTHENTICATION_REQUIRED'
} as const;

export type ApiResponseDtoWalletResponseStatusEnum = typeof ApiResponseDtoWalletResponseStatusEnum[keyof typeof ApiResponseDtoWalletResponseStatusEnum];

/**
 * 
 * @export
 * @interface Bank
 */
export interface Bank {
    /**
     * 
     * @type {string}
     * @memberof Bank
     */
    'name'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof Bank
     */
    'alias'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof Bank
     */
    'routingKey'?: string;
    /**
     * 
     * @type {string}
     * @memberof Bank
     */
    'logoImage'?: string;
    /**
     * 
     * @type {string}
     * @memberof Bank
     */
    'bankCode'?: string;
    /**
     * 
     * @type {string}
     * @memberof Bank
     */
    'categoryId'?: string;
    /**
     * 
     * @type {string}
     * @memberof Bank
     */
    'nubanCode'?: string;
}
/**
 * 
 * @export
 * @interface BankStatementResponse
 */
export interface BankStatementResponse {
    /**
     * 
     * @type {string}
     * @memberof BankStatementResponse
     */
    'bankName'?: string;
    /**
     * 
     * @type {string}
     * @memberof BankStatementResponse
     */
    'accountName'?: string;
    /**
     * 
     * @type {string}
     * @memberof BankStatementResponse
     */
    'accountNumber'?: string;
    /**
     * 
     * @type {string}
     * @memberof BankStatementResponse
     */
    'bankCode'?: string;
    /**
     * 
     * @type {FileUploadResponse}
     * @memberof BankStatementResponse
     */
    'statementFile'?: FileUploadResponse;
}
/**
 * BVN verification payload
 * @export
 * @interface BvnCheck
 */
export interface BvnCheck {
    /**
     * 
     * @type {string}
     * @memberof BvnCheck
     */
    'bvn': string;
    /**
     * 
     * @type {string}
     * @memberof BvnCheck
     */
    'dob': string;
    /**
     * 
     * @type {string}
     * @memberof BvnCheck
     */
    'firstName': string;
    /**
     * 
     * @type {string}
     * @memberof BvnCheck
     */
    'lastName': string;
}
/**
 * 
 * @export
 * @interface BvnVerificationResponse
 */
export interface BvnVerificationResponse {
    /**
     * 
     * @type {string}
     * @memberof BvnVerificationResponse
     */
    'name'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof BvnVerificationResponse
     */
    'bvnAlreadyVerified'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof BvnVerificationResponse
     */
    'referenceId'?: string;
    /**
     * 
     * @type {string}
     * @memberof BvnVerificationResponse
     */
    'message'?: string;
}
/**
 * Complete BVN verification payload
 * @export
 * @interface BvnVerifyOtp
 */
export interface BvnVerifyOtp {
    /**
     * 
     * @type {string}
     * @memberof BvnVerifyOtp
     */
    'bvnOtp': string;
    /**
     * 
     * @type {string}
     * @memberof BvnVerifyOtp
     */
    'referenceId': string;
}
/**
 * 
 * @export
 * @interface CallbackTransferData
 */
export interface CallbackTransferData {
    /**
     * 
     * @type {boolean}
     * @memberof CallbackTransferData
     */
    'reversed'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof CallbackTransferData
     */
    'deleted'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof CallbackTransferData
     */
    '_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof CallbackTransferData
     */
    'client'?: string;
    /**
     * 
     * @type {string}
     * @memberof CallbackTransferData
     */
    'account'?: string;
    /**
     * 
     * @type {string}
     * @memberof CallbackTransferData
     */
    'type'?: string;
    /**
     * 
     * @type {string}
     * @memberof CallbackTransferData
     */
    'sessionId'?: string;
    /**
     * 
     * @type {string}
     * @memberof CallbackTransferData
     */
    'nameEnquiryReference'?: string;
    /**
     * 
     * @type {string}
     * @memberof CallbackTransferData
     */
    'paymentReference'?: string;
    /**
     * 
     * @type {string}
     * @memberof CallbackTransferData
     */
    'mandateReference'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof CallbackTransferData
     */
    'isReversed'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof CallbackTransferData
     */
    'reversalReference'?: string;
    /**
     * 
     * @type {string}
     * @memberof CallbackTransferData
     */
    'provider'?: string;
    /**
     * 
     * @type {string}
     * @memberof CallbackTransferData
     */
    'providerChannel'?: string;
    /**
     * 
     * @type {string}
     * @memberof CallbackTransferData
     */
    'providerChannelCode'?: string;
    /**
     * 
     * @type {string}
     * @memberof CallbackTransferData
     */
    'destinationInstitutionCode'?: string;
    /**
     * 
     * @type {string}
     * @memberof CallbackTransferData
     */
    'creditAccountName'?: string;
    /**
     * 
     * @type {string}
     * @memberof CallbackTransferData
     */
    'creditAccountNumber'?: string;
    /**
     * 
     * @type {string}
     * @memberof CallbackTransferData
     */
    'creditBankVerificationNumber'?: string;
    /**
     * 
     * @type {string}
     * @memberof CallbackTransferData
     */
    'creditKYCLevel'?: string;
    /**
     * 
     * @type {string}
     * @memberof CallbackTransferData
     */
    'debitAccountName'?: string;
    /**
     * 
     * @type {string}
     * @memberof CallbackTransferData
     */
    'debitAccountNumber'?: string;
    /**
     * 
     * @type {string}
     * @memberof CallbackTransferData
     */
    'debitBankVerificationNumber'?: string;
    /**
     * 
     * @type {string}
     * @memberof CallbackTransferData
     */
    'debitKYCLevel'?: string;
    /**
     * 
     * @type {string}
     * @memberof CallbackTransferData
     */
    'transactionLocation'?: string;
    /**
     * 
     * @type {string}
     * @memberof CallbackTransferData
     */
    'narration'?: string;
    /**
     * 
     * @type {number}
     * @memberof CallbackTransferData
     */
    'amount'?: number;
    /**
     * 
     * @type {number}
     * @memberof CallbackTransferData
     */
    'fees'?: number;
    /**
     * 
     * @type {number}
     * @memberof CallbackTransferData
     */
    'vat'?: number;
    /**
     * 
     * @type {number}
     * @memberof CallbackTransferData
     */
    'stampDuty'?: number;
    /**
     * 
     * @type {string}
     * @memberof CallbackTransferData
     */
    'responseCode'?: string;
    /**
     * 
     * @type {string}
     * @memberof CallbackTransferData
     */
    'responseMessage'?: string;
    /**
     * 
     * @type {string}
     * @memberof CallbackTransferData
     */
    'status'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof CallbackTransferData
     */
    'isDeleted'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof CallbackTransferData
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof CallbackTransferData
     */
    'updatedAt'?: string;
    /**
     * 
     * @type {number}
     * @memberof CallbackTransferData
     */
    '__v'?: number;
    /**
     * 
     * @type {string}
     * @memberof CallbackTransferData
     */
    'approvedAt'?: string;
    /**
     * 
     * @type {object}
     * @memberof CallbackTransferData
     */
    'queued'?: object;
}
/**
 * Password change payload
 * @export
 * @interface ChangePassword
 */
export interface ChangePassword {
    /**
     * 
     * @type {string}
     * @memberof ChangePassword
     */
    'currentPassword': string;
    /**
     * 
     * @type {string}
     * @memberof ChangePassword
     */
    'newPassword': string;
}
/**
 * Update transaction pin payload
 * @export
 * @interface ChangeTransactionPin
 */
export interface ChangeTransactionPin {
    /**
     * 
     * @type {string}
     * @memberof ChangeTransactionPin
     */
    'currentTransactionPin': string;
    /**
     * 
     * @type {string}
     * @memberof ChangeTransactionPin
     */
    'newTransactionPin': string;
    /**
     * 
     * @type {string}
     * @memberof ChangeTransactionPin
     */
    'confirmNewTransactionPin': string;
}
/**
 * DailyPay claim payload
 * @export
 * @interface ClaimDailyPay
 */
export interface ClaimDailyPay {
    /**
     * 
     * @type {string}
     * @memberof ClaimDailyPay
     */
    'transactionPin': string;
    /**
     * 
     * @type {number}
     * @memberof ClaimDailyPay
     */
    'amountToClaim': number;
}
/**
 * Complete password reset payload
 * @export
 * @interface CompletePasswordResetLink
 */
export interface CompletePasswordResetLink {
    /**
     * 
     * @type {string}
     * @memberof CompletePasswordResetLink
     */
    'encryptedEmail': string;
    /**
     * 
     * @type {string}
     * @memberof CompletePasswordResetLink
     */
    'token': string;
    /**
     * 
     * @type {string}
     * @memberof CompletePasswordResetLink
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof CompletePasswordResetLink
     */
    'newPassword': string;
}
/**
 * Complete password reset payload
 * @export
 * @interface CompletePasswordResetOtp
 */
export interface CompletePasswordResetOtp {
    /**
     * 
     * @type {string}
     * @memberof CompletePasswordResetOtp
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof CompletePasswordResetOtp
     */
    'otp': string;
    /**
     * 
     * @type {string}
     * @memberof CompletePasswordResetOtp
     */
    'newPassword': string;
}
/**
 * Complete account payload
 * @export
 * @interface CompleteVirtualAccountCreation
 */
export interface CompleteVirtualAccountCreation {
    /**
     * 
     * @type {string}
     * @memberof CompleteVirtualAccountCreation
     */
    'otp': string;
    /**
     * 
     * @type {string}
     * @memberof CompleteVirtualAccountCreation
     */
    'reference': string;
}
/**
 * Signin payload
 * @export
 * @interface Credentials
 */
export interface Credentials {
    /**
     * 
     * @type {string}
     * @memberof Credentials
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof Credentials
     */
    'password': string;
}
/**
 * DailyPay profile payload
 * @export
 * @interface DailyPayJobStep1
 */
export interface DailyPayJobStep1 {
    /**
     * 
     * @type {string}
     * @memberof DailyPayJobStep1
     */
    'organizationType': DailyPayJobStep1OrganizationTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof DailyPayJobStep1
     */
    'employerName': string;
    /**
     * 
     * @type {string}
     * @memberof DailyPayJobStep1
     */
    'employerEmail': string;
    /**
     * 
     * @type {string}
     * @memberof DailyPayJobStep1
     */
    'employerPhone'?: string;
    /**
     * 
     * @type {string}
     * @memberof DailyPayJobStep1
     */
    'employerWebsite': string;
    /**
     * 
     * @type {string}
     * @memberof DailyPayJobStep1
     */
    'employerAddress': string;
    /**
     * 
     * @type {string}
     * @memberof DailyPayJobStep1
     */
    'jobTitle': string;
    /**
     * 
     * @type {string}
     * @memberof DailyPayJobStep1
     */
    'jobRole': string;
    /**
     * 
     * @type {number}
     * @memberof DailyPayJobStep1
     */
    'monthlySalary': number;
    /**
     * 
     * @type {string}
     * @memberof DailyPayJobStep1
     */
    'currency': DailyPayJobStep1CurrencyEnum;
    /**
     * 
     * @type {string}
     * @memberof DailyPayJobStep1
     */
    'durationOfWork': string;
}

export const DailyPayJobStep1OrganizationTypeEnum = {
    Private: 'PRIVATE',
    Government: 'GOVERNMENT',
    Ngo: 'NGO'
} as const;

export type DailyPayJobStep1OrganizationTypeEnum = typeof DailyPayJobStep1OrganizationTypeEnum[keyof typeof DailyPayJobStep1OrganizationTypeEnum];
export const DailyPayJobStep1CurrencyEnum = {
    Afghani: 'AFGHANI',
    AlgerianDinar: 'ALGERIAN_DINAR',
    AngolanKwanza: 'ANGOLAN_KWANZA',
    ArgentinePeso: 'ARGENTINE_PESO',
    AustralianDollar: 'AUSTRALIAN_DOLLAR',
    BahrainiDinar: 'BAHRAINI_DINAR',
    BangladeshiTaka: 'BANGLADESHI_TAKA',
    Bitcoin: 'BITCOIN',
    BrazilianReal: 'BRAZILIAN_REAL',
    BruneiDollar: 'BRUNEI_DOLLAR',
    BulgarianLev: 'BULGARIAN_LEV',
    BurundianFranc: 'BURUNDIAN_FRANC',
    CanadianDollar: 'CANADIAN_DOLLAR',
    CfaFrancBeac: 'CFA_FRANC_BEAC',
    CfaFrancBceao: 'CFA_FRANC_BCEAO',
    ChileanPeso: 'CHILEAN_PESO',
    ChineseYuan: 'CHINESE_YUAN',
    ColombianPeso: 'COLOMBIAN_PESO',
    CongoleseFranc: 'CONGOLESE_FRANC',
    CzechKoruna: 'CZECH_KORUNA',
    DanishKrone: 'DANISH_KRONE',
    DominicanPeso: 'DOMINICAN_PESO',
    EgyptianPound: 'EGYPTIAN_POUND',
    EthiopianBirr: 'ETHIOPIAN_BIRR',
    Euro: 'EURO',
    FijianDollar: 'FIJIAN_DOLLAR',
    GhanaianCedi: 'GHANAIAN_CEDI',
    GuineanFranc: 'GUINEAN_FRANC',
    HongKongDollar: 'HONG_KONG_DOLLAR',
    HungarianForint: 'HUNGARIAN_FORINT',
    IcelandicKrona: 'ICELANDIC_KRONA',
    IndianRupee: 'INDIAN_RUPEE',
    IndonesianRupiah: 'INDONESIAN_RUPIAH',
    IranianRial: 'IRANIAN_RIAL',
    IraqiDinar: 'IRAQI_DINAR',
    IsraeliShekel: 'ISRAELI_SHEKEL',
    JamaicanDollar: 'JAMAICAN_DOLLAR',
    JapaneseYen: 'JAPANESE_YEN',
    JordanianDinar: 'JORDANIAN_DINAR',
    KazakhstaniTenge: 'KAZAKHSTANI_TENGE',
    KenyanShilling: 'KENYAN_SHILLING',
    KuwaitiDinar: 'KUWAITI_DINAR',
    LaosKip: 'LAOS_KIp',
    LebanesePound: 'LEBANESE_POUND',
    LibyanDinar: 'LIBYAN_DINAR',
    MalagasyAriary: 'MALAGASY_ARIARY',
    MalawianKwacha: 'MALAWIAN_KWACHA',
    MalaysianRinggit: 'MALAYSIAN_RINGGIT',
    MauritianRupee: 'MAURITIAN_RUPEE',
    MexicanPeso: 'MEXICAN_PESO',
    MoroccanDirham: 'MOROCCAN_DIRHAM',
    MozambicanMetical: 'MOZAMBICAN_METICAL',
    NamibianDollar: 'NAMIBIAN_DOLLAR',
    Naira: 'NAIRA',
    NepaleseRupee: 'NEPALESE_RUPEE',
    NewZealandDollar: 'NEW_ZEALAND_DOLLAR',
    NorwegianKrone: 'NORWEGIAN_KRONE',
    OmaniRial: 'OMANI_RIAL',
    PakistaniRupee: 'PAKISTANI_RUPEE',
    PhilippinePeso: 'PHILIPPINE_PESO',
    PolishZloty: 'POLISH_ZLOTY',
    QatariRiyal: 'QATARI_RIYAL',
    RomanianLeu: 'ROMANIAN_LEU',
    RussianRuble: 'RUSSIAN_RUBLE',
    RwandanFranc: 'RWANDAN_FRANC',
    SaudiRiyal: 'SAUDI_RIYAL',
    SerbianDinar: 'SERBIAN_DINAR',
    SeychellesRupee: 'SEYCHELLES_RUPEE',
    SingaporeDollar: 'SINGAPORE_DOLLAR',
    SomaliShilling: 'SOMALI_SHILLING',
    SouthAfricanRand: 'SOUTH_AFRICAN_RAND',
    SouthKoreanWon: 'SOUTH_KOREAN_WON',
    SouthSudanesePound: 'SOUTH_SUDANESE_POUND',
    SriLankanRupee: 'SRI_LANKAN_RUPEE',
    SwedishKrona: 'SWEDISH_KRONA',
    SwissFranc: 'SWISS_FRANC',
    SyrianPound: 'SYRIAN_POUND',
    TaiwanDollar: 'TAIWAN_DOLLAR',
    TanzanianShilling: 'TANZANIAN_SHILLING',
    ThaiBaht: 'THAI_BAHT',
    TunisianDinar: 'TUNISIAN_DINAR',
    TurkishLira: 'TURKISH_LIRA',
    UgandanShilling: 'UGANDAN_SHILLING',
    UkrainianHryvnia: 'UKRAINIAN_HRYVNIA',
    UaeDirham: 'UAE_DIRHAM',
    UkPound: 'UK_POUND',
    UsDollar: 'US_DOLLAR',
    UruguayanPeso: 'URUGUAYAN_PESO',
    UzbekistaniSom: 'UZBEKISTANI_SOM',
    VenezuelanBolivar: 'VENEZUELAN_BOLIVAR',
    VietnameseDong: 'VIETNAMESE_DONG',
    YemeniRial: 'YEMENI_RIAL',
    ZambianKwacha: 'ZAMBIAN_KWACHA',
    ZimbabweanDollar: 'ZIMBABWEAN_DOLLAR'
} as const;

export type DailyPayJobStep1CurrencyEnum = typeof DailyPayJobStep1CurrencyEnum[keyof typeof DailyPayJobStep1CurrencyEnum];

/**
 * Salary account payload
 * @export
 * @interface DailyPayJobStep2
 */
export interface DailyPayJobStep2 {
    /**
     * 
     * @type {string}
     * @memberof DailyPayJobStep2
     */
    'monoCode': string;
}
/**
 * HR mandate review request payload
 * @export
 * @interface DailyPayJobStep3
 */
export interface DailyPayJobStep3 {
    /**
     * 
     * @type {string}
     * @memberof DailyPayJobStep3
     */
    'hrName': string;
    /**
     * 
     * @type {string}
     * @memberof DailyPayJobStep3
     */
    'hrEmail': string;
    /**
     * 
     * @type {string}
     * @memberof DailyPayJobStep3
     */
    'hrPhone': string;
}
/**
 * Mandate approval payload
 * @export
 * @interface DailyPayJobStep4ApproveMandate
 */
export interface DailyPayJobStep4ApproveMandate {
    /**
     * 
     * @type {string}
     * @memberof DailyPayJobStep4ApproveMandate
     */
    'encryptedEmail': string;
    /**
     * 
     * @type {string}
     * @memberof DailyPayJobStep4ApproveMandate
     */
    'token': string;
    /**
     * 
     * @type {string}
     * @memberof DailyPayJobStep4ApproveMandate
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof DailyPayJobStep4ApproveMandate
     */
    'comment'?: string;
    /**
     * 
     * @type {string}
     * @memberof DailyPayJobStep4ApproveMandate
     */
    'employerType': DailyPayJobStep4ApproveMandateEmployerTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof DailyPayJobStep4ApproveMandate
     */
    'employerName': string;
    /**
     * 
     * @type {string}
     * @memberof DailyPayJobStep4ApproveMandate
     */
    'employerRCNumber'?: string;
    /**
     * 
     * @type {string}
     * @memberof DailyPayJobStep4ApproveMandate
     */
    'employerWebsite'?: string;
    /**
     * 
     * @type {string}
     * @memberof DailyPayJobStep4ApproveMandate
     */
    'employerAddress': string;
    /**
     * 
     * @type {string}
     * @memberof DailyPayJobStep4ApproveMandate
     */
    'companySize': string;
    /**
     * 
     * @type {string}
     * @memberof DailyPayJobStep4ApproveMandate
     */
    'industry': string;
    /**
     * 
     * @type {string}
     * @memberof DailyPayJobStep4ApproveMandate
     */
    'hrFirstName': string;
    /**
     * 
     * @type {string}
     * @memberof DailyPayJobStep4ApproveMandate
     */
    'hrLastName': string;
    /**
     * 
     * @type {string}
     * @memberof DailyPayJobStep4ApproveMandate
     */
    'hrJobTitle': string;
    /**
     * 
     * @type {string}
     * @memberof DailyPayJobStep4ApproveMandate
     */
    'hrEmail': string;
    /**
     * 
     * @type {string}
     * @memberof DailyPayJobStep4ApproveMandate
     */
    'contactPhone': string;
}

export const DailyPayJobStep4ApproveMandateEmployerTypeEnum = {
    Private: 'PRIVATE',
    Government: 'GOVERNMENT',
    Ngo: 'NGO'
} as const;

export type DailyPayJobStep4ApproveMandateEmployerTypeEnum = typeof DailyPayJobStep4ApproveMandateEmployerTypeEnum[keyof typeof DailyPayJobStep4ApproveMandateEmployerTypeEnum];

/**
 * Mandate decline payload
 * @export
 * @interface DailyPayJobStep4DeclineMandate
 */
export interface DailyPayJobStep4DeclineMandate {
    /**
     * 
     * @type {string}
     * @memberof DailyPayJobStep4DeclineMandate
     */
    'encryptedEmail': string;
    /**
     * 
     * @type {string}
     * @memberof DailyPayJobStep4DeclineMandate
     */
    'token': string;
    /**
     * 
     * @type {string}
     * @memberof DailyPayJobStep4DeclineMandate
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof DailyPayJobStep4DeclineMandate
     */
    'declineReason'?: string;
}
/**
 * 
 * @export
 * @interface DailyPayWalletMetrics
 */
export interface DailyPayWalletMetrics {
    /**
     * 
     * @type {string}
     * @memberof DailyPayWalletMetrics
     */
    'wallet'?: string;
    /**
     * 
     * @type {number}
     * @memberof DailyPayWalletMetrics
     */
    'walletBalance'?: number;
    /**
     * 
     * @type {number}
     * @memberof DailyPayWalletMetrics
     */
    'targetForTheMonth'?: number;
    /**
     * 
     * @type {number}
     * @memberof DailyPayWalletMetrics
     */
    'totalClaimForTheMonth'?: number;
    /**
     * 
     * @type {number}
     * @memberof DailyPayWalletMetrics
     */
    'remainingBalanceForTheMonth'?: number;
}
/**
 * 
 * @export
 * @interface FileUploadResponse
 */
export interface FileUploadResponse {
    /**
     * 
     * @type {string}
     * @memberof FileUploadResponse
     */
    'filename'?: string;
    /**
     * 
     * @type {string}
     * @memberof FileUploadResponse
     */
    'previewUrl'?: string;
    /**
     * 
     * @type {string}
     * @memberof FileUploadResponse
     */
    'fileExt'?: string;
    /**
     * 
     * @type {string}
     * @memberof FileUploadResponse
     */
    'fileSize'?: string;
}
/**
 * HR data payload
 * @export
 * @interface HrDataRequest
 */
export interface HrDataRequest {
    /**
     * 
     * @type {string}
     * @memberof HrDataRequest
     */
    'employerType': string;
    /**
     * 
     * @type {string}
     * @memberof HrDataRequest
     */
    'employerName': string;
    /**
     * 
     * @type {string}
     * @memberof HrDataRequest
     */
    'employerRCNumber'?: string;
    /**
     * 
     * @type {string}
     * @memberof HrDataRequest
     */
    'employerWebsite'?: string;
    /**
     * 
     * @type {string}
     * @memberof HrDataRequest
     */
    'employerAddress': string;
    /**
     * 
     * @type {string}
     * @memberof HrDataRequest
     */
    'companySize': string;
    /**
     * 
     * @type {string}
     * @memberof HrDataRequest
     */
    'industry': string;
    /**
     * 
     * @type {string}
     * @memberof HrDataRequest
     */
    'hrFirstName': string;
    /**
     * 
     * @type {string}
     * @memberof HrDataRequest
     */
    'hrLastName': string;
    /**
     * 
     * @type {string}
     * @memberof HrDataRequest
     */
    'hrJobTitle': string;
    /**
     * 
     * @type {string}
     * @memberof HrDataRequest
     */
    'hrEmail': string;
    /**
     * 
     * @type {string}
     * @memberof HrDataRequest
     */
    'contactPhone': string;
}
/**
 * 
 * @export
 * @interface HrDataResponse
 */
export interface HrDataResponse {
    /**
     * 
     * @type {string}
     * @memberof HrDataResponse
     */
    'comment'?: string;
    /**
     * 
     * @type {string}
     * @memberof HrDataResponse
     */
    'employerType'?: HrDataResponseEmployerTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof HrDataResponse
     */
    'employerName'?: string;
    /**
     * 
     * @type {string}
     * @memberof HrDataResponse
     */
    'employerRCNumber'?: string;
    /**
     * 
     * @type {string}
     * @memberof HrDataResponse
     */
    'employerWebsite'?: string;
    /**
     * 
     * @type {string}
     * @memberof HrDataResponse
     */
    'employerAddress'?: string;
    /**
     * 
     * @type {string}
     * @memberof HrDataResponse
     */
    'companySize'?: string;
    /**
     * 
     * @type {string}
     * @memberof HrDataResponse
     */
    'industry'?: string;
    /**
     * 
     * @type {string}
     * @memberof HrDataResponse
     */
    'hrFirstName'?: string;
    /**
     * 
     * @type {string}
     * @memberof HrDataResponse
     */
    'hrLastName'?: string;
    /**
     * 
     * @type {string}
     * @memberof HrDataResponse
     */
    'hrJobTitle'?: string;
    /**
     * 
     * @type {string}
     * @memberof HrDataResponse
     */
    'hrEmail'?: string;
    /**
     * 
     * @type {string}
     * @memberof HrDataResponse
     */
    'contactPhone'?: string;
    /**
     * 
     * @type {string}
     * @memberof HrDataResponse
     */
    'verifiedLinkedInProfile'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof HrDataResponse
     */
    'verified'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof HrDataResponse
     */
    'dateVerified'?: string;
    /**
     * 
     * @type {string}
     * @memberof HrDataResponse
     */
    'verifiedBy'?: string;
    /**
     * 
     * @type {string}
     * @memberof HrDataResponse
     */
    'createdDate'?: string;
    /**
     * 
     * @type {string}
     * @memberof HrDataResponse
     */
    'lastModifiedDate'?: string;
    /**
     * 
     * @type {string}
     * @memberof HrDataResponse
     */
    'lastModifiedBy'?: string;
}

export const HrDataResponseEmployerTypeEnum = {
    Private: 'PRIVATE',
    Government: 'GOVERNMENT',
    Ngo: 'NGO'
} as const;

export type HrDataResponseEmployerTypeEnum = typeof HrDataResponseEmployerTypeEnum[keyof typeof HrDataResponseEmployerTypeEnum];

/**
 * 
 * @export
 * @interface HrLinkedInValidationResponse
 */
export interface HrLinkedInValidationResponse {
    /**
     * 
     * @type {boolean}
     * @memberof HrLinkedInValidationResponse
     */
    'valid'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof HrLinkedInValidationResponse
     */
    'linkedInProfile'?: string;
}
/**
 * Password reset payload
 * @export
 * @interface InitiateResetPassword
 */
export interface InitiateResetPassword {
    /**
     * 
     * @type {string}
     * @memberof InitiateResetPassword
     */
    'email': string;
}
/**
 * 
 * @export
 * @interface JobResponse
 */
export interface JobResponse {
    /**
     * 
     * @type {string}
     * @memberof JobResponse
     */
    'jobId'?: string;
    /**
     * 
     * @type {string}
     * @memberof JobResponse
     */
    'organizationType'?: JobResponseOrganizationTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof JobResponse
     */
    'employerName'?: string;
    /**
     * 
     * @type {string}
     * @memberof JobResponse
     */
    'employerPhone'?: string;
    /**
     * 
     * @type {string}
     * @memberof JobResponse
     */
    'employerEmail'?: string;
    /**
     * 
     * @type {string}
     * @memberof JobResponse
     */
    'employerWebsite'?: string;
    /**
     * 
     * @type {AddressResponse}
     * @memberof JobResponse
     */
    'employerAddress'?: AddressResponse;
    /**
     * 
     * @type {string}
     * @memberof JobResponse
     */
    'jobTitle'?: string;
    /**
     * 
     * @type {string}
     * @memberof JobResponse
     */
    'jobRole'?: string;
    /**
     * 
     * @type {number}
     * @memberof JobResponse
     */
    'monthlySalary'?: number;
    /**
     * 
     * @type {string}
     * @memberof JobResponse
     */
    'salaryTimeframe'?: string;
    /**
     * 
     * @type {string}
     * @memberof JobResponse
     */
    'currency'?: JobResponseCurrencyEnum;
    /**
     * 
     * @type {string}
     * @memberof JobResponse
     */
    'hrName'?: string;
    /**
     * 
     * @type {string}
     * @memberof JobResponse
     */
    'hrPhone'?: string;
    /**
     * 
     * @type {string}
     * @memberof JobResponse
     */
    'hrEmail'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof JobResponse
     */
    'emailSentToHr'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof JobResponse
     */
    'emailResendCount'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof JobResponse
     */
    'hrApproval'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof JobResponse
     */
    'hrApprovalStatus'?: JobResponseHrApprovalStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof JobResponse
     */
    'dateApproved'?: string;
    /**
     * 
     * @type {string}
     * @memberof JobResponse
     */
    'hrComment'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof JobResponse
     */
    'active'?: boolean;
    /**
     * 
     * @type {HrDataResponse}
     * @memberof JobResponse
     */
    'hrData'?: HrDataResponse;
    /**
     * 
     * @type {JobSteps}
     * @memberof JobResponse
     */
    'steps'?: JobSteps;
    /**
     * 
     * @type {BankStatementResponse}
     * @memberof JobResponse
     */
    'bankStatement'?: BankStatementResponse;
    /**
     * 
     * @type {string}
     * @memberof JobResponse
     */
    'createdDate'?: string;
    /**
     * 
     * @type {string}
     * @memberof JobResponse
     */
    'lastModifiedDate'?: string;
    /**
     * 
     * @type {string}
     * @memberof JobResponse
     */
    'lastModifiedBy'?: string;
}

export const JobResponseOrganizationTypeEnum = {
    Private: 'PRIVATE',
    Government: 'GOVERNMENT',
    Ngo: 'NGO'
} as const;

export type JobResponseOrganizationTypeEnum = typeof JobResponseOrganizationTypeEnum[keyof typeof JobResponseOrganizationTypeEnum];
export const JobResponseCurrencyEnum = {
    Afghani: 'AFGHANI',
    AlgerianDinar: 'ALGERIAN_DINAR',
    AngolanKwanza: 'ANGOLAN_KWANZA',
    ArgentinePeso: 'ARGENTINE_PESO',
    AustralianDollar: 'AUSTRALIAN_DOLLAR',
    BahrainiDinar: 'BAHRAINI_DINAR',
    BangladeshiTaka: 'BANGLADESHI_TAKA',
    Bitcoin: 'BITCOIN',
    BrazilianReal: 'BRAZILIAN_REAL',
    BruneiDollar: 'BRUNEI_DOLLAR',
    BulgarianLev: 'BULGARIAN_LEV',
    BurundianFranc: 'BURUNDIAN_FRANC',
    CanadianDollar: 'CANADIAN_DOLLAR',
    CfaFrancBeac: 'CFA_FRANC_BEAC',
    CfaFrancBceao: 'CFA_FRANC_BCEAO',
    ChileanPeso: 'CHILEAN_PESO',
    ChineseYuan: 'CHINESE_YUAN',
    ColombianPeso: 'COLOMBIAN_PESO',
    CongoleseFranc: 'CONGOLESE_FRANC',
    CzechKoruna: 'CZECH_KORUNA',
    DanishKrone: 'DANISH_KRONE',
    DominicanPeso: 'DOMINICAN_PESO',
    EgyptianPound: 'EGYPTIAN_POUND',
    EthiopianBirr: 'ETHIOPIAN_BIRR',
    Euro: 'EURO',
    FijianDollar: 'FIJIAN_DOLLAR',
    GhanaianCedi: 'GHANAIAN_CEDI',
    GuineanFranc: 'GUINEAN_FRANC',
    HongKongDollar: 'HONG_KONG_DOLLAR',
    HungarianForint: 'HUNGARIAN_FORINT',
    IcelandicKrona: 'ICELANDIC_KRONA',
    IndianRupee: 'INDIAN_RUPEE',
    IndonesianRupiah: 'INDONESIAN_RUPIAH',
    IranianRial: 'IRANIAN_RIAL',
    IraqiDinar: 'IRAQI_DINAR',
    IsraeliShekel: 'ISRAELI_SHEKEL',
    JamaicanDollar: 'JAMAICAN_DOLLAR',
    JapaneseYen: 'JAPANESE_YEN',
    JordanianDinar: 'JORDANIAN_DINAR',
    KazakhstaniTenge: 'KAZAKHSTANI_TENGE',
    KenyanShilling: 'KENYAN_SHILLING',
    KuwaitiDinar: 'KUWAITI_DINAR',
    LaosKip: 'LAOS_KIp',
    LebanesePound: 'LEBANESE_POUND',
    LibyanDinar: 'LIBYAN_DINAR',
    MalagasyAriary: 'MALAGASY_ARIARY',
    MalawianKwacha: 'MALAWIAN_KWACHA',
    MalaysianRinggit: 'MALAYSIAN_RINGGIT',
    MauritianRupee: 'MAURITIAN_RUPEE',
    MexicanPeso: 'MEXICAN_PESO',
    MoroccanDirham: 'MOROCCAN_DIRHAM',
    MozambicanMetical: 'MOZAMBICAN_METICAL',
    NamibianDollar: 'NAMIBIAN_DOLLAR',
    Naira: 'NAIRA',
    NepaleseRupee: 'NEPALESE_RUPEE',
    NewZealandDollar: 'NEW_ZEALAND_DOLLAR',
    NorwegianKrone: 'NORWEGIAN_KRONE',
    OmaniRial: 'OMANI_RIAL',
    PakistaniRupee: 'PAKISTANI_RUPEE',
    PhilippinePeso: 'PHILIPPINE_PESO',
    PolishZloty: 'POLISH_ZLOTY',
    QatariRiyal: 'QATARI_RIYAL',
    RomanianLeu: 'ROMANIAN_LEU',
    RussianRuble: 'RUSSIAN_RUBLE',
    RwandanFranc: 'RWANDAN_FRANC',
    SaudiRiyal: 'SAUDI_RIYAL',
    SerbianDinar: 'SERBIAN_DINAR',
    SeychellesRupee: 'SEYCHELLES_RUPEE',
    SingaporeDollar: 'SINGAPORE_DOLLAR',
    SomaliShilling: 'SOMALI_SHILLING',
    SouthAfricanRand: 'SOUTH_AFRICAN_RAND',
    SouthKoreanWon: 'SOUTH_KOREAN_WON',
    SouthSudanesePound: 'SOUTH_SUDANESE_POUND',
    SriLankanRupee: 'SRI_LANKAN_RUPEE',
    SwedishKrona: 'SWEDISH_KRONA',
    SwissFranc: 'SWISS_FRANC',
    SyrianPound: 'SYRIAN_POUND',
    TaiwanDollar: 'TAIWAN_DOLLAR',
    TanzanianShilling: 'TANZANIAN_SHILLING',
    ThaiBaht: 'THAI_BAHT',
    TunisianDinar: 'TUNISIAN_DINAR',
    TurkishLira: 'TURKISH_LIRA',
    UgandanShilling: 'UGANDAN_SHILLING',
    UkrainianHryvnia: 'UKRAINIAN_HRYVNIA',
    UaeDirham: 'UAE_DIRHAM',
    UkPound: 'UK_POUND',
    UsDollar: 'US_DOLLAR',
    UruguayanPeso: 'URUGUAYAN_PESO',
    UzbekistaniSom: 'UZBEKISTANI_SOM',
    VenezuelanBolivar: 'VENEZUELAN_BOLIVAR',
    VietnameseDong: 'VIETNAMESE_DONG',
    YemeniRial: 'YEMENI_RIAL',
    ZambianKwacha: 'ZAMBIAN_KWACHA',
    ZimbabweanDollar: 'ZIMBABWEAN_DOLLAR'
} as const;

export type JobResponseCurrencyEnum = typeof JobResponseCurrencyEnum[keyof typeof JobResponseCurrencyEnum];
export const JobResponseHrApprovalStatusEnum = {
    Pending: 'PENDING',
    Approved: 'APPROVED',
    Decline: 'DECLINE'
} as const;

export type JobResponseHrApprovalStatusEnum = typeof JobResponseHrApprovalStatusEnum[keyof typeof JobResponseHrApprovalStatusEnum];

/**
 * 
 * @export
 * @interface JobSteps
 */
export interface JobSteps {
    /**
     * 
     * @type {boolean}
     * @memberof JobSteps
     */
    'step1'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof JobSteps
     */
    'step2'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof JobSteps
     */
    'step3'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof JobSteps
     */
    'step4'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof JobSteps
     */
    'step5'?: boolean;
}
/**
 * 
 * @export
 * @interface JwtData
 */
export interface JwtData {
    /**
     * 
     * @type {string}
     * @memberof JwtData
     */
    'authorizationToken'?: string;
    /**
     * 
     * @type {string}
     * @memberof JwtData
     */
    'type'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof JwtData
     */
    'roles'?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof JwtData
     */
    'permissions'?: Array<string>;
}
/**
 * 
 * @export
 * @interface KycBioData
 */
export interface KycBioData {
    /**
     * 
     * @type {string}
     * @memberof KycBioData
     */
    'idNumber'?: string;
    /**
     * 
     * @type {string}
     * @memberof KycBioData
     */
    'idType'?: string;
    /**
     * 
     * @type {string}
     * @memberof KycBioData
     */
    'fullName'?: string;
    /**
     * 
     * @type {string}
     * @memberof KycBioData
     */
    'firstname'?: string;
    /**
     * 
     * @type {string}
     * @memberof KycBioData
     */
    'middlename'?: string;
    /**
     * 
     * @type {string}
     * @memberof KycBioData
     */
    'lastname'?: string;
    /**
     * 
     * @type {string}
     * @memberof KycBioData
     */
    'email'?: string;
    /**
     * 
     * @type {string}
     * @memberof KycBioData
     */
    'phoneNumber'?: string;
    /**
     * 
     * @type {string}
     * @memberof KycBioData
     */
    'phoneNumber2'?: string;
    /**
     * 
     * @type {string}
     * @memberof KycBioData
     */
    'dob'?: string;
    /**
     * 
     * @type {string}
     * @memberof KycBioData
     */
    'gender'?: string;
    /**
     * 
     * @type {string}
     * @memberof KycBioData
     */
    'maritalStatus'?: string;
    /**
     * 
     * @type {string}
     * @memberof KycBioData
     */
    'photo'?: string;
    /**
     * 
     * @type {string}
     * @memberof KycBioData
     */
    'country'?: string;
    /**
     * 
     * @type {string}
     * @memberof KycBioData
     */
    'nationality'?: string;
    /**
     * 
     * @type {string}
     * @memberof KycBioData
     */
    'stateOfOrigin'?: string;
    /**
     * 
     * @type {string}
     * @memberof KycBioData
     */
    'lgaOfOrigin'?: string;
    /**
     * 
     * @type {string}
     * @memberof KycBioData
     */
    'residentialAddress'?: string;
    /**
     * 
     * @type {string}
     * @memberof KycBioData
     */
    'stateOfResidence'?: string;
}
/**
 * 
 * @export
 * @interface KycDataResponse
 */
export interface KycDataResponse {
    /**
     * 
     * @type {string}
     * @memberof KycDataResponse
     */
    'kycId'?: string;
    /**
     * 
     * @type {string}
     * @memberof KycDataResponse
     */
    'kycType'?: KycDataResponseKycTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof KycDataResponse
     */
    'number'?: string;
    /**
     * 
     * @type {KycBioData}
     * @memberof KycDataResponse
     */
    'bioData'?: KycBioData;
    /**
     * 
     * @type {string}
     * @memberof KycDataResponse
     */
    'kycStatus'?: KycDataResponseKycStatusEnum;
    /**
     * 
     * @type {boolean}
     * @memberof KycDataResponse
     */
    'kycApproved'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof KycDataResponse
     */
    'remark'?: string;
    /**
     * 
     * @type {string}
     * @memberof KycDataResponse
     */
    'createdDate'?: string;
    /**
     * 
     * @type {string}
     * @memberof KycDataResponse
     */
    'lastModifiedDate'?: string;
    /**
     * 
     * @type {string}
     * @memberof KycDataResponse
     */
    'lastModifiedBy'?: string;
}

export const KycDataResponseKycTypeEnum = {
    Bvn: 'BVN',
    Nin: 'NIN',
    Cac: 'CAC',
    Tin: 'TIN',
    NationalId: 'NATIONAL_ID',
    Passport: 'PASSPORT',
    VotersCard: 'VOTERS_CARD',
    DriverLicense: 'DRIVER_LICENSE',
    SocialSecurity: 'SOCIAL_SECURITY'
} as const;

export type KycDataResponseKycTypeEnum = typeof KycDataResponseKycTypeEnum[keyof typeof KycDataResponseKycTypeEnum];
export const KycDataResponseKycStatusEnum = {
    Pending: 'PENDING',
    Verified: 'VERIFIED',
    Declined: 'DECLINED'
} as const;

export type KycDataResponseKycStatusEnum = typeof KycDataResponseKycStatusEnum[keyof typeof KycDataResponseKycStatusEnum];

/**
 * 
 * @export
 * @interface KycResponse
 */
export interface KycResponse {
    /**
     * 
     * @type {KycStatusResponse}
     * @memberof KycResponse
     */
    'kycStatus'?: KycStatusResponse;
    /**
     * 
     * @type {Array<KycDataResponse>}
     * @memberof KycResponse
     */
    'kycData'?: Array<KycDataResponse>;
}
/**
 * 
 * @export
 * @interface KycStatusResponse
 */
export interface KycStatusResponse {
    /**
     * 
     * @type {boolean}
     * @memberof KycStatusResponse
     */
    'bvnDone'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof KycStatusResponse
     */
    'ninDone'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof KycStatusResponse
     */
    'cacDone'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof KycStatusResponse
     */
    'tinDone'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof KycStatusResponse
     */
    'passportDone'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof KycStatusResponse
     */
    'pvcDone'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof KycStatusResponse
     */
    'nationalIdDone'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof KycStatusResponse
     */
    'driverLicenseDone'?: boolean;
}
/**
 * 
 * @export
 * @interface MainWalletMetrics
 */
export interface MainWalletMetrics {
    /**
     * 
     * @type {string}
     * @memberof MainWalletMetrics
     */
    'wallet'?: string;
    /**
     * 
     * @type {number}
     * @memberof MainWalletMetrics
     */
    'walletBalance'?: number;
}
/**
 * Name enquiry payload
 * @export
 * @interface NameEnquiry
 */
export interface NameEnquiry {
    /**
     * 
     * @type {string}
     * @memberof NameEnquiry
     */
    'bankCode': string;
    /**
     * 
     * @type {string}
     * @memberof NameEnquiry
     */
    'accountNumber': string;
}
/**
 * 
 * @export
 * @interface NameEnquiryDataResponse
 */
export interface NameEnquiryDataResponse {
    /**
     * 
     * @type {string}
     * @memberof NameEnquiryDataResponse
     */
    'sessionId'?: string;
    /**
     * 
     * @type {string}
     * @memberof NameEnquiryDataResponse
     */
    'bankCode'?: string;
    /**
     * 
     * @type {string}
     * @memberof NameEnquiryDataResponse
     */
    'accountName'?: string;
    /**
     * 
     * @type {string}
     * @memberof NameEnquiryDataResponse
     */
    'accountNumber'?: string;
}
/**
 * NIN verification payload
 * @export
 * @interface NinCheck
 */
export interface NinCheck {
    /**
     * 
     * @type {string}
     * @memberof NinCheck
     */
    'nin': string;
    /**
     * 
     * @type {string}
     * @memberof NinCheck
     */
    'dob': string;
    /**
     * 
     * @type {string}
     * @memberof NinCheck
     */
    'firstName': string;
    /**
     * 
     * @type {string}
     * @memberof NinCheck
     */
    'lastName': string;
}
/**
 * 
 * @export
 * @interface NinVerificationResponse
 */
export interface NinVerificationResponse {
    /**
     * 
     * @type {string}
     * @memberof NinVerificationResponse
     */
    'name'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof NinVerificationResponse
     */
    'ninAlreadyVerified'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof NinVerificationResponse
     */
    'referenceId'?: string;
    /**
     * 
     * @type {string}
     * @memberof NinVerificationResponse
     */
    'message'?: string;
}
/**
 * Complete NIN verification payload
 * @export
 * @interface NinVerifyOtp
 */
export interface NinVerifyOtp {
    /**
     * 
     * @type {string}
     * @memberof NinVerifyOtp
     */
    'ninOtp': string;
    /**
     * 
     * @type {string}
     * @memberof NinVerifyOtp
     */
    'referenceId': string;
}
/**
 * 
 * @export
 * @interface PayerDetails
 */
export interface PayerDetails {
    /**
     * 
     * @type {string}
     * @memberof PayerDetails
     */
    'paymentTransactionNo'?: string;
    /**
     * 
     * @type {string}
     * @memberof PayerDetails
     */
    'paymentTransactionReference'?: string;
    /**
     * 
     * @type {string}
     * @memberof PayerDetails
     */
    'paymentMethod'?: string;
    /**
     * 
     * @type {string}
     * @memberof PayerDetails
     */
    'payerAccountNumber'?: string;
    /**
     * 
     * @type {string}
     * @memberof PayerDetails
     */
    'payerName'?: string;
    /**
     * 
     * @type {string}
     * @memberof PayerDetails
     */
    'payerBank'?: string;
    /**
     * 
     * @type {string}
     * @memberof PayerDetails
     */
    'payerBankCode'?: string;
    /**
     * 
     * @type {string}
     * @memberof PayerDetails
     */
    'currency'?: PayerDetailsCurrencyEnum;
}

export const PayerDetailsCurrencyEnum = {
    Afghani: 'AFGHANI',
    AlgerianDinar: 'ALGERIAN_DINAR',
    AngolanKwanza: 'ANGOLAN_KWANZA',
    ArgentinePeso: 'ARGENTINE_PESO',
    AustralianDollar: 'AUSTRALIAN_DOLLAR',
    BahrainiDinar: 'BAHRAINI_DINAR',
    BangladeshiTaka: 'BANGLADESHI_TAKA',
    Bitcoin: 'BITCOIN',
    BrazilianReal: 'BRAZILIAN_REAL',
    BruneiDollar: 'BRUNEI_DOLLAR',
    BulgarianLev: 'BULGARIAN_LEV',
    BurundianFranc: 'BURUNDIAN_FRANC',
    CanadianDollar: 'CANADIAN_DOLLAR',
    CfaFrancBeac: 'CFA_FRANC_BEAC',
    CfaFrancBceao: 'CFA_FRANC_BCEAO',
    ChileanPeso: 'CHILEAN_PESO',
    ChineseYuan: 'CHINESE_YUAN',
    ColombianPeso: 'COLOMBIAN_PESO',
    CongoleseFranc: 'CONGOLESE_FRANC',
    CzechKoruna: 'CZECH_KORUNA',
    DanishKrone: 'DANISH_KRONE',
    DominicanPeso: 'DOMINICAN_PESO',
    EgyptianPound: 'EGYPTIAN_POUND',
    EthiopianBirr: 'ETHIOPIAN_BIRR',
    Euro: 'EURO',
    FijianDollar: 'FIJIAN_DOLLAR',
    GhanaianCedi: 'GHANAIAN_CEDI',
    GuineanFranc: 'GUINEAN_FRANC',
    HongKongDollar: 'HONG_KONG_DOLLAR',
    HungarianForint: 'HUNGARIAN_FORINT',
    IcelandicKrona: 'ICELANDIC_KRONA',
    IndianRupee: 'INDIAN_RUPEE',
    IndonesianRupiah: 'INDONESIAN_RUPIAH',
    IranianRial: 'IRANIAN_RIAL',
    IraqiDinar: 'IRAQI_DINAR',
    IsraeliShekel: 'ISRAELI_SHEKEL',
    JamaicanDollar: 'JAMAICAN_DOLLAR',
    JapaneseYen: 'JAPANESE_YEN',
    JordanianDinar: 'JORDANIAN_DINAR',
    KazakhstaniTenge: 'KAZAKHSTANI_TENGE',
    KenyanShilling: 'KENYAN_SHILLING',
    KuwaitiDinar: 'KUWAITI_DINAR',
    LaosKip: 'LAOS_KIp',
    LebanesePound: 'LEBANESE_POUND',
    LibyanDinar: 'LIBYAN_DINAR',
    MalagasyAriary: 'MALAGASY_ARIARY',
    MalawianKwacha: 'MALAWIAN_KWACHA',
    MalaysianRinggit: 'MALAYSIAN_RINGGIT',
    MauritianRupee: 'MAURITIAN_RUPEE',
    MexicanPeso: 'MEXICAN_PESO',
    MoroccanDirham: 'MOROCCAN_DIRHAM',
    MozambicanMetical: 'MOZAMBICAN_METICAL',
    NamibianDollar: 'NAMIBIAN_DOLLAR',
    Naira: 'NAIRA',
    NepaleseRupee: 'NEPALESE_RUPEE',
    NewZealandDollar: 'NEW_ZEALAND_DOLLAR',
    NorwegianKrone: 'NORWEGIAN_KRONE',
    OmaniRial: 'OMANI_RIAL',
    PakistaniRupee: 'PAKISTANI_RUPEE',
    PhilippinePeso: 'PHILIPPINE_PESO',
    PolishZloty: 'POLISH_ZLOTY',
    QatariRiyal: 'QATARI_RIYAL',
    RomanianLeu: 'ROMANIAN_LEU',
    RussianRuble: 'RUSSIAN_RUBLE',
    RwandanFranc: 'RWANDAN_FRANC',
    SaudiRiyal: 'SAUDI_RIYAL',
    SerbianDinar: 'SERBIAN_DINAR',
    SeychellesRupee: 'SEYCHELLES_RUPEE',
    SingaporeDollar: 'SINGAPORE_DOLLAR',
    SomaliShilling: 'SOMALI_SHILLING',
    SouthAfricanRand: 'SOUTH_AFRICAN_RAND',
    SouthKoreanWon: 'SOUTH_KOREAN_WON',
    SouthSudanesePound: 'SOUTH_SUDANESE_POUND',
    SriLankanRupee: 'SRI_LANKAN_RUPEE',
    SwedishKrona: 'SWEDISH_KRONA',
    SwissFranc: 'SWISS_FRANC',
    SyrianPound: 'SYRIAN_POUND',
    TaiwanDollar: 'TAIWAN_DOLLAR',
    TanzanianShilling: 'TANZANIAN_SHILLING',
    ThaiBaht: 'THAI_BAHT',
    TunisianDinar: 'TUNISIAN_DINAR',
    TurkishLira: 'TURKISH_LIRA',
    UgandanShilling: 'UGANDAN_SHILLING',
    UkrainianHryvnia: 'UKRAINIAN_HRYVNIA',
    UaeDirham: 'UAE_DIRHAM',
    UkPound: 'UK_POUND',
    UsDollar: 'US_DOLLAR',
    UruguayanPeso: 'URUGUAYAN_PESO',
    UzbekistaniSom: 'UZBEKISTANI_SOM',
    VenezuelanBolivar: 'VENEZUELAN_BOLIVAR',
    VietnameseDong: 'VIETNAMESE_DONG',
    YemeniRial: 'YEMENI_RIAL',
    ZambianKwacha: 'ZAMBIAN_KWACHA',
    ZimbabweanDollar: 'ZIMBABWEAN_DOLLAR'
} as const;

export type PayerDetailsCurrencyEnum = typeof PayerDetailsCurrencyEnum[keyof typeof PayerDetailsCurrencyEnum];

/**
 * Otp resend payload
 * @export
 * @interface ResendBvnOtp
 */
export interface ResendBvnOtp {
    /**
     * 
     * @type {string}
     * @memberof ResendBvnOtp
     */
    'referenceId': string;
}
/**
 * Otp resend payload
 * @export
 * @interface ResendNinOtp
 */
export interface ResendNinOtp {
    /**
     * 
     * @type {string}
     * @memberof ResendNinOtp
     */
    'referenceId': string;
}
/**
 * Resend OTP for account payload
 * @export
 * @interface ResendOtpForVirtualAccountCreation
 */
export interface ResendOtpForVirtualAccountCreation {
    /**
     * 
     * @type {string}
     * @memberof ResendOtpForVirtualAccountCreation
     */
    'reference': string;
}
/**
 * Callback payload
 * @export
 * @interface SafeHavenTransferCallback
 */
export interface SafeHavenTransferCallback {
    /**
     * 
     * @type {string}
     * @memberof SafeHavenTransferCallback
     */
    'type'?: string;
    /**
     * 
     * @type {CallbackTransferData}
     * @memberof SafeHavenTransferCallback
     */
    'data'?: CallbackTransferData;
}
/**
 * Send OTP payload
 * @export
 * @interface SendOTPRequest
 */
export interface SendOTPRequest {
    /**
     * 
     * @type {string}
     * @memberof SendOTPRequest
     */
    'email': string;
}
/**
 * Set transaction pin payload
 * @export
 * @interface SetTransactionPin
 */
export interface SetTransactionPin {
    /**
     * 
     * @type {string}
     * @memberof SetTransactionPin
     */
    'transactionPin': string;
    /**
     * 
     * @type {string}
     * @memberof SetTransactionPin
     */
    'confirmTransactionPin': string;
}
/**
 * 
 * @export
 * @interface SignInResponse
 */
export interface SignInResponse {
    /**
     * 
     * @type {UserData}
     * @memberof SignInResponse
     */
    'userAccountData'?: UserData;
    /**
     * 
     * @type {JwtData}
     * @memberof SignInResponse
     */
    'jwtTokenData'?: JwtData;
}
/**
 * User registration payload
 * @export
 * @interface SignUpRequest
 */
export interface SignUpRequest {
    /**
     * 
     * @type {string}
     * @memberof SignUpRequest
     */
    'firstName': string;
    /**
     * 
     * @type {string}
     * @memberof SignUpRequest
     */
    'lastName': string;
    /**
     * 
     * @type {string}
     * @memberof SignUpRequest
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof SignUpRequest
     */
    'phone': string;
    /**
     * 
     * @type {string}
     * @memberof SignUpRequest
     */
    'password': string;
    /**
     * 
     * @type {string}
     * @memberof SignUpRequest
     */
    'organizationType'?: SignUpRequestOrganizationTypeEnum;
}

export const SignUpRequestOrganizationTypeEnum = {
    Private: 'PRIVATE',
    Government: 'GOVERNMENT',
    Ngo: 'NGO'
} as const;

export type SignUpRequestOrganizationTypeEnum = typeof SignUpRequestOrganizationTypeEnum[keyof typeof SignUpRequestOrganizationTypeEnum];

/**
 * 
 * @export
 * @interface TransactionResponse
 */
export interface TransactionResponse {
    /**
     * 
     * @type {string}
     * @memberof TransactionResponse
     */
    'transactionId'?: string;
    /**
     * 
     * @type {string}
     * @memberof TransactionResponse
     */
    'transactionNo'?: string;
    /**
     * 
     * @type {string}
     * @memberof TransactionResponse
     */
    'transactionReference'?: string;
    /**
     * 
     * @type {string}
     * @memberof TransactionResponse
     */
    'transactionDate'?: string;
    /**
     * 
     * @type {string}
     * @memberof TransactionResponse
     */
    'transactionType'?: TransactionResponseTransactionTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof TransactionResponse
     */
    'paymentType'?: TransactionResponsePaymentTypeEnum;
    /**
     * 
     * @type {number}
     * @memberof TransactionResponse
     */
    'amount'?: number;
    /**
     * 
     * @type {number}
     * @memberof TransactionResponse
     */
    'charges'?: number;
    /**
     * 
     * @type {number}
     * @memberof TransactionResponse
     */
    'totalAmount'?: number;
    /**
     * 
     * @type {string}
     * @memberof TransactionResponse
     */
    'currency'?: TransactionResponseCurrencyEnum;
    /**
     * 
     * @type {string}
     * @memberof TransactionResponse
     */
    'channels'?: TransactionResponseChannelsEnum;
    /**
     * 
     * @type {string}
     * @memberof TransactionResponse
     */
    'medium'?: TransactionResponseMediumEnum;
    /**
     * 
     * @type {string}
     * @memberof TransactionResponse
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof TransactionResponse
     */
    'narration'?: string;
    /**
     * 
     * @type {string}
     * @memberof TransactionResponse
     */
    'remark'?: string;
    /**
     * 
     * @type {string}
     * @memberof TransactionResponse
     */
    'category'?: string;
    /**
     * 
     * @type {number}
     * @memberof TransactionResponse
     */
    'balanceBefore'?: number;
    /**
     * 
     * @type {number}
     * @memberof TransactionResponse
     */
    'balanceAfter'?: number;
    /**
     * 
     * @type {PayerDetails}
     * @memberof TransactionResponse
     */
    'senderDetails'?: PayerDetails;
    /**
     * 
     * @type {PayerDetails}
     * @memberof TransactionResponse
     */
    'recipientDetails'?: PayerDetails;
    /**
     * 
     * @type {string}
     * @memberof TransactionResponse
     */
    'status'?: TransactionResponseStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof TransactionResponse
     */
    'createdDate'?: string;
    /**
     * 
     * @type {string}
     * @memberof TransactionResponse
     */
    'lastModifiedDate'?: string;
    /**
     * 
     * @type {string}
     * @memberof TransactionResponse
     */
    'lastModifiedBy'?: string;
}

export const TransactionResponseTransactionTypeEnum = {
    Debit: 'DEBIT',
    Credit: 'CREDIT'
} as const;

export type TransactionResponseTransactionTypeEnum = typeof TransactionResponseTransactionTypeEnum[keyof typeof TransactionResponseTransactionTypeEnum];
export const TransactionResponsePaymentTypeEnum = {
    Transaction: 'TRANSACTION',
    Charges: 'CHARGES'
} as const;

export type TransactionResponsePaymentTypeEnum = typeof TransactionResponsePaymentTypeEnum[keyof typeof TransactionResponsePaymentTypeEnum];
export const TransactionResponseCurrencyEnum = {
    Afghani: 'AFGHANI',
    AlgerianDinar: 'ALGERIAN_DINAR',
    AngolanKwanza: 'ANGOLAN_KWANZA',
    ArgentinePeso: 'ARGENTINE_PESO',
    AustralianDollar: 'AUSTRALIAN_DOLLAR',
    BahrainiDinar: 'BAHRAINI_DINAR',
    BangladeshiTaka: 'BANGLADESHI_TAKA',
    Bitcoin: 'BITCOIN',
    BrazilianReal: 'BRAZILIAN_REAL',
    BruneiDollar: 'BRUNEI_DOLLAR',
    BulgarianLev: 'BULGARIAN_LEV',
    BurundianFranc: 'BURUNDIAN_FRANC',
    CanadianDollar: 'CANADIAN_DOLLAR',
    CfaFrancBeac: 'CFA_FRANC_BEAC',
    CfaFrancBceao: 'CFA_FRANC_BCEAO',
    ChileanPeso: 'CHILEAN_PESO',
    ChineseYuan: 'CHINESE_YUAN',
    ColombianPeso: 'COLOMBIAN_PESO',
    CongoleseFranc: 'CONGOLESE_FRANC',
    CzechKoruna: 'CZECH_KORUNA',
    DanishKrone: 'DANISH_KRONE',
    DominicanPeso: 'DOMINICAN_PESO',
    EgyptianPound: 'EGYPTIAN_POUND',
    EthiopianBirr: 'ETHIOPIAN_BIRR',
    Euro: 'EURO',
    FijianDollar: 'FIJIAN_DOLLAR',
    GhanaianCedi: 'GHANAIAN_CEDI',
    GuineanFranc: 'GUINEAN_FRANC',
    HongKongDollar: 'HONG_KONG_DOLLAR',
    HungarianForint: 'HUNGARIAN_FORINT',
    IcelandicKrona: 'ICELANDIC_KRONA',
    IndianRupee: 'INDIAN_RUPEE',
    IndonesianRupiah: 'INDONESIAN_RUPIAH',
    IranianRial: 'IRANIAN_RIAL',
    IraqiDinar: 'IRAQI_DINAR',
    IsraeliShekel: 'ISRAELI_SHEKEL',
    JamaicanDollar: 'JAMAICAN_DOLLAR',
    JapaneseYen: 'JAPANESE_YEN',
    JordanianDinar: 'JORDANIAN_DINAR',
    KazakhstaniTenge: 'KAZAKHSTANI_TENGE',
    KenyanShilling: 'KENYAN_SHILLING',
    KuwaitiDinar: 'KUWAITI_DINAR',
    LaosKip: 'LAOS_KIp',
    LebanesePound: 'LEBANESE_POUND',
    LibyanDinar: 'LIBYAN_DINAR',
    MalagasyAriary: 'MALAGASY_ARIARY',
    MalawianKwacha: 'MALAWIAN_KWACHA',
    MalaysianRinggit: 'MALAYSIAN_RINGGIT',
    MauritianRupee: 'MAURITIAN_RUPEE',
    MexicanPeso: 'MEXICAN_PESO',
    MoroccanDirham: 'MOROCCAN_DIRHAM',
    MozambicanMetical: 'MOZAMBICAN_METICAL',
    NamibianDollar: 'NAMIBIAN_DOLLAR',
    Naira: 'NAIRA',
    NepaleseRupee: 'NEPALESE_RUPEE',
    NewZealandDollar: 'NEW_ZEALAND_DOLLAR',
    NorwegianKrone: 'NORWEGIAN_KRONE',
    OmaniRial: 'OMANI_RIAL',
    PakistaniRupee: 'PAKISTANI_RUPEE',
    PhilippinePeso: 'PHILIPPINE_PESO',
    PolishZloty: 'POLISH_ZLOTY',
    QatariRiyal: 'QATARI_RIYAL',
    RomanianLeu: 'ROMANIAN_LEU',
    RussianRuble: 'RUSSIAN_RUBLE',
    RwandanFranc: 'RWANDAN_FRANC',
    SaudiRiyal: 'SAUDI_RIYAL',
    SerbianDinar: 'SERBIAN_DINAR',
    SeychellesRupee: 'SEYCHELLES_RUPEE',
    SingaporeDollar: 'SINGAPORE_DOLLAR',
    SomaliShilling: 'SOMALI_SHILLING',
    SouthAfricanRand: 'SOUTH_AFRICAN_RAND',
    SouthKoreanWon: 'SOUTH_KOREAN_WON',
    SouthSudanesePound: 'SOUTH_SUDANESE_POUND',
    SriLankanRupee: 'SRI_LANKAN_RUPEE',
    SwedishKrona: 'SWEDISH_KRONA',
    SwissFranc: 'SWISS_FRANC',
    SyrianPound: 'SYRIAN_POUND',
    TaiwanDollar: 'TAIWAN_DOLLAR',
    TanzanianShilling: 'TANZANIAN_SHILLING',
    ThaiBaht: 'THAI_BAHT',
    TunisianDinar: 'TUNISIAN_DINAR',
    TurkishLira: 'TURKISH_LIRA',
    UgandanShilling: 'UGANDAN_SHILLING',
    UkrainianHryvnia: 'UKRAINIAN_HRYVNIA',
    UaeDirham: 'UAE_DIRHAM',
    UkPound: 'UK_POUND',
    UsDollar: 'US_DOLLAR',
    UruguayanPeso: 'URUGUAYAN_PESO',
    UzbekistaniSom: 'UZBEKISTANI_SOM',
    VenezuelanBolivar: 'VENEZUELAN_BOLIVAR',
    VietnameseDong: 'VIETNAMESE_DONG',
    YemeniRial: 'YEMENI_RIAL',
    ZambianKwacha: 'ZAMBIAN_KWACHA',
    ZimbabweanDollar: 'ZIMBABWEAN_DOLLAR'
} as const;

export type TransactionResponseCurrencyEnum = typeof TransactionResponseCurrencyEnum[keyof typeof TransactionResponseCurrencyEnum];
export const TransactionResponseChannelsEnum = {
    BankToWallet: 'BANK_TO_WALLET',
    WalletToBank: 'WALLET_TO_BANK',
    WalletToWallet: 'WALLET_TO_WALLET',
    DailyPayWalletCredit: 'DAILY_PAY_WALLET_CREDIT',
    DailyPayWalletToMainWallet: 'DAILY_PAY_WALLET_TO_MAIN_WALLET',
    MonthlyDailyPayWalletSweep: 'MONTHLY_DAILY_PAY_WALLET_SWEEP',
    DailyPayCreditRepayment: 'DAILY_PAY_CREDIT_REPAYMENT',
    TransactionCharges: 'TRANSACTION_CHARGES'
} as const;

export type TransactionResponseChannelsEnum = typeof TransactionResponseChannelsEnum[keyof typeof TransactionResponseChannelsEnum];
export const TransactionResponseMediumEnum = {
    MainWallet: 'MAIN_WALLET',
    DailyPayWallet: 'DAILY_PAY_WALLET',
    Card: 'CARD'
} as const;

export type TransactionResponseMediumEnum = typeof TransactionResponseMediumEnum[keyof typeof TransactionResponseMediumEnum];
export const TransactionResponseStatusEnum = {
    Success: 'SUCCESS',
    Pending: 'PENDING',
    Reversed: 'REVERSED',
    Failed: 'FAILED'
} as const;

export type TransactionResponseStatusEnum = typeof TransactionResponseStatusEnum[keyof typeof TransactionResponseStatusEnum];

/**
 * User profile update payload
 * @export
 * @interface UpdateUserProfile
 */
export interface UpdateUserProfile {
    /**
     * 
     * @type {string}
     * @memberof UpdateUserProfile
     */
    'firstName'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateUserProfile
     */
    'lastName'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateUserProfile
     */
    'phone'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateUserProfile
     */
    'language'?: UpdateUserProfileLanguageEnum;
    /**
     * 
     * @type {string}
     * @memberof UpdateUserProfile
     */
    'fcmToken'?: string;
}

export const UpdateUserProfileLanguageEnum = {
    Afrikaans: 'AFRIKAANS',
    Albanian: 'ALBANIAN',
    Amharic: 'AMHARIC',
    Arabic: 'ARABIC',
    ArabicEgyptian: 'ARABIC_EGYPTIAN',
    Armenian: 'ARMENIAN',
    Azerbaijani: 'AZERBAIJANI',
    Balochi: 'BALOCHI',
    Basque: 'BASQUE',
    Belarusian: 'BELARUSIAN',
    Bengali: 'BENGALI',
    Bhojpuri: 'BHOJPURI',
    Bosnian: 'BOSNIAN',
    Breton: 'BRETON',
    Bulgarian: 'BULGARIAN',
    Burmese: 'BURMESE',
    Chewa: 'CHEWA',
    Chhattisgarhi: 'CHHATTISGARHI',
    Chopi: 'CHOPI',
    Croatian: 'CROATIAN',
    Czech: 'CZECH',
    Danish: 'DANISH',
    Dhundhari: 'DHUNDHARI',
    Dutch: 'DUTCH',
    English: 'ENGLISH',
    Estonian: 'ESTONIAN',
    Faroese: 'FAROESE',
    Farsi: 'FARSI',
    Finnish: 'FINNISH',
    French: 'FRENCH',
    Fula: 'FULA',
    Ganda: 'GANDA',
    Georgian: 'GEORGIAN',
    German: 'GERMAN',
    Greek: 'GREEK',
    Greenlandic: 'GREENLANDIC',
    Gujarati: 'GUJARATI',
    HaitianCreole: 'HAITIAN_CREOLE',
    Hausa: 'HAUSA',
    Herero: 'HERERO',
    Hiligaynon: 'HILIGAYNON',
    Hindi: 'HINDI',
    Hmong: 'HMONG',
    Hungarian: 'HUNGARIAN',
    Icelandic: 'ICELANDIC',
    Igbo: 'IGBO',
    Ilocano: 'ILOCANO',
    Indonesian: 'INDONESIAN',
    Irish: 'IRISH',
    Italian: 'ITALIAN',
    Javanese: 'JAVANESE',
    Japanese: 'JAPANESE',
    Kabyle: 'KABYLE',
    Kannada: 'KANNADA',
    Kazakh: 'KAZAKH',
    Kikongo: 'KIKONGO',
    Kinyarwanda: 'KINYARWANDA',
    Kirundi: 'KIRUNDI',
    Konkani: 'KONKANI',
    Korean: 'KOREAN',
    Kurdish: 'KURDISH',
    Latvian: 'LATVIAN',
    Lingala: 'LINGALA',
    Lithuanian: 'LITHUANIAN',
    Luxembourgish: 'LUXEMBOURGISH',
    Macedonian: 'MACEDONIAN',
    Maithili: 'MAITHILI',
    Malay: 'MALAY',
    Malayalam: 'MALAYALAM',
    Maltese: 'MALTESE',
    Mandarin: 'MANDARIN',
    Marathi: 'MARATHI',
    Mongolian: 'MONGOLIAN',
    Mossi: 'MOSSI',
    Nama: 'NAMA',
    Ndebele: 'NDEBELE',
    Nepali: 'NEPALI',
    Norwegian: 'NORWEGIAN',
    Oriya: 'ORIYA',
    Oshiwambo: 'OSHIWAMBO',
    Pashto: 'PASHTO',
    Persian: 'PERSIAN',
    Polish: 'POLISH',
    Portuguese: 'PORTUGUESE',
    Quechua: 'QUECHUA',
    Romanian: 'ROMANIAN',
    Ronga: 'RONGA',
    Russian: 'RUSSIAN',
    Sami: 'SAMI',
    San: 'SAN',
    ScotsGaelic: 'SCOTS_GAELIC',
    Serbian: 'SERBIAN',
    SerboCroatian: 'SERBO_CROATIAN',
    Shona: 'SHONA',
    Sinhala: 'SINHALA',
    Slovak: 'SLOVAK',
    Somali: 'SOMALI',
    Soninke: 'SONINKE',
    Sotho: 'SOTHO',
    SouthernMin: 'SOUTHERN_MIN',
    Spanish: 'SPANISH',
    Sundanese: 'SUNDANESE',
    Swahili: 'SWAHILI',
    Swazi: 'SWAZI',
    Swedish: 'SWEDISH',
    Tamashek: 'TAMASHEK',
    Tamil: 'TAMIL',
    Tatar: 'TATAR',
    Telugu: 'TELUGU',
    Thai: 'THAI',
    Tigrinya: 'TIGRINYA',
    Tswa: 'TSWA',
    Tswana: 'TSWANA',
    Turkish: 'TURKISH',
    Uyghur: 'UYGHUR',
    Urdu: 'URDU',
    Uzbek: 'UZBEK',
    Venda: 'VENDA',
    Vietnamese: 'VIETNAMESE',
    Welsh: 'WELSH',
    Wolof: 'WOLOF',
    Xhosa: 'XHOSA',
    Yoruba: 'YORUBA',
    Yue: 'YUE',
    Zulu: 'ZULU'
} as const;

export type UpdateUserProfileLanguageEnum = typeof UpdateUserProfileLanguageEnum[keyof typeof UpdateUserProfileLanguageEnum];

/**
 * User profile photo update payload
 * @export
 * @interface UpdateUserProfilePhoto
 */
export interface UpdateUserProfilePhoto {
    /**
     * 
     * @type {string}
     * @memberof UpdateUserProfilePhoto
     */
    'based64String': string;
}
/**
 * 
 * @export
 * @interface UpdateUserProfilePhotoRequest
 */
export interface UpdateUserProfilePhotoRequest {
    /**
     * 
     * @type {File}
     * @memberof UpdateUserProfilePhotoRequest
     */
    'file': File;
}
/**
 * File upload payload
 * @export
 * @interface UploadBase64File
 */
export interface UploadBase64File {
    /**
     * 
     * @type {string}
     * @memberof UploadBase64File
     */
    'base64String'?: string;
}
/**
 * 
 * @export
 * @interface UserData
 */
export interface UserData {
    /**
     * 
     * @type {string}
     * @memberof UserData
     */
    'userId'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserData
     */
    'firstName'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserData
     */
    'lastName'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserData
     */
    'email'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserData
     */
    'phone'?: string;
    /**
     * 
     * @type {AddressResponse}
     * @memberof UserData
     */
    'address'?: AddressResponse;
    /**
     * 
     * @type {string}
     * @memberof UserData
     */
    'userType'?: UserDataUserTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof UserData
     */
    'organizationType'?: UserDataOrganizationTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof UserData
     */
    'language'?: UserDataLanguageEnum;
    /**
     * 
     * @type {FileUploadResponse}
     * @memberof UserData
     */
    'photo'?: FileUploadResponse;
    /**
     * 
     * @type {string}
     * @memberof UserData
     */
    'onboardingStage'?: UserDataOnboardingStageEnum;
    /**
     * 
     * @type {boolean}
     * @memberof UserData
     */
    'activated'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof UserData
     */
    'status'?: UserDataStatusEnum;
    /**
     * 
     * @type {boolean}
     * @memberof UserData
     */
    'isTwoFaEnabled'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof UserData
     */
    'twoFaType'?: UserDataTwoFaTypeEnum;
    /**
     * 
     * @type {boolean}
     * @memberof UserData
     */
    'isOnline'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof UserData
     */
    'isTransactionPinSet'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof UserData
     */
    'dailyPayActivated'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof UserData
     */
    'dailyPayActivationDate'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserData
     */
    'authorizedDevice'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserData
     */
    'authorizedDeviceId'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserData
     */
    'fcmToken'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserData
     */
    'lastLogin'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserData
     */
    'createdDate'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserData
     */
    'lastModifiedDate'?: string;
}

export const UserDataUserTypeEnum = {
    User: 'USER',
    Admin: 'ADMIN'
} as const;

export type UserDataUserTypeEnum = typeof UserDataUserTypeEnum[keyof typeof UserDataUserTypeEnum];
export const UserDataOrganizationTypeEnum = {
    Private: 'PRIVATE',
    Government: 'GOVERNMENT',
    Ngo: 'NGO'
} as const;

export type UserDataOrganizationTypeEnum = typeof UserDataOrganizationTypeEnum[keyof typeof UserDataOrganizationTypeEnum];
export const UserDataLanguageEnum = {
    Afrikaans: 'AFRIKAANS',
    Albanian: 'ALBANIAN',
    Amharic: 'AMHARIC',
    Arabic: 'ARABIC',
    ArabicEgyptian: 'ARABIC_EGYPTIAN',
    Armenian: 'ARMENIAN',
    Azerbaijani: 'AZERBAIJANI',
    Balochi: 'BALOCHI',
    Basque: 'BASQUE',
    Belarusian: 'BELARUSIAN',
    Bengali: 'BENGALI',
    Bhojpuri: 'BHOJPURI',
    Bosnian: 'BOSNIAN',
    Breton: 'BRETON',
    Bulgarian: 'BULGARIAN',
    Burmese: 'BURMESE',
    Chewa: 'CHEWA',
    Chhattisgarhi: 'CHHATTISGARHI',
    Chopi: 'CHOPI',
    Croatian: 'CROATIAN',
    Czech: 'CZECH',
    Danish: 'DANISH',
    Dhundhari: 'DHUNDHARI',
    Dutch: 'DUTCH',
    English: 'ENGLISH',
    Estonian: 'ESTONIAN',
    Faroese: 'FAROESE',
    Farsi: 'FARSI',
    Finnish: 'FINNISH',
    French: 'FRENCH',
    Fula: 'FULA',
    Ganda: 'GANDA',
    Georgian: 'GEORGIAN',
    German: 'GERMAN',
    Greek: 'GREEK',
    Greenlandic: 'GREENLANDIC',
    Gujarati: 'GUJARATI',
    HaitianCreole: 'HAITIAN_CREOLE',
    Hausa: 'HAUSA',
    Herero: 'HERERO',
    Hiligaynon: 'HILIGAYNON',
    Hindi: 'HINDI',
    Hmong: 'HMONG',
    Hungarian: 'HUNGARIAN',
    Icelandic: 'ICELANDIC',
    Igbo: 'IGBO',
    Ilocano: 'ILOCANO',
    Indonesian: 'INDONESIAN',
    Irish: 'IRISH',
    Italian: 'ITALIAN',
    Javanese: 'JAVANESE',
    Japanese: 'JAPANESE',
    Kabyle: 'KABYLE',
    Kannada: 'KANNADA',
    Kazakh: 'KAZAKH',
    Kikongo: 'KIKONGO',
    Kinyarwanda: 'KINYARWANDA',
    Kirundi: 'KIRUNDI',
    Konkani: 'KONKANI',
    Korean: 'KOREAN',
    Kurdish: 'KURDISH',
    Latvian: 'LATVIAN',
    Lingala: 'LINGALA',
    Lithuanian: 'LITHUANIAN',
    Luxembourgish: 'LUXEMBOURGISH',
    Macedonian: 'MACEDONIAN',
    Maithili: 'MAITHILI',
    Malay: 'MALAY',
    Malayalam: 'MALAYALAM',
    Maltese: 'MALTESE',
    Mandarin: 'MANDARIN',
    Marathi: 'MARATHI',
    Mongolian: 'MONGOLIAN',
    Mossi: 'MOSSI',
    Nama: 'NAMA',
    Ndebele: 'NDEBELE',
    Nepali: 'NEPALI',
    Norwegian: 'NORWEGIAN',
    Oriya: 'ORIYA',
    Oshiwambo: 'OSHIWAMBO',
    Pashto: 'PASHTO',
    Persian: 'PERSIAN',
    Polish: 'POLISH',
    Portuguese: 'PORTUGUESE',
    Quechua: 'QUECHUA',
    Romanian: 'ROMANIAN',
    Ronga: 'RONGA',
    Russian: 'RUSSIAN',
    Sami: 'SAMI',
    San: 'SAN',
    ScotsGaelic: 'SCOTS_GAELIC',
    Serbian: 'SERBIAN',
    SerboCroatian: 'SERBO_CROATIAN',
    Shona: 'SHONA',
    Sinhala: 'SINHALA',
    Slovak: 'SLOVAK',
    Somali: 'SOMALI',
    Soninke: 'SONINKE',
    Sotho: 'SOTHO',
    SouthernMin: 'SOUTHERN_MIN',
    Spanish: 'SPANISH',
    Sundanese: 'SUNDANESE',
    Swahili: 'SWAHILI',
    Swazi: 'SWAZI',
    Swedish: 'SWEDISH',
    Tamashek: 'TAMASHEK',
    Tamil: 'TAMIL',
    Tatar: 'TATAR',
    Telugu: 'TELUGU',
    Thai: 'THAI',
    Tigrinya: 'TIGRINYA',
    Tswa: 'TSWA',
    Tswana: 'TSWANA',
    Turkish: 'TURKISH',
    Uyghur: 'UYGHUR',
    Urdu: 'URDU',
    Uzbek: 'UZBEK',
    Venda: 'VENDA',
    Vietnamese: 'VIETNAMESE',
    Welsh: 'WELSH',
    Wolof: 'WOLOF',
    Xhosa: 'XHOSA',
    Yoruba: 'YORUBA',
    Yue: 'YUE',
    Zulu: 'ZULU'
} as const;

export type UserDataLanguageEnum = typeof UserDataLanguageEnum[keyof typeof UserDataLanguageEnum];
export const UserDataOnboardingStageEnum = {
    Started: 'STARTED',
    OtpVerification: 'OTP_VERIFICATION',
    Completed: 'COMPLETED'
} as const;

export type UserDataOnboardingStageEnum = typeof UserDataOnboardingStageEnum[keyof typeof UserDataOnboardingStageEnum];
export const UserDataStatusEnum = {
    Inactive: 'INACTIVE',
    Active: 'ACTIVE',
    Archived: 'ARCHIVED',
    Deleted: 'DELETED'
} as const;

export type UserDataStatusEnum = typeof UserDataStatusEnum[keyof typeof UserDataStatusEnum];
export const UserDataTwoFaTypeEnum = {
    Email: 'EMAIL',
    Phone: 'PHONE',
    Whatsapp: 'WHATSAPP',
    AuthenticationApp: 'AUTHENTICATION_APP'
} as const;

export type UserDataTwoFaTypeEnum = typeof UserDataTwoFaTypeEnum[keyof typeof UserDataTwoFaTypeEnum];

/**
 * 
 * @export
 * @interface UsersResponse
 */
export interface UsersResponse {
    /**
     * 
     * @type {string}
     * @memberof UsersResponse
     */
    'userId'?: string;
    /**
     * 
     * @type {string}
     * @memberof UsersResponse
     */
    'firstName'?: string;
    /**
     * 
     * @type {string}
     * @memberof UsersResponse
     */
    'lastName'?: string;
    /**
     * 
     * @type {string}
     * @memberof UsersResponse
     */
    'email'?: string;
    /**
     * 
     * @type {string}
     * @memberof UsersResponse
     */
    'phone'?: string;
    /**
     * 
     * @type {AddressResponse}
     * @memberof UsersResponse
     */
    'address'?: AddressResponse;
    /**
     * 
     * @type {string}
     * @memberof UsersResponse
     */
    'userType'?: UsersResponseUserTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof UsersResponse
     */
    'organizationType'?: UsersResponseOrganizationTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof UsersResponse
     */
    'language'?: UsersResponseLanguageEnum;
    /**
     * 
     * @type {FileUploadResponse}
     * @memberof UsersResponse
     */
    'photo'?: FileUploadResponse;
    /**
     * 
     * @type {string}
     * @memberof UsersResponse
     */
    'onboardingStage'?: UsersResponseOnboardingStageEnum;
    /**
     * 
     * @type {boolean}
     * @memberof UsersResponse
     */
    'activated'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof UsersResponse
     */
    'status'?: UsersResponseStatusEnum;
    /**
     * 
     * @type {boolean}
     * @memberof UsersResponse
     */
    'isTwoFaEnabled'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof UsersResponse
     */
    'twoFaType'?: UsersResponseTwoFaTypeEnum;
    /**
     * 
     * @type {boolean}
     * @memberof UsersResponse
     */
    'isOnline'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof UsersResponse
     */
    'isTransactionPinSet'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof UsersResponse
     */
    'dailyPayActivated'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof UsersResponse
     */
    'dailyPayActivationDate'?: string;
    /**
     * 
     * @type {string}
     * @memberof UsersResponse
     */
    'authorizedDevice'?: string;
    /**
     * 
     * @type {string}
     * @memberof UsersResponse
     */
    'authorizedDeviceId'?: string;
    /**
     * 
     * @type {string}
     * @memberof UsersResponse
     */
    'fcmToken'?: string;
    /**
     * 
     * @type {string}
     * @memberof UsersResponse
     */
    'lastLogin'?: string;
    /**
     * 
     * @type {string}
     * @memberof UsersResponse
     */
    'createdDate'?: string;
    /**
     * 
     * @type {string}
     * @memberof UsersResponse
     */
    'lastModifiedDate'?: string;
}

export const UsersResponseUserTypeEnum = {
    User: 'USER',
    Admin: 'ADMIN'
} as const;

export type UsersResponseUserTypeEnum = typeof UsersResponseUserTypeEnum[keyof typeof UsersResponseUserTypeEnum];
export const UsersResponseOrganizationTypeEnum = {
    Private: 'PRIVATE',
    Government: 'GOVERNMENT',
    Ngo: 'NGO'
} as const;

export type UsersResponseOrganizationTypeEnum = typeof UsersResponseOrganizationTypeEnum[keyof typeof UsersResponseOrganizationTypeEnum];
export const UsersResponseLanguageEnum = {
    Afrikaans: 'AFRIKAANS',
    Albanian: 'ALBANIAN',
    Amharic: 'AMHARIC',
    Arabic: 'ARABIC',
    ArabicEgyptian: 'ARABIC_EGYPTIAN',
    Armenian: 'ARMENIAN',
    Azerbaijani: 'AZERBAIJANI',
    Balochi: 'BALOCHI',
    Basque: 'BASQUE',
    Belarusian: 'BELARUSIAN',
    Bengali: 'BENGALI',
    Bhojpuri: 'BHOJPURI',
    Bosnian: 'BOSNIAN',
    Breton: 'BRETON',
    Bulgarian: 'BULGARIAN',
    Burmese: 'BURMESE',
    Chewa: 'CHEWA',
    Chhattisgarhi: 'CHHATTISGARHI',
    Chopi: 'CHOPI',
    Croatian: 'CROATIAN',
    Czech: 'CZECH',
    Danish: 'DANISH',
    Dhundhari: 'DHUNDHARI',
    Dutch: 'DUTCH',
    English: 'ENGLISH',
    Estonian: 'ESTONIAN',
    Faroese: 'FAROESE',
    Farsi: 'FARSI',
    Finnish: 'FINNISH',
    French: 'FRENCH',
    Fula: 'FULA',
    Ganda: 'GANDA',
    Georgian: 'GEORGIAN',
    German: 'GERMAN',
    Greek: 'GREEK',
    Greenlandic: 'GREENLANDIC',
    Gujarati: 'GUJARATI',
    HaitianCreole: 'HAITIAN_CREOLE',
    Hausa: 'HAUSA',
    Herero: 'HERERO',
    Hiligaynon: 'HILIGAYNON',
    Hindi: 'HINDI',
    Hmong: 'HMONG',
    Hungarian: 'HUNGARIAN',
    Icelandic: 'ICELANDIC',
    Igbo: 'IGBO',
    Ilocano: 'ILOCANO',
    Indonesian: 'INDONESIAN',
    Irish: 'IRISH',
    Italian: 'ITALIAN',
    Javanese: 'JAVANESE',
    Japanese: 'JAPANESE',
    Kabyle: 'KABYLE',
    Kannada: 'KANNADA',
    Kazakh: 'KAZAKH',
    Kikongo: 'KIKONGO',
    Kinyarwanda: 'KINYARWANDA',
    Kirundi: 'KIRUNDI',
    Konkani: 'KONKANI',
    Korean: 'KOREAN',
    Kurdish: 'KURDISH',
    Latvian: 'LATVIAN',
    Lingala: 'LINGALA',
    Lithuanian: 'LITHUANIAN',
    Luxembourgish: 'LUXEMBOURGISH',
    Macedonian: 'MACEDONIAN',
    Maithili: 'MAITHILI',
    Malay: 'MALAY',
    Malayalam: 'MALAYALAM',
    Maltese: 'MALTESE',
    Mandarin: 'MANDARIN',
    Marathi: 'MARATHI',
    Mongolian: 'MONGOLIAN',
    Mossi: 'MOSSI',
    Nama: 'NAMA',
    Ndebele: 'NDEBELE',
    Nepali: 'NEPALI',
    Norwegian: 'NORWEGIAN',
    Oriya: 'ORIYA',
    Oshiwambo: 'OSHIWAMBO',
    Pashto: 'PASHTO',
    Persian: 'PERSIAN',
    Polish: 'POLISH',
    Portuguese: 'PORTUGUESE',
    Quechua: 'QUECHUA',
    Romanian: 'ROMANIAN',
    Ronga: 'RONGA',
    Russian: 'RUSSIAN',
    Sami: 'SAMI',
    San: 'SAN',
    ScotsGaelic: 'SCOTS_GAELIC',
    Serbian: 'SERBIAN',
    SerboCroatian: 'SERBO_CROATIAN',
    Shona: 'SHONA',
    Sinhala: 'SINHALA',
    Slovak: 'SLOVAK',
    Somali: 'SOMALI',
    Soninke: 'SONINKE',
    Sotho: 'SOTHO',
    SouthernMin: 'SOUTHERN_MIN',
    Spanish: 'SPANISH',
    Sundanese: 'SUNDANESE',
    Swahili: 'SWAHILI',
    Swazi: 'SWAZI',
    Swedish: 'SWEDISH',
    Tamashek: 'TAMASHEK',
    Tamil: 'TAMIL',
    Tatar: 'TATAR',
    Telugu: 'TELUGU',
    Thai: 'THAI',
    Tigrinya: 'TIGRINYA',
    Tswa: 'TSWA',
    Tswana: 'TSWANA',
    Turkish: 'TURKISH',
    Uyghur: 'UYGHUR',
    Urdu: 'URDU',
    Uzbek: 'UZBEK',
    Venda: 'VENDA',
    Vietnamese: 'VIETNAMESE',
    Welsh: 'WELSH',
    Wolof: 'WOLOF',
    Xhosa: 'XHOSA',
    Yoruba: 'YORUBA',
    Yue: 'YUE',
    Zulu: 'ZULU'
} as const;

export type UsersResponseLanguageEnum = typeof UsersResponseLanguageEnum[keyof typeof UsersResponseLanguageEnum];
export const UsersResponseOnboardingStageEnum = {
    Started: 'STARTED',
    OtpVerification: 'OTP_VERIFICATION',
    Completed: 'COMPLETED'
} as const;

export type UsersResponseOnboardingStageEnum = typeof UsersResponseOnboardingStageEnum[keyof typeof UsersResponseOnboardingStageEnum];
export const UsersResponseStatusEnum = {
    Inactive: 'INACTIVE',
    Active: 'ACTIVE',
    Archived: 'ARCHIVED',
    Deleted: 'DELETED'
} as const;

export type UsersResponseStatusEnum = typeof UsersResponseStatusEnum[keyof typeof UsersResponseStatusEnum];
export const UsersResponseTwoFaTypeEnum = {
    Email: 'EMAIL',
    Phone: 'PHONE',
    Whatsapp: 'WHATSAPP',
    AuthenticationApp: 'AUTHENTICATION_APP'
} as const;

export type UsersResponseTwoFaTypeEnum = typeof UsersResponseTwoFaTypeEnum[keyof typeof UsersResponseTwoFaTypeEnum];

/**
 * HR email validation payload
 * @export
 * @interface ValidateHrEmailRequest
 */
export interface ValidateHrEmailRequest {
    /**
     * 
     * @type {string}
     * @memberof ValidateHrEmailRequest
     */
    'hrEmail': string;
    /**
     * 
     * @type {string}
     * @memberof ValidateHrEmailRequest
     */
    'employerWebsite': string;
}
/**
 * 
 * @export
 * @interface ValidateHrEmailResponse
 */
export interface ValidateHrEmailResponse {
    /**
     * 
     * @type {boolean}
     * @memberof ValidateHrEmailResponse
     */
    'isHrEmailValid'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof ValidateHrEmailResponse
     */
    'message'?: string;
}
/**
 * Verify OTP payload
 * @export
 * @interface VerifyOTPRequest
 */
export interface VerifyOTPRequest {
    /**
     * 
     * @type {string}
     * @memberof VerifyOTPRequest
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof VerifyOTPRequest
     */
    'otp': string;
}
/**
 * 
 * @export
 * @interface WalletResponse
 */
export interface WalletResponse {
    /**
     * 
     * @type {string}
     * @memberof WalletResponse
     */
    'walletId'?: string;
    /**
     * 
     * @type {string}
     * @memberof WalletResponse
     */
    'accountNumber'?: string;
    /**
     * 
     * @type {string}
     * @memberof WalletResponse
     */
    'accountName'?: string;
    /**
     * 
     * @type {string}
     * @memberof WalletResponse
     */
    'accountType'?: string;
    /**
     * 
     * @type {string}
     * @memberof WalletResponse
     */
    'bankName'?: string;
    /**
     * 
     * @type {string}
     * @memberof WalletResponse
     */
    'bankCode'?: string;
    /**
     * 
     * @type {string}
     * @memberof WalletResponse
     */
    'currency'?: WalletResponseCurrencyEnum;
    /**
     * 
     * @type {number}
     * @memberof WalletResponse
     */
    'ledgerBalance'?: number;
    /**
     * 
     * @type {number}
     * @memberof WalletResponse
     */
    'availableBalance'?: number;
    /**
     * 
     * @type {number}
     * @memberof WalletResponse
     */
    'totalBalance'?: number;
    /**
     * 
     * @type {string}
     * @memberof WalletResponse
     */
    'walletStatus'?: WalletResponseWalletStatusEnum;
    /**
     * 
     * @type {boolean}
     * @memberof WalletResponse
     */
    'active'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof WalletResponse
     */
    'createdDate'?: string;
    /**
     * 
     * @type {string}
     * @memberof WalletResponse
     */
    'lastModifiedDate'?: string;
}

export const WalletResponseCurrencyEnum = {
    Afghani: 'AFGHANI',
    AlgerianDinar: 'ALGERIAN_DINAR',
    AngolanKwanza: 'ANGOLAN_KWANZA',
    ArgentinePeso: 'ARGENTINE_PESO',
    AustralianDollar: 'AUSTRALIAN_DOLLAR',
    BahrainiDinar: 'BAHRAINI_DINAR',
    BangladeshiTaka: 'BANGLADESHI_TAKA',
    Bitcoin: 'BITCOIN',
    BrazilianReal: 'BRAZILIAN_REAL',
    BruneiDollar: 'BRUNEI_DOLLAR',
    BulgarianLev: 'BULGARIAN_LEV',
    BurundianFranc: 'BURUNDIAN_FRANC',
    CanadianDollar: 'CANADIAN_DOLLAR',
    CfaFrancBeac: 'CFA_FRANC_BEAC',
    CfaFrancBceao: 'CFA_FRANC_BCEAO',
    ChileanPeso: 'CHILEAN_PESO',
    ChineseYuan: 'CHINESE_YUAN',
    ColombianPeso: 'COLOMBIAN_PESO',
    CongoleseFranc: 'CONGOLESE_FRANC',
    CzechKoruna: 'CZECH_KORUNA',
    DanishKrone: 'DANISH_KRONE',
    DominicanPeso: 'DOMINICAN_PESO',
    EgyptianPound: 'EGYPTIAN_POUND',
    EthiopianBirr: 'ETHIOPIAN_BIRR',
    Euro: 'EURO',
    FijianDollar: 'FIJIAN_DOLLAR',
    GhanaianCedi: 'GHANAIAN_CEDI',
    GuineanFranc: 'GUINEAN_FRANC',
    HongKongDollar: 'HONG_KONG_DOLLAR',
    HungarianForint: 'HUNGARIAN_FORINT',
    IcelandicKrona: 'ICELANDIC_KRONA',
    IndianRupee: 'INDIAN_RUPEE',
    IndonesianRupiah: 'INDONESIAN_RUPIAH',
    IranianRial: 'IRANIAN_RIAL',
    IraqiDinar: 'IRAQI_DINAR',
    IsraeliShekel: 'ISRAELI_SHEKEL',
    JamaicanDollar: 'JAMAICAN_DOLLAR',
    JapaneseYen: 'JAPANESE_YEN',
    JordanianDinar: 'JORDANIAN_DINAR',
    KazakhstaniTenge: 'KAZAKHSTANI_TENGE',
    KenyanShilling: 'KENYAN_SHILLING',
    KuwaitiDinar: 'KUWAITI_DINAR',
    LaosKip: 'LAOS_KIp',
    LebanesePound: 'LEBANESE_POUND',
    LibyanDinar: 'LIBYAN_DINAR',
    MalagasyAriary: 'MALAGASY_ARIARY',
    MalawianKwacha: 'MALAWIAN_KWACHA',
    MalaysianRinggit: 'MALAYSIAN_RINGGIT',
    MauritianRupee: 'MAURITIAN_RUPEE',
    MexicanPeso: 'MEXICAN_PESO',
    MoroccanDirham: 'MOROCCAN_DIRHAM',
    MozambicanMetical: 'MOZAMBICAN_METICAL',
    NamibianDollar: 'NAMIBIAN_DOLLAR',
    Naira: 'NAIRA',
    NepaleseRupee: 'NEPALESE_RUPEE',
    NewZealandDollar: 'NEW_ZEALAND_DOLLAR',
    NorwegianKrone: 'NORWEGIAN_KRONE',
    OmaniRial: 'OMANI_RIAL',
    PakistaniRupee: 'PAKISTANI_RUPEE',
    PhilippinePeso: 'PHILIPPINE_PESO',
    PolishZloty: 'POLISH_ZLOTY',
    QatariRiyal: 'QATARI_RIYAL',
    RomanianLeu: 'ROMANIAN_LEU',
    RussianRuble: 'RUSSIAN_RUBLE',
    RwandanFranc: 'RWANDAN_FRANC',
    SaudiRiyal: 'SAUDI_RIYAL',
    SerbianDinar: 'SERBIAN_DINAR',
    SeychellesRupee: 'SEYCHELLES_RUPEE',
    SingaporeDollar: 'SINGAPORE_DOLLAR',
    SomaliShilling: 'SOMALI_SHILLING',
    SouthAfricanRand: 'SOUTH_AFRICAN_RAND',
    SouthKoreanWon: 'SOUTH_KOREAN_WON',
    SouthSudanesePound: 'SOUTH_SUDANESE_POUND',
    SriLankanRupee: 'SRI_LANKAN_RUPEE',
    SwedishKrona: 'SWEDISH_KRONA',
    SwissFranc: 'SWISS_FRANC',
    SyrianPound: 'SYRIAN_POUND',
    TaiwanDollar: 'TAIWAN_DOLLAR',
    TanzanianShilling: 'TANZANIAN_SHILLING',
    ThaiBaht: 'THAI_BAHT',
    TunisianDinar: 'TUNISIAN_DINAR',
    TurkishLira: 'TURKISH_LIRA',
    UgandanShilling: 'UGANDAN_SHILLING',
    UkrainianHryvnia: 'UKRAINIAN_HRYVNIA',
    UaeDirham: 'UAE_DIRHAM',
    UkPound: 'UK_POUND',
    UsDollar: 'US_DOLLAR',
    UruguayanPeso: 'URUGUAYAN_PESO',
    UzbekistaniSom: 'UZBEKISTANI_SOM',
    VenezuelanBolivar: 'VENEZUELAN_BOLIVAR',
    VietnameseDong: 'VIETNAMESE_DONG',
    YemeniRial: 'YEMENI_RIAL',
    ZambianKwacha: 'ZAMBIAN_KWACHA',
    ZimbabweanDollar: 'ZIMBABWEAN_DOLLAR'
} as const;

export type WalletResponseCurrencyEnum = typeof WalletResponseCurrencyEnum[keyof typeof WalletResponseCurrencyEnum];
export const WalletResponseWalletStatusEnum = {
    Pending: 'PENDING',
    Open: 'OPEN',
    Locked: 'LOCKED',
    Frozen: 'FROZEN'
} as const;

export type WalletResponseWalletStatusEnum = typeof WalletResponseWalletStatusEnum[keyof typeof WalletResponseWalletStatusEnum];

/**
 * Transfer payload
 * @export
 * @interface WalletToBankTransfer
 */
export interface WalletToBankTransfer {
    /**
     * 
     * @type {string}
     * @memberof WalletToBankTransfer
     */
    'transactionPin': string;
    /**
     * 
     * @type {string}
     * @memberof WalletToBankTransfer
     */
    'nameEnquirySessionId': string;
    /**
     * 
     * @type {number}
     * @memberof WalletToBankTransfer
     */
    'amount': number;
    /**
     * 
     * @type {string}
     * @memberof WalletToBankTransfer
     */
    'recipientBankName': string;
    /**
     * 
     * @type {string}
     * @memberof WalletToBankTransfer
     */
    'recipientAccountName': string;
    /**
     * 
     * @type {string}
     * @memberof WalletToBankTransfer
     */
    'recipientBankCode': string;
    /**
     * 
     * @type {string}
     * @memberof WalletToBankTransfer
     */
    'recipientAccountNumber': string;
    /**
     * 
     * @type {string}
     * @memberof WalletToBankTransfer
     */
    'category'?: string;
    /**
     * 
     * @type {string}
     * @memberof WalletToBankTransfer
     */
    'narration'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof WalletToBankTransfer
     */
    'saveBeneficiary'?: boolean;
}

/**
 * AccountNumberResourceApi - axios parameter creator
 * @export
 */
export const AccountNumberResourceApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Resource to complete account creation
         * @summary Complete account creation
         * @param {CompleteVirtualAccountCreation} completeVirtualAccountCreation 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        completeRubiesVirtualAccountCreation: async (completeVirtualAccountCreation: CompleteVirtualAccountCreation, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'completeVirtualAccountCreation' is not null or undefined
            assertParamExists('completeRubiesVirtualAccountCreation', 'completeVirtualAccountCreation', completeVirtualAccountCreation)
            const localVarPath = `/api/v1/account/create-account/complete`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(completeVirtualAccountCreation, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Resource to initiate account creation
         * @summary Initiate account creation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        initiateRubiesVirtualAccountCreation: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/account/create-account/initiate`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Resource to resend OTP for account creation
         * @summary Resend OTP for account creation
         * @param {ResendOtpForVirtualAccountCreation} resendOtpForVirtualAccountCreation 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resendOtpForRubiesVirtualAccountCreation: async (resendOtpForVirtualAccountCreation: ResendOtpForVirtualAccountCreation, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'resendOtpForVirtualAccountCreation' is not null or undefined
            assertParamExists('resendOtpForRubiesVirtualAccountCreation', 'resendOtpForVirtualAccountCreation', resendOtpForVirtualAccountCreation)
            const localVarPath = `/api/v1/account/create-account/resend-otp`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(resendOtpForVirtualAccountCreation, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AccountNumberResourceApi - functional programming interface
 * @export
 */
export const AccountNumberResourceApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AccountNumberResourceApiAxiosParamCreator(configuration)
    return {
        /**
         * Resource to complete account creation
         * @summary Complete account creation
         * @param {CompleteVirtualAccountCreation} completeVirtualAccountCreation 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async completeRubiesVirtualAccountCreation(completeVirtualAccountCreation: CompleteVirtualAccountCreation, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.completeRubiesVirtualAccountCreation(completeVirtualAccountCreation, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AccountNumberResourceApi.completeRubiesVirtualAccountCreation']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Resource to initiate account creation
         * @summary Initiate account creation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async initiateRubiesVirtualAccountCreation(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.initiateRubiesVirtualAccountCreation(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AccountNumberResourceApi.initiateRubiesVirtualAccountCreation']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Resource to resend OTP for account creation
         * @summary Resend OTP for account creation
         * @param {ResendOtpForVirtualAccountCreation} resendOtpForVirtualAccountCreation 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async resendOtpForRubiesVirtualAccountCreation(resendOtpForVirtualAccountCreation: ResendOtpForVirtualAccountCreation, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.resendOtpForRubiesVirtualAccountCreation(resendOtpForVirtualAccountCreation, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AccountNumberResourceApi.resendOtpForRubiesVirtualAccountCreation']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AccountNumberResourceApi - factory interface
 * @export
 */
export const AccountNumberResourceApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AccountNumberResourceApiFp(configuration)
    return {
        /**
         * Resource to complete account creation
         * @summary Complete account creation
         * @param {CompleteVirtualAccountCreation} completeVirtualAccountCreation 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        completeRubiesVirtualAccountCreation(completeVirtualAccountCreation: CompleteVirtualAccountCreation, options?: RawAxiosRequestConfig): AxiosPromise<ApiResponseDto> {
            return localVarFp.completeRubiesVirtualAccountCreation(completeVirtualAccountCreation, options).then((request) => request(axios, basePath));
        },
        /**
         * Resource to initiate account creation
         * @summary Initiate account creation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        initiateRubiesVirtualAccountCreation(options?: RawAxiosRequestConfig): AxiosPromise<ApiResponseDto> {
            return localVarFp.initiateRubiesVirtualAccountCreation(options).then((request) => request(axios, basePath));
        },
        /**
         * Resource to resend OTP for account creation
         * @summary Resend OTP for account creation
         * @param {ResendOtpForVirtualAccountCreation} resendOtpForVirtualAccountCreation 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resendOtpForRubiesVirtualAccountCreation(resendOtpForVirtualAccountCreation: ResendOtpForVirtualAccountCreation, options?: RawAxiosRequestConfig): AxiosPromise<ApiResponseDto> {
            return localVarFp.resendOtpForRubiesVirtualAccountCreation(resendOtpForVirtualAccountCreation, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AccountNumberResourceApi - object-oriented interface
 * @export
 * @class AccountNumberResourceApi
 * @extends {BaseAPI}
 */
export class AccountNumberResourceApi extends BaseAPI {
    /**
     * Resource to complete account creation
     * @summary Complete account creation
     * @param {CompleteVirtualAccountCreation} completeVirtualAccountCreation 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountNumberResourceApi
     */
    public completeRubiesVirtualAccountCreation(completeVirtualAccountCreation: CompleteVirtualAccountCreation, options?: RawAxiosRequestConfig) {
        return AccountNumberResourceApiFp(this.configuration).completeRubiesVirtualAccountCreation(completeVirtualAccountCreation, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Resource to initiate account creation
     * @summary Initiate account creation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountNumberResourceApi
     */
    public initiateRubiesVirtualAccountCreation(options?: RawAxiosRequestConfig) {
        return AccountNumberResourceApiFp(this.configuration).initiateRubiesVirtualAccountCreation(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Resource to resend OTP for account creation
     * @summary Resend OTP for account creation
     * @param {ResendOtpForVirtualAccountCreation} resendOtpForVirtualAccountCreation 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountNumberResourceApi
     */
    public resendOtpForRubiesVirtualAccountCreation(resendOtpForVirtualAccountCreation: ResendOtpForVirtualAccountCreation, options?: RawAxiosRequestConfig) {
        return AccountNumberResourceApiFp(this.configuration).resendOtpForRubiesVirtualAccountCreation(resendOtpForVirtualAccountCreation, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * AdminResourceApi - axios parameter creator
 * @export
 */
export const AdminResourceApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Resource to retrieve all users
         * @summary Retrieve all users
         * @param {number} page Page
         * @param {number} size Size
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveAllUsers: async (page: number, size: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'page' is not null or undefined
            assertParamExists('retrieveAllUsers', 'page', page)
            // verify required parameter 'size' is not null or undefined
            assertParamExists('retrieveAllUsers', 'size', size)
            const localVarPath = `/api/v1/admin/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Resource to retrieve user by id
         * @summary Retrieve user by id
         * @param {string} userId ID of the user to retrieve
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveUserById1: async (userId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('retrieveUserById1', 'userId', userId)
            const localVarPath = `/api/v1/admin/user`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AdminResourceApi - functional programming interface
 * @export
 */
export const AdminResourceApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AdminResourceApiAxiosParamCreator(configuration)
    return {
        /**
         * Resource to retrieve all users
         * @summary Retrieve all users
         * @param {number} page Page
         * @param {number} size Size
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieveAllUsers(page: number, size: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiResponseDtoListUsersResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrieveAllUsers(page, size, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminResourceApi.retrieveAllUsers']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Resource to retrieve user by id
         * @summary Retrieve user by id
         * @param {string} userId ID of the user to retrieve
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieveUserById1(userId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiResponseDtoUsersResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrieveUserById1(userId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminResourceApi.retrieveUserById1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AdminResourceApi - factory interface
 * @export
 */
export const AdminResourceApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AdminResourceApiFp(configuration)
    return {
        /**
         * Resource to retrieve all users
         * @summary Retrieve all users
         * @param {number} page Page
         * @param {number} size Size
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveAllUsers(page: number, size: number, options?: RawAxiosRequestConfig): AxiosPromise<ApiResponseDtoListUsersResponse> {
            return localVarFp.retrieveAllUsers(page, size, options).then((request) => request(axios, basePath));
        },
        /**
         * Resource to retrieve user by id
         * @summary Retrieve user by id
         * @param {string} userId ID of the user to retrieve
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveUserById1(userId: string, options?: RawAxiosRequestConfig): AxiosPromise<ApiResponseDtoUsersResponse> {
            return localVarFp.retrieveUserById1(userId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AdminResourceApi - object-oriented interface
 * @export
 * @class AdminResourceApi
 * @extends {BaseAPI}
 */
export class AdminResourceApi extends BaseAPI {
    /**
     * Resource to retrieve all users
     * @summary Retrieve all users
     * @param {number} page Page
     * @param {number} size Size
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminResourceApi
     */
    public retrieveAllUsers(page: number, size: number, options?: RawAxiosRequestConfig) {
        return AdminResourceApiFp(this.configuration).retrieveAllUsers(page, size, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Resource to retrieve user by id
     * @summary Retrieve user by id
     * @param {string} userId ID of the user to retrieve
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminResourceApi
     */
    public retrieveUserById1(userId: string, options?: RawAxiosRequestConfig) {
        return AdminResourceApiFp(this.configuration).retrieveUserById1(userId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * CallbackResourceApi - axios parameter creator
 * @export
 */
export const CallbackResourceApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Resource for Safe Haven customer redirect URL
         * @summary Safe Haven customer redirect URL
         * @param {string} privateKey Callback private key
         * @param {string} userToken Callback user token
         * @param {string} channel Callback channel
         * @param {SafeHavenTransferCallback} safeHavenTransferCallback 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        safeHavenCustomerRedirectUrl: async (privateKey: string, userToken: string, channel: string, safeHavenTransferCallback: SafeHavenTransferCallback, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'privateKey' is not null or undefined
            assertParamExists('safeHavenCustomerRedirectUrl', 'privateKey', privateKey)
            // verify required parameter 'userToken' is not null or undefined
            assertParamExists('safeHavenCustomerRedirectUrl', 'userToken', userToken)
            // verify required parameter 'channel' is not null or undefined
            assertParamExists('safeHavenCustomerRedirectUrl', 'channel', channel)
            // verify required parameter 'safeHavenTransferCallback' is not null or undefined
            assertParamExists('safeHavenCustomerRedirectUrl', 'safeHavenTransferCallback', safeHavenTransferCallback)
            const localVarPath = `/api/v1/callback/safe-haven/customer`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (privateKey !== undefined) {
                localVarQueryParameter['privateKey'] = privateKey;
            }

            if (userToken !== undefined) {
                localVarQueryParameter['userToken'] = userToken;
            }

            if (channel !== undefined) {
                localVarQueryParameter['channel'] = channel;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(safeHavenTransferCallback, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Resource for Safe Haven bank transfer callback
         * @summary Safe Haven bank transfer callback
         * @param {string} privateKey Callback private key
         * @param {string} userToken Callback user token
         * @param {string} channel Callback channel
         * @param {SafeHavenTransferCallback} safeHavenTransferCallback 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        safeHavenTransferCallback: async (privateKey: string, userToken: string, channel: string, safeHavenTransferCallback: SafeHavenTransferCallback, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'privateKey' is not null or undefined
            assertParamExists('safeHavenTransferCallback', 'privateKey', privateKey)
            // verify required parameter 'userToken' is not null or undefined
            assertParamExists('safeHavenTransferCallback', 'userToken', userToken)
            // verify required parameter 'channel' is not null or undefined
            assertParamExists('safeHavenTransferCallback', 'channel', channel)
            // verify required parameter 'safeHavenTransferCallback' is not null or undefined
            assertParamExists('safeHavenTransferCallback', 'safeHavenTransferCallback', safeHavenTransferCallback)
            const localVarPath = `/api/v1/callback/safe-haven/transfer`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (privateKey !== undefined) {
                localVarQueryParameter['privateKey'] = privateKey;
            }

            if (userToken !== undefined) {
                localVarQueryParameter['userToken'] = userToken;
            }

            if (channel !== undefined) {
                localVarQueryParameter['channel'] = channel;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(safeHavenTransferCallback, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CallbackResourceApi - functional programming interface
 * @export
 */
export const CallbackResourceApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CallbackResourceApiAxiosParamCreator(configuration)
    return {
        /**
         * Resource for Safe Haven customer redirect URL
         * @summary Safe Haven customer redirect URL
         * @param {string} privateKey Callback private key
         * @param {string} userToken Callback user token
         * @param {string} channel Callback channel
         * @param {SafeHavenTransferCallback} safeHavenTransferCallback 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async safeHavenCustomerRedirectUrl(privateKey: string, userToken: string, channel: string, safeHavenTransferCallback: SafeHavenTransferCallback, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.safeHavenCustomerRedirectUrl(privateKey, userToken, channel, safeHavenTransferCallback, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CallbackResourceApi.safeHavenCustomerRedirectUrl']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Resource for Safe Haven bank transfer callback
         * @summary Safe Haven bank transfer callback
         * @param {string} privateKey Callback private key
         * @param {string} userToken Callback user token
         * @param {string} channel Callback channel
         * @param {SafeHavenTransferCallback} safeHavenTransferCallback 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async safeHavenTransferCallback(privateKey: string, userToken: string, channel: string, safeHavenTransferCallback: SafeHavenTransferCallback, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.safeHavenTransferCallback(privateKey, userToken, channel, safeHavenTransferCallback, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CallbackResourceApi.safeHavenTransferCallback']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * CallbackResourceApi - factory interface
 * @export
 */
export const CallbackResourceApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CallbackResourceApiFp(configuration)
    return {
        /**
         * Resource for Safe Haven customer redirect URL
         * @summary Safe Haven customer redirect URL
         * @param {string} privateKey Callback private key
         * @param {string} userToken Callback user token
         * @param {string} channel Callback channel
         * @param {SafeHavenTransferCallback} safeHavenTransferCallback 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        safeHavenCustomerRedirectUrl(privateKey: string, userToken: string, channel: string, safeHavenTransferCallback: SafeHavenTransferCallback, options?: RawAxiosRequestConfig): AxiosPromise<ApiResponseDto> {
            return localVarFp.safeHavenCustomerRedirectUrl(privateKey, userToken, channel, safeHavenTransferCallback, options).then((request) => request(axios, basePath));
        },
        /**
         * Resource for Safe Haven bank transfer callback
         * @summary Safe Haven bank transfer callback
         * @param {string} privateKey Callback private key
         * @param {string} userToken Callback user token
         * @param {string} channel Callback channel
         * @param {SafeHavenTransferCallback} safeHavenTransferCallback 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        safeHavenTransferCallback(privateKey: string, userToken: string, channel: string, safeHavenTransferCallback: SafeHavenTransferCallback, options?: RawAxiosRequestConfig): AxiosPromise<ApiResponseDto> {
            return localVarFp.safeHavenTransferCallback(privateKey, userToken, channel, safeHavenTransferCallback, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CallbackResourceApi - object-oriented interface
 * @export
 * @class CallbackResourceApi
 * @extends {BaseAPI}
 */
export class CallbackResourceApi extends BaseAPI {
    /**
     * Resource for Safe Haven customer redirect URL
     * @summary Safe Haven customer redirect URL
     * @param {string} privateKey Callback private key
     * @param {string} userToken Callback user token
     * @param {string} channel Callback channel
     * @param {SafeHavenTransferCallback} safeHavenTransferCallback 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CallbackResourceApi
     */
    public safeHavenCustomerRedirectUrl(privateKey: string, userToken: string, channel: string, safeHavenTransferCallback: SafeHavenTransferCallback, options?: RawAxiosRequestConfig) {
        return CallbackResourceApiFp(this.configuration).safeHavenCustomerRedirectUrl(privateKey, userToken, channel, safeHavenTransferCallback, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Resource for Safe Haven bank transfer callback
     * @summary Safe Haven bank transfer callback
     * @param {string} privateKey Callback private key
     * @param {string} userToken Callback user token
     * @param {string} channel Callback channel
     * @param {SafeHavenTransferCallback} safeHavenTransferCallback 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CallbackResourceApi
     */
    public safeHavenTransferCallback(privateKey: string, userToken: string, channel: string, safeHavenTransferCallback: SafeHavenTransferCallback, options?: RawAxiosRequestConfig) {
        return CallbackResourceApiFp(this.configuration).safeHavenTransferCallback(privateKey, userToken, channel, safeHavenTransferCallback, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * DailypayResourceApi - axios parameter creator
 * @export
 */
export const DailypayResourceApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Resource to activate DailyPay
         * @summary Activate DailyPay
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        activateDailyPay: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/dailypay/activate`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Resource to Add DailyPay job profile - step 1
         * @summary Add DailyPay job profile - step 1
         * @param {DailyPayJobStep1} dailyPayJobStep1 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addJobProfile: async (dailyPayJobStep1: DailyPayJobStep1, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'dailyPayJobStep1' is not null or undefined
            assertParamExists('addJobProfile', 'dailyPayJobStep1', dailyPayJobStep1)
            const localVarPath = `/api/v1/dailypay/job-setup/step1/add-job-profile`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(dailyPayJobStep1, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Resource to approve salary mandate request
         * @summary Approve salary mandate request
         * @param {DailyPayJobStep4ApproveMandate} dailyPayJobStep4ApproveMandate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        approveMandateRequest: async (dailyPayJobStep4ApproveMandate: DailyPayJobStep4ApproveMandate, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'dailyPayJobStep4ApproveMandate' is not null or undefined
            assertParamExists('approveMandateRequest', 'dailyPayJobStep4ApproveMandate', dailyPayJobStep4ApproveMandate)
            const localVarPath = `/api/v1/dailypay/job-setup/step4/approve-mandate`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(dailyPayJobStep4ApproveMandate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Resource to claim DailyPay money credited to DailyPay wallet
         * @summary Claim DailyPay money credited to DailyPay wallet
         * @param {ClaimDailyPay} claimDailyPay 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        claimDailyPay: async (claimDailyPay: ClaimDailyPay, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'claimDailyPay' is not null or undefined
            assertParamExists('claimDailyPay', 'claimDailyPay', claimDailyPay)
            const localVarPath = `/api/v1/dailypay/claim`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(claimDailyPay, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Resource to deactivate DailyPay
         * @summary Deactivate DailyPay
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deactivateDailyPay: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/dailypay/deactivate`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Resource to decline salary mandate request
         * @summary Decline salary mandate request
         * @param {DailyPayJobStep4DeclineMandate} dailyPayJobStep4DeclineMandate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        declineMandateRequest: async (dailyPayJobStep4DeclineMandate: DailyPayJobStep4DeclineMandate, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'dailyPayJobStep4DeclineMandate' is not null or undefined
            assertParamExists('declineMandateRequest', 'dailyPayJobStep4DeclineMandate', dailyPayJobStep4DeclineMandate)
            const localVarPath = `/api/v1/dailypay/job-setup/step4/decline-mandate`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(dailyPayJobStep4DeclineMandate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Resource to retrieve linked job details
         * @summary Retrieve linked job details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getJobDetails: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/dailypay/job-details`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Resource to link salary account with Mono
         * @summary Link salary account with Mono
         * @param {DailyPayJobStep2} dailyPayJobStep2 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        linkJobSalaryAccount: async (dailyPayJobStep2: DailyPayJobStep2, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'dailyPayJobStep2' is not null or undefined
            assertParamExists('linkJobSalaryAccount', 'dailyPayJobStep2', dailyPayJobStep2)
            const localVarPath = `/api/v1/dailypay/job-setup/step2/link-salary-account`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(dailyPayJobStep2, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Resource to resend mandate review request email
         * @summary Resend mandate review request email
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resendMandateEmailToHr: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/dailypay/job-setup/step3/resend-mandate-email`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Resource to retrieve user DailyPay wallet information
         * @summary Retrieve user DailyPay wallet information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveDailyPayWalletInfo: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/dailypay/wallet`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Resource to send mandate review request to HR - step 3
         * @summary Send mandate review request to HR - step 3
         * @param {DailyPayJobStep3} dailyPayJobStep3 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendMandateReviewRequestToHr: async (dailyPayJobStep3: DailyPayJobStep3, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'dailyPayJobStep3' is not null or undefined
            assertParamExists('sendMandateReviewRequestToHr', 'dailyPayJobStep3', dailyPayJobStep3)
            const localVarPath = `/api/v1/dailypay/job-setup/step3/mandate-review-request`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(dailyPayJobStep3, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Resource to unlink salary account from Mono
         * @summary Unlink salary account from Mono
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unlinkJobSalaryAccount: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/dailypay/job-setup/step2/unlink-salary-account`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Resource to update DailyPay job profile - step 1
         * @summary Update DailyPay job profile - step 1
         * @param {DailyPayJobStep1} dailyPayJobStep1 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateJobProfile: async (dailyPayJobStep1: DailyPayJobStep1, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'dailyPayJobStep1' is not null or undefined
            assertParamExists('updateJobProfile', 'dailyPayJobStep1', dailyPayJobStep1)
            const localVarPath = `/api/v1/dailypay/job-setup/step1/update-job-profile`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(dailyPayJobStep1, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Resource to upload salary account 6 months bank statement
         * @summary Upload salary account 6 months bank statement
         * @param {string} bankName Salary bank name
         * @param {string} accountName Salary account name
         * @param {string} accountNumber Salary account number
         * @param {File} file Bank statement PDF file
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadBankStatementOfJobSalaryAccount: async (bankName: string, accountName: string, accountNumber: string, file: File, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'bankName' is not null or undefined
            assertParamExists('uploadBankStatementOfJobSalaryAccount', 'bankName', bankName)
            // verify required parameter 'accountName' is not null or undefined
            assertParamExists('uploadBankStatementOfJobSalaryAccount', 'accountName', accountName)
            // verify required parameter 'accountNumber' is not null or undefined
            assertParamExists('uploadBankStatementOfJobSalaryAccount', 'accountNumber', accountNumber)
            // verify required parameter 'file' is not null or undefined
            assertParamExists('uploadBankStatementOfJobSalaryAccount', 'file', file)
            const localVarPath = `/api/v1/dailypay/job-setup/step2/upload-bank-statement`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            if (bankName !== undefined) {
                localVarQueryParameter['bankName'] = bankName;
            }

            if (accountName !== undefined) {
                localVarQueryParameter['accountName'] = accountName;
            }

            if (accountNumber !== undefined) {
                localVarQueryParameter['accountNumber'] = accountNumber;
            }


            if (file !== undefined) { 
                localVarFormParams.append('file', file as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Resource to validate HR email
         * @summary Validate HR email
         * @param {ValidateHrEmailRequest} validateHrEmailRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        validateHrEmail: async (validateHrEmailRequest: ValidateHrEmailRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'validateHrEmailRequest' is not null or undefined
            assertParamExists('validateHrEmail', 'validateHrEmailRequest', validateHrEmailRequest)
            const localVarPath = `/api/v1/dailypay/job-setup/step3/validate-hr-email`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(validateHrEmailRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DailypayResourceApi - functional programming interface
 * @export
 */
export const DailypayResourceApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DailypayResourceApiAxiosParamCreator(configuration)
    return {
        /**
         * Resource to activate DailyPay
         * @summary Activate DailyPay
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async activateDailyPay(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiResponseDtoWalletResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.activateDailyPay(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DailypayResourceApi.activateDailyPay']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Resource to Add DailyPay job profile - step 1
         * @summary Add DailyPay job profile - step 1
         * @param {DailyPayJobStep1} dailyPayJobStep1 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addJobProfile(dailyPayJobStep1: DailyPayJobStep1, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiResponseDtoJobResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addJobProfile(dailyPayJobStep1, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DailypayResourceApi.addJobProfile']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Resource to approve salary mandate request
         * @summary Approve salary mandate request
         * @param {DailyPayJobStep4ApproveMandate} dailyPayJobStep4ApproveMandate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async approveMandateRequest(dailyPayJobStep4ApproveMandate: DailyPayJobStep4ApproveMandate, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.approveMandateRequest(dailyPayJobStep4ApproveMandate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DailypayResourceApi.approveMandateRequest']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Resource to claim DailyPay money credited to DailyPay wallet
         * @summary Claim DailyPay money credited to DailyPay wallet
         * @param {ClaimDailyPay} claimDailyPay 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async claimDailyPay(claimDailyPay: ClaimDailyPay, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.claimDailyPay(claimDailyPay, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DailypayResourceApi.claimDailyPay']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Resource to deactivate DailyPay
         * @summary Deactivate DailyPay
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deactivateDailyPay(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deactivateDailyPay(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DailypayResourceApi.deactivateDailyPay']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Resource to decline salary mandate request
         * @summary Decline salary mandate request
         * @param {DailyPayJobStep4DeclineMandate} dailyPayJobStep4DeclineMandate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async declineMandateRequest(dailyPayJobStep4DeclineMandate: DailyPayJobStep4DeclineMandate, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.declineMandateRequest(dailyPayJobStep4DeclineMandate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DailypayResourceApi.declineMandateRequest']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Resource to retrieve linked job details
         * @summary Retrieve linked job details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getJobDetails(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiResponseDtoJobResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getJobDetails(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DailypayResourceApi.getJobDetails']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Resource to link salary account with Mono
         * @summary Link salary account with Mono
         * @param {DailyPayJobStep2} dailyPayJobStep2 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async linkJobSalaryAccount(dailyPayJobStep2: DailyPayJobStep2, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiResponseDtoJobResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.linkJobSalaryAccount(dailyPayJobStep2, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DailypayResourceApi.linkJobSalaryAccount']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Resource to resend mandate review request email
         * @summary Resend mandate review request email
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async resendMandateEmailToHr(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiResponseDtoJobResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.resendMandateEmailToHr(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DailypayResourceApi.resendMandateEmailToHr']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Resource to retrieve user DailyPay wallet information
         * @summary Retrieve user DailyPay wallet information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieveDailyPayWalletInfo(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiResponseDtoWalletResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrieveDailyPayWalletInfo(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DailypayResourceApi.retrieveDailyPayWalletInfo']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Resource to send mandate review request to HR - step 3
         * @summary Send mandate review request to HR - step 3
         * @param {DailyPayJobStep3} dailyPayJobStep3 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sendMandateReviewRequestToHr(dailyPayJobStep3: DailyPayJobStep3, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiResponseDtoJobResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.sendMandateReviewRequestToHr(dailyPayJobStep3, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DailypayResourceApi.sendMandateReviewRequestToHr']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Resource to unlink salary account from Mono
         * @summary Unlink salary account from Mono
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async unlinkJobSalaryAccount(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.unlinkJobSalaryAccount(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DailypayResourceApi.unlinkJobSalaryAccount']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Resource to update DailyPay job profile - step 1
         * @summary Update DailyPay job profile - step 1
         * @param {DailyPayJobStep1} dailyPayJobStep1 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateJobProfile(dailyPayJobStep1: DailyPayJobStep1, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiResponseDtoJobResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateJobProfile(dailyPayJobStep1, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DailypayResourceApi.updateJobProfile']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Resource to upload salary account 6 months bank statement
         * @summary Upload salary account 6 months bank statement
         * @param {string} bankName Salary bank name
         * @param {string} accountName Salary account name
         * @param {string} accountNumber Salary account number
         * @param {File} file Bank statement PDF file
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async uploadBankStatementOfJobSalaryAccount(bankName: string, accountName: string, accountNumber: string, file: File, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiResponseDtoJobResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.uploadBankStatementOfJobSalaryAccount(bankName, accountName, accountNumber, file, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DailypayResourceApi.uploadBankStatementOfJobSalaryAccount']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Resource to validate HR email
         * @summary Validate HR email
         * @param {ValidateHrEmailRequest} validateHrEmailRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async validateHrEmail(validateHrEmailRequest: ValidateHrEmailRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiResponseDtoValidateHrEmailResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.validateHrEmail(validateHrEmailRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DailypayResourceApi.validateHrEmail']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * DailypayResourceApi - factory interface
 * @export
 */
export const DailypayResourceApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DailypayResourceApiFp(configuration)
    return {
        /**
         * Resource to activate DailyPay
         * @summary Activate DailyPay
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        activateDailyPay(options?: RawAxiosRequestConfig): AxiosPromise<ApiResponseDtoWalletResponse> {
            return localVarFp.activateDailyPay(options).then((request) => request(axios, basePath));
        },
        /**
         * Resource to Add DailyPay job profile - step 1
         * @summary Add DailyPay job profile - step 1
         * @param {DailyPayJobStep1} dailyPayJobStep1 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addJobProfile(dailyPayJobStep1: DailyPayJobStep1, options?: RawAxiosRequestConfig): AxiosPromise<ApiResponseDtoJobResponse> {
            return localVarFp.addJobProfile(dailyPayJobStep1, options).then((request) => request(axios, basePath));
        },
        /**
         * Resource to approve salary mandate request
         * @summary Approve salary mandate request
         * @param {DailyPayJobStep4ApproveMandate} dailyPayJobStep4ApproveMandate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        approveMandateRequest(dailyPayJobStep4ApproveMandate: DailyPayJobStep4ApproveMandate, options?: RawAxiosRequestConfig): AxiosPromise<ApiResponseDto> {
            return localVarFp.approveMandateRequest(dailyPayJobStep4ApproveMandate, options).then((request) => request(axios, basePath));
        },
        /**
         * Resource to claim DailyPay money credited to DailyPay wallet
         * @summary Claim DailyPay money credited to DailyPay wallet
         * @param {ClaimDailyPay} claimDailyPay 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        claimDailyPay(claimDailyPay: ClaimDailyPay, options?: RawAxiosRequestConfig): AxiosPromise<ApiResponseDto> {
            return localVarFp.claimDailyPay(claimDailyPay, options).then((request) => request(axios, basePath));
        },
        /**
         * Resource to deactivate DailyPay
         * @summary Deactivate DailyPay
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deactivateDailyPay(options?: RawAxiosRequestConfig): AxiosPromise<ApiResponseDto> {
            return localVarFp.deactivateDailyPay(options).then((request) => request(axios, basePath));
        },
        /**
         * Resource to decline salary mandate request
         * @summary Decline salary mandate request
         * @param {DailyPayJobStep4DeclineMandate} dailyPayJobStep4DeclineMandate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        declineMandateRequest(dailyPayJobStep4DeclineMandate: DailyPayJobStep4DeclineMandate, options?: RawAxiosRequestConfig): AxiosPromise<ApiResponseDto> {
            return localVarFp.declineMandateRequest(dailyPayJobStep4DeclineMandate, options).then((request) => request(axios, basePath));
        },
        /**
         * Resource to retrieve linked job details
         * @summary Retrieve linked job details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getJobDetails(options?: RawAxiosRequestConfig): AxiosPromise<ApiResponseDtoJobResponse> {
            return localVarFp.getJobDetails(options).then((request) => request(axios, basePath));
        },
        /**
         * Resource to link salary account with Mono
         * @summary Link salary account with Mono
         * @param {DailyPayJobStep2} dailyPayJobStep2 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        linkJobSalaryAccount(dailyPayJobStep2: DailyPayJobStep2, options?: RawAxiosRequestConfig): AxiosPromise<ApiResponseDtoJobResponse> {
            return localVarFp.linkJobSalaryAccount(dailyPayJobStep2, options).then((request) => request(axios, basePath));
        },
        /**
         * Resource to resend mandate review request email
         * @summary Resend mandate review request email
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resendMandateEmailToHr(options?: RawAxiosRequestConfig): AxiosPromise<ApiResponseDtoJobResponse> {
            return localVarFp.resendMandateEmailToHr(options).then((request) => request(axios, basePath));
        },
        /**
         * Resource to retrieve user DailyPay wallet information
         * @summary Retrieve user DailyPay wallet information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveDailyPayWalletInfo(options?: RawAxiosRequestConfig): AxiosPromise<ApiResponseDtoWalletResponse> {
            return localVarFp.retrieveDailyPayWalletInfo(options).then((request) => request(axios, basePath));
        },
        /**
         * Resource to send mandate review request to HR - step 3
         * @summary Send mandate review request to HR - step 3
         * @param {DailyPayJobStep3} dailyPayJobStep3 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendMandateReviewRequestToHr(dailyPayJobStep3: DailyPayJobStep3, options?: RawAxiosRequestConfig): AxiosPromise<ApiResponseDtoJobResponse> {
            return localVarFp.sendMandateReviewRequestToHr(dailyPayJobStep3, options).then((request) => request(axios, basePath));
        },
        /**
         * Resource to unlink salary account from Mono
         * @summary Unlink salary account from Mono
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unlinkJobSalaryAccount(options?: RawAxiosRequestConfig): AxiosPromise<ApiResponseDto> {
            return localVarFp.unlinkJobSalaryAccount(options).then((request) => request(axios, basePath));
        },
        /**
         * Resource to update DailyPay job profile - step 1
         * @summary Update DailyPay job profile - step 1
         * @param {DailyPayJobStep1} dailyPayJobStep1 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateJobProfile(dailyPayJobStep1: DailyPayJobStep1, options?: RawAxiosRequestConfig): AxiosPromise<ApiResponseDtoJobResponse> {
            return localVarFp.updateJobProfile(dailyPayJobStep1, options).then((request) => request(axios, basePath));
        },
        /**
         * Resource to upload salary account 6 months bank statement
         * @summary Upload salary account 6 months bank statement
         * @param {string} bankName Salary bank name
         * @param {string} accountName Salary account name
         * @param {string} accountNumber Salary account number
         * @param {File} file Bank statement PDF file
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadBankStatementOfJobSalaryAccount(bankName: string, accountName: string, accountNumber: string, file: File, options?: RawAxiosRequestConfig): AxiosPromise<ApiResponseDtoJobResponse> {
            return localVarFp.uploadBankStatementOfJobSalaryAccount(bankName, accountName, accountNumber, file, options).then((request) => request(axios, basePath));
        },
        /**
         * Resource to validate HR email
         * @summary Validate HR email
         * @param {ValidateHrEmailRequest} validateHrEmailRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        validateHrEmail(validateHrEmailRequest: ValidateHrEmailRequest, options?: RawAxiosRequestConfig): AxiosPromise<ApiResponseDtoValidateHrEmailResponse> {
            return localVarFp.validateHrEmail(validateHrEmailRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DailypayResourceApi - object-oriented interface
 * @export
 * @class DailypayResourceApi
 * @extends {BaseAPI}
 */
export class DailypayResourceApi extends BaseAPI {
    /**
     * Resource to activate DailyPay
     * @summary Activate DailyPay
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DailypayResourceApi
     */
    public activateDailyPay(options?: RawAxiosRequestConfig) {
        return DailypayResourceApiFp(this.configuration).activateDailyPay(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Resource to Add DailyPay job profile - step 1
     * @summary Add DailyPay job profile - step 1
     * @param {DailyPayJobStep1} dailyPayJobStep1 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DailypayResourceApi
     */
    public addJobProfile(dailyPayJobStep1: DailyPayJobStep1, options?: RawAxiosRequestConfig) {
        return DailypayResourceApiFp(this.configuration).addJobProfile(dailyPayJobStep1, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Resource to approve salary mandate request
     * @summary Approve salary mandate request
     * @param {DailyPayJobStep4ApproveMandate} dailyPayJobStep4ApproveMandate 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DailypayResourceApi
     */
    public approveMandateRequest(dailyPayJobStep4ApproveMandate: DailyPayJobStep4ApproveMandate, options?: RawAxiosRequestConfig) {
        return DailypayResourceApiFp(this.configuration).approveMandateRequest(dailyPayJobStep4ApproveMandate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Resource to claim DailyPay money credited to DailyPay wallet
     * @summary Claim DailyPay money credited to DailyPay wallet
     * @param {ClaimDailyPay} claimDailyPay 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DailypayResourceApi
     */
    public claimDailyPay(claimDailyPay: ClaimDailyPay, options?: RawAxiosRequestConfig) {
        return DailypayResourceApiFp(this.configuration).claimDailyPay(claimDailyPay, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Resource to deactivate DailyPay
     * @summary Deactivate DailyPay
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DailypayResourceApi
     */
    public deactivateDailyPay(options?: RawAxiosRequestConfig) {
        return DailypayResourceApiFp(this.configuration).deactivateDailyPay(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Resource to decline salary mandate request
     * @summary Decline salary mandate request
     * @param {DailyPayJobStep4DeclineMandate} dailyPayJobStep4DeclineMandate 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DailypayResourceApi
     */
    public declineMandateRequest(dailyPayJobStep4DeclineMandate: DailyPayJobStep4DeclineMandate, options?: RawAxiosRequestConfig) {
        return DailypayResourceApiFp(this.configuration).declineMandateRequest(dailyPayJobStep4DeclineMandate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Resource to retrieve linked job details
     * @summary Retrieve linked job details
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DailypayResourceApi
     */
    public getJobDetails(options?: RawAxiosRequestConfig) {
        return DailypayResourceApiFp(this.configuration).getJobDetails(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Resource to link salary account with Mono
     * @summary Link salary account with Mono
     * @param {DailyPayJobStep2} dailyPayJobStep2 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DailypayResourceApi
     */
    public linkJobSalaryAccount(dailyPayJobStep2: DailyPayJobStep2, options?: RawAxiosRequestConfig) {
        return DailypayResourceApiFp(this.configuration).linkJobSalaryAccount(dailyPayJobStep2, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Resource to resend mandate review request email
     * @summary Resend mandate review request email
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DailypayResourceApi
     */
    public resendMandateEmailToHr(options?: RawAxiosRequestConfig) {
        return DailypayResourceApiFp(this.configuration).resendMandateEmailToHr(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Resource to retrieve user DailyPay wallet information
     * @summary Retrieve user DailyPay wallet information
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DailypayResourceApi
     */
    public retrieveDailyPayWalletInfo(options?: RawAxiosRequestConfig) {
        return DailypayResourceApiFp(this.configuration).retrieveDailyPayWalletInfo(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Resource to send mandate review request to HR - step 3
     * @summary Send mandate review request to HR - step 3
     * @param {DailyPayJobStep3} dailyPayJobStep3 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DailypayResourceApi
     */
    public sendMandateReviewRequestToHr(dailyPayJobStep3: DailyPayJobStep3, options?: RawAxiosRequestConfig) {
        return DailypayResourceApiFp(this.configuration).sendMandateReviewRequestToHr(dailyPayJobStep3, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Resource to unlink salary account from Mono
     * @summary Unlink salary account from Mono
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DailypayResourceApi
     */
    public unlinkJobSalaryAccount(options?: RawAxiosRequestConfig) {
        return DailypayResourceApiFp(this.configuration).unlinkJobSalaryAccount(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Resource to update DailyPay job profile - step 1
     * @summary Update DailyPay job profile - step 1
     * @param {DailyPayJobStep1} dailyPayJobStep1 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DailypayResourceApi
     */
    public updateJobProfile(dailyPayJobStep1: DailyPayJobStep1, options?: RawAxiosRequestConfig) {
        return DailypayResourceApiFp(this.configuration).updateJobProfile(dailyPayJobStep1, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Resource to upload salary account 6 months bank statement
     * @summary Upload salary account 6 months bank statement
     * @param {string} bankName Salary bank name
     * @param {string} accountName Salary account name
     * @param {string} accountNumber Salary account number
     * @param {File} file Bank statement PDF file
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DailypayResourceApi
     */
    public uploadBankStatementOfJobSalaryAccount(bankName: string, accountName: string, accountNumber: string, file: File, options?: RawAxiosRequestConfig) {
        return DailypayResourceApiFp(this.configuration).uploadBankStatementOfJobSalaryAccount(bankName, accountName, accountNumber, file, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Resource to validate HR email
     * @summary Validate HR email
     * @param {ValidateHrEmailRequest} validateHrEmailRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DailypayResourceApi
     */
    public validateHrEmail(validateHrEmailRequest: ValidateHrEmailRequest, options?: RawAxiosRequestConfig) {
        return DailypayResourceApiFp(this.configuration).validateHrEmail(validateHrEmailRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * DashboardResourceApi - axios parameter creator
 * @export
 */
export const DashboardResourceApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Resource to metrics and analytics for DailyPay wallet
         * @summary Get metrics and analytics for DailyPay wallet
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDailyPayWalletMetrics: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/dashboard/metrics/dailypay-wallet`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Resource to metrics and analytics for main wallet
         * @summary Get metrics and analytics for main wallet
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMailWalletMetrics: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/dashboard/metrics/main-wallet`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DashboardResourceApi - functional programming interface
 * @export
 */
export const DashboardResourceApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DashboardResourceApiAxiosParamCreator(configuration)
    return {
        /**
         * Resource to metrics and analytics for DailyPay wallet
         * @summary Get metrics and analytics for DailyPay wallet
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDailyPayWalletMetrics(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiResponseDtoDailyPayWalletMetrics>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDailyPayWalletMetrics(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DashboardResourceApi.getDailyPayWalletMetrics']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Resource to metrics and analytics for main wallet
         * @summary Get metrics and analytics for main wallet
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMailWalletMetrics(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiResponseDtoMainWalletMetrics>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMailWalletMetrics(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DashboardResourceApi.getMailWalletMetrics']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * DashboardResourceApi - factory interface
 * @export
 */
export const DashboardResourceApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DashboardResourceApiFp(configuration)
    return {
        /**
         * Resource to metrics and analytics for DailyPay wallet
         * @summary Get metrics and analytics for DailyPay wallet
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDailyPayWalletMetrics(options?: RawAxiosRequestConfig): AxiosPromise<ApiResponseDtoDailyPayWalletMetrics> {
            return localVarFp.getDailyPayWalletMetrics(options).then((request) => request(axios, basePath));
        },
        /**
         * Resource to metrics and analytics for main wallet
         * @summary Get metrics and analytics for main wallet
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMailWalletMetrics(options?: RawAxiosRequestConfig): AxiosPromise<ApiResponseDtoMainWalletMetrics> {
            return localVarFp.getMailWalletMetrics(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DashboardResourceApi - object-oriented interface
 * @export
 * @class DashboardResourceApi
 * @extends {BaseAPI}
 */
export class DashboardResourceApi extends BaseAPI {
    /**
     * Resource to metrics and analytics for DailyPay wallet
     * @summary Get metrics and analytics for DailyPay wallet
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DashboardResourceApi
     */
    public getDailyPayWalletMetrics(options?: RawAxiosRequestConfig) {
        return DashboardResourceApiFp(this.configuration).getDailyPayWalletMetrics(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Resource to metrics and analytics for main wallet
     * @summary Get metrics and analytics for main wallet
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DashboardResourceApi
     */
    public getMailWalletMetrics(options?: RawAxiosRequestConfig) {
        return DashboardResourceApiFp(this.configuration).getMailWalletMetrics(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * FileResourceApi - axios parameter creator
 * @export
 */
export const FileResourceApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Resource to download file from s3 bucket
         * @summary Download file from s3 bucket
         * @param {string} fileName Name of file to download
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadFile: async (fileName: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'fileName' is not null or undefined
            assertParamExists('downloadFile', 'fileName', fileName)
            const localVarPath = `/api/v1/file/download`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (fileName !== undefined) {
                localVarQueryParameter['fileName'] = fileName;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Resource to view/preview file from s3 bucket
         * @summary View/preview file from s3 bucket
         * @param {string} fileName Name of file to view/preview
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        previewFile: async (fileName: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'fileName' is not null or undefined
            assertParamExists('previewFile', 'fileName', fileName)
            const localVarPath = `/api/v1/file/preview`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (fileName !== undefined) {
                localVarQueryParameter['fileName'] = fileName;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Resource to upload file to s3 bucket
         * @summary Upload file to s3 bucket
         * @param {File} file File to upload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadFile: async (file: File, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'file' is not null or undefined
            assertParamExists('uploadFile', 'file', file)
            const localVarPath = `/api/v1/file/upload`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();


            if (file !== undefined) { 
                localVarFormParams.append('file', file as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Resource to upload file to s3 bucket from base64 string
         * @summary Upload file to s3 bucket from base64 string
         * @param {UploadBase64File} uploadBase64File 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadFileFromBase64: async (uploadBase64File: UploadBase64File, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uploadBase64File' is not null or undefined
            assertParamExists('uploadFileFromBase64', 'uploadBase64File', uploadBase64File)
            const localVarPath = `/api/v1/file/upload/base64`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(uploadBase64File, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * FileResourceApi - functional programming interface
 * @export
 */
export const FileResourceApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = FileResourceApiAxiosParamCreator(configuration)
    return {
        /**
         * Resource to download file from s3 bucket
         * @summary Download file from s3 bucket
         * @param {string} fileName Name of file to download
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async downloadFile(fileName: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.downloadFile(fileName, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FileResourceApi.downloadFile']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Resource to view/preview file from s3 bucket
         * @summary View/preview file from s3 bucket
         * @param {string} fileName Name of file to view/preview
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async previewFile(fileName: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.previewFile(fileName, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FileResourceApi.previewFile']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Resource to upload file to s3 bucket
         * @summary Upload file to s3 bucket
         * @param {File} file File to upload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async uploadFile(file: File, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiResponseDtoFileUploadResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.uploadFile(file, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FileResourceApi.uploadFile']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Resource to upload file to s3 bucket from base64 string
         * @summary Upload file to s3 bucket from base64 string
         * @param {UploadBase64File} uploadBase64File 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async uploadFileFromBase64(uploadBase64File: UploadBase64File, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiResponseDtoFileUploadResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.uploadFileFromBase64(uploadBase64File, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FileResourceApi.uploadFileFromBase64']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * FileResourceApi - factory interface
 * @export
 */
export const FileResourceApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = FileResourceApiFp(configuration)
    return {
        /**
         * Resource to download file from s3 bucket
         * @summary Download file from s3 bucket
         * @param {string} fileName Name of file to download
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadFile(fileName: string, options?: RawAxiosRequestConfig): AxiosPromise<ApiResponseDto> {
            return localVarFp.downloadFile(fileName, options).then((request) => request(axios, basePath));
        },
        /**
         * Resource to view/preview file from s3 bucket
         * @summary View/preview file from s3 bucket
         * @param {string} fileName Name of file to view/preview
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        previewFile(fileName: string, options?: RawAxiosRequestConfig): AxiosPromise<ApiResponseDto> {
            return localVarFp.previewFile(fileName, options).then((request) => request(axios, basePath));
        },
        /**
         * Resource to upload file to s3 bucket
         * @summary Upload file to s3 bucket
         * @param {File} file File to upload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadFile(file: File, options?: RawAxiosRequestConfig): AxiosPromise<ApiResponseDtoFileUploadResponse> {
            return localVarFp.uploadFile(file, options).then((request) => request(axios, basePath));
        },
        /**
         * Resource to upload file to s3 bucket from base64 string
         * @summary Upload file to s3 bucket from base64 string
         * @param {UploadBase64File} uploadBase64File 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadFileFromBase64(uploadBase64File: UploadBase64File, options?: RawAxiosRequestConfig): AxiosPromise<ApiResponseDtoFileUploadResponse> {
            return localVarFp.uploadFileFromBase64(uploadBase64File, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * FileResourceApi - object-oriented interface
 * @export
 * @class FileResourceApi
 * @extends {BaseAPI}
 */
export class FileResourceApi extends BaseAPI {
    /**
     * Resource to download file from s3 bucket
     * @summary Download file from s3 bucket
     * @param {string} fileName Name of file to download
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FileResourceApi
     */
    public downloadFile(fileName: string, options?: RawAxiosRequestConfig) {
        return FileResourceApiFp(this.configuration).downloadFile(fileName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Resource to view/preview file from s3 bucket
     * @summary View/preview file from s3 bucket
     * @param {string} fileName Name of file to view/preview
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FileResourceApi
     */
    public previewFile(fileName: string, options?: RawAxiosRequestConfig) {
        return FileResourceApiFp(this.configuration).previewFile(fileName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Resource to upload file to s3 bucket
     * @summary Upload file to s3 bucket
     * @param {File} file File to upload
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FileResourceApi
     */
    public uploadFile(file: File, options?: RawAxiosRequestConfig) {
        return FileResourceApiFp(this.configuration).uploadFile(file, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Resource to upload file to s3 bucket from base64 string
     * @summary Upload file to s3 bucket from base64 string
     * @param {UploadBase64File} uploadBase64File 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FileResourceApi
     */
    public uploadFileFromBase64(uploadBase64File: UploadBase64File, options?: RawAxiosRequestConfig) {
        return FileResourceApiFp(this.configuration).uploadFileFromBase64(uploadBase64File, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * KycResourceApi - axios parameter creator
 * @export
 */
export const KycResourceApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Resource to complete BVN verification
         * @summary Complete BVN verification
         * @param {BvnVerifyOtp} bvnVerifyOtp 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        completeBvnVerification: async (bvnVerifyOtp: BvnVerifyOtp, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'bvnVerifyOtp' is not null or undefined
            assertParamExists('completeBvnVerification', 'bvnVerifyOtp', bvnVerifyOtp)
            const localVarPath = `/api/v1/kyc/verification/bvn/complete`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(bvnVerifyOtp, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Resource to complete NIN verification
         * @summary Complete NIN verification
         * @param {NinVerifyOtp} ninVerifyOtp 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        completeNinVerification: async (ninVerifyOtp: NinVerifyOtp, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ninVerifyOtp' is not null or undefined
            assertParamExists('completeNinVerification', 'ninVerifyOtp', ninVerifyOtp)
            const localVarPath = `/api/v1/kyc/verification/nin/complete`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(ninVerifyOtp, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Resource to retrieve user KYC data
         * @summary Retrieve user KYC data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getKyc: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/kyc`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Resource to retrieve user KYC status
         * @summary Retrieve user KYC status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getKycStatus: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/kyc/status`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Resource to initiate BVN verification
         * @summary Initiate BVN verification
         * @param {BvnCheck} bvnCheck 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        initiateBvnVerification: async (bvnCheck: BvnCheck, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'bvnCheck' is not null or undefined
            assertParamExists('initiateBvnVerification', 'bvnCheck', bvnCheck)
            const localVarPath = `/api/v1/kyc/verification/bvn/initiate`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(bvnCheck, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Resource to initiate NIN verification
         * @summary Initiate NIN verification
         * @param {NinCheck} ninCheck 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        initiateNinVerification: async (ninCheck: NinCheck, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ninCheck' is not null or undefined
            assertParamExists('initiateNinVerification', 'ninCheck', ninCheck)
            const localVarPath = `/api/v1/kyc/verification/nin/initiate`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(ninCheck, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Resource to resend BVN OTP
         * @summary Resend BVN OTP
         * @param {ResendBvnOtp} resendBvnOtp 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resendBvnOtp: async (resendBvnOtp: ResendBvnOtp, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'resendBvnOtp' is not null or undefined
            assertParamExists('resendBvnOtp', 'resendBvnOtp', resendBvnOtp)
            const localVarPath = `/api/v1/kyc/verification/bvn/resend-otp`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(resendBvnOtp, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Resource to resend NIN OTP
         * @summary Resend NIN OTP
         * @param {ResendNinOtp} resendNinOtp 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resendNinOtp: async (resendNinOtp: ResendNinOtp, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'resendNinOtp' is not null or undefined
            assertParamExists('resendNinOtp', 'resendNinOtp', resendNinOtp)
            const localVarPath = `/api/v1/kyc/verification/nin/resend-otp`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(resendNinOtp, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * KycResourceApi - functional programming interface
 * @export
 */
export const KycResourceApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = KycResourceApiAxiosParamCreator(configuration)
    return {
        /**
         * Resource to complete BVN verification
         * @summary Complete BVN verification
         * @param {BvnVerifyOtp} bvnVerifyOtp 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async completeBvnVerification(bvnVerifyOtp: BvnVerifyOtp, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.completeBvnVerification(bvnVerifyOtp, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['KycResourceApi.completeBvnVerification']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Resource to complete NIN verification
         * @summary Complete NIN verification
         * @param {NinVerifyOtp} ninVerifyOtp 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async completeNinVerification(ninVerifyOtp: NinVerifyOtp, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.completeNinVerification(ninVerifyOtp, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['KycResourceApi.completeNinVerification']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Resource to retrieve user KYC data
         * @summary Retrieve user KYC data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getKyc(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiResponseDtoKycResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getKyc(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['KycResourceApi.getKyc']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Resource to retrieve user KYC status
         * @summary Retrieve user KYC status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getKycStatus(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiResponseDtoKycStatusResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getKycStatus(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['KycResourceApi.getKycStatus']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Resource to initiate BVN verification
         * @summary Initiate BVN verification
         * @param {BvnCheck} bvnCheck 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async initiateBvnVerification(bvnCheck: BvnCheck, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiResponseDtoBvnVerificationResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.initiateBvnVerification(bvnCheck, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['KycResourceApi.initiateBvnVerification']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Resource to initiate NIN verification
         * @summary Initiate NIN verification
         * @param {NinCheck} ninCheck 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async initiateNinVerification(ninCheck: NinCheck, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiResponseDtoNinVerificationResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.initiateNinVerification(ninCheck, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['KycResourceApi.initiateNinVerification']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Resource to resend BVN OTP
         * @summary Resend BVN OTP
         * @param {ResendBvnOtp} resendBvnOtp 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async resendBvnOtp(resendBvnOtp: ResendBvnOtp, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiResponseDtoBvnVerificationResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.resendBvnOtp(resendBvnOtp, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['KycResourceApi.resendBvnOtp']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Resource to resend NIN OTP
         * @summary Resend NIN OTP
         * @param {ResendNinOtp} resendNinOtp 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async resendNinOtp(resendNinOtp: ResendNinOtp, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiResponseDtoNinVerificationResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.resendNinOtp(resendNinOtp, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['KycResourceApi.resendNinOtp']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * KycResourceApi - factory interface
 * @export
 */
export const KycResourceApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = KycResourceApiFp(configuration)
    return {
        /**
         * Resource to complete BVN verification
         * @summary Complete BVN verification
         * @param {BvnVerifyOtp} bvnVerifyOtp 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        completeBvnVerification(bvnVerifyOtp: BvnVerifyOtp, options?: RawAxiosRequestConfig): AxiosPromise<ApiResponseDto> {
            return localVarFp.completeBvnVerification(bvnVerifyOtp, options).then((request) => request(axios, basePath));
        },
        /**
         * Resource to complete NIN verification
         * @summary Complete NIN verification
         * @param {NinVerifyOtp} ninVerifyOtp 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        completeNinVerification(ninVerifyOtp: NinVerifyOtp, options?: RawAxiosRequestConfig): AxiosPromise<ApiResponseDto> {
            return localVarFp.completeNinVerification(ninVerifyOtp, options).then((request) => request(axios, basePath));
        },
        /**
         * Resource to retrieve user KYC data
         * @summary Retrieve user KYC data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getKyc(options?: RawAxiosRequestConfig): AxiosPromise<ApiResponseDtoKycResponse> {
            return localVarFp.getKyc(options).then((request) => request(axios, basePath));
        },
        /**
         * Resource to retrieve user KYC status
         * @summary Retrieve user KYC status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getKycStatus(options?: RawAxiosRequestConfig): AxiosPromise<ApiResponseDtoKycStatusResponse> {
            return localVarFp.getKycStatus(options).then((request) => request(axios, basePath));
        },
        /**
         * Resource to initiate BVN verification
         * @summary Initiate BVN verification
         * @param {BvnCheck} bvnCheck 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        initiateBvnVerification(bvnCheck: BvnCheck, options?: RawAxiosRequestConfig): AxiosPromise<ApiResponseDtoBvnVerificationResponse> {
            return localVarFp.initiateBvnVerification(bvnCheck, options).then((request) => request(axios, basePath));
        },
        /**
         * Resource to initiate NIN verification
         * @summary Initiate NIN verification
         * @param {NinCheck} ninCheck 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        initiateNinVerification(ninCheck: NinCheck, options?: RawAxiosRequestConfig): AxiosPromise<ApiResponseDtoNinVerificationResponse> {
            return localVarFp.initiateNinVerification(ninCheck, options).then((request) => request(axios, basePath));
        },
        /**
         * Resource to resend BVN OTP
         * @summary Resend BVN OTP
         * @param {ResendBvnOtp} resendBvnOtp 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resendBvnOtp(resendBvnOtp: ResendBvnOtp, options?: RawAxiosRequestConfig): AxiosPromise<ApiResponseDtoBvnVerificationResponse> {
            return localVarFp.resendBvnOtp(resendBvnOtp, options).then((request) => request(axios, basePath));
        },
        /**
         * Resource to resend NIN OTP
         * @summary Resend NIN OTP
         * @param {ResendNinOtp} resendNinOtp 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resendNinOtp(resendNinOtp: ResendNinOtp, options?: RawAxiosRequestConfig): AxiosPromise<ApiResponseDtoNinVerificationResponse> {
            return localVarFp.resendNinOtp(resendNinOtp, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * KycResourceApi - object-oriented interface
 * @export
 * @class KycResourceApi
 * @extends {BaseAPI}
 */
export class KycResourceApi extends BaseAPI {
    /**
     * Resource to complete BVN verification
     * @summary Complete BVN verification
     * @param {BvnVerifyOtp} bvnVerifyOtp 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KycResourceApi
     */
    public completeBvnVerification(bvnVerifyOtp: BvnVerifyOtp, options?: RawAxiosRequestConfig) {
        return KycResourceApiFp(this.configuration).completeBvnVerification(bvnVerifyOtp, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Resource to complete NIN verification
     * @summary Complete NIN verification
     * @param {NinVerifyOtp} ninVerifyOtp 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KycResourceApi
     */
    public completeNinVerification(ninVerifyOtp: NinVerifyOtp, options?: RawAxiosRequestConfig) {
        return KycResourceApiFp(this.configuration).completeNinVerification(ninVerifyOtp, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Resource to retrieve user KYC data
     * @summary Retrieve user KYC data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KycResourceApi
     */
    public getKyc(options?: RawAxiosRequestConfig) {
        return KycResourceApiFp(this.configuration).getKyc(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Resource to retrieve user KYC status
     * @summary Retrieve user KYC status
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KycResourceApi
     */
    public getKycStatus(options?: RawAxiosRequestConfig) {
        return KycResourceApiFp(this.configuration).getKycStatus(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Resource to initiate BVN verification
     * @summary Initiate BVN verification
     * @param {BvnCheck} bvnCheck 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KycResourceApi
     */
    public initiateBvnVerification(bvnCheck: BvnCheck, options?: RawAxiosRequestConfig) {
        return KycResourceApiFp(this.configuration).initiateBvnVerification(bvnCheck, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Resource to initiate NIN verification
     * @summary Initiate NIN verification
     * @param {NinCheck} ninCheck 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KycResourceApi
     */
    public initiateNinVerification(ninCheck: NinCheck, options?: RawAxiosRequestConfig) {
        return KycResourceApiFp(this.configuration).initiateNinVerification(ninCheck, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Resource to resend BVN OTP
     * @summary Resend BVN OTP
     * @param {ResendBvnOtp} resendBvnOtp 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KycResourceApi
     */
    public resendBvnOtp(resendBvnOtp: ResendBvnOtp, options?: RawAxiosRequestConfig) {
        return KycResourceApiFp(this.configuration).resendBvnOtp(resendBvnOtp, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Resource to resend NIN OTP
     * @summary Resend NIN OTP
     * @param {ResendNinOtp} resendNinOtp 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KycResourceApi
     */
    public resendNinOtp(resendNinOtp: ResendNinOtp, options?: RawAxiosRequestConfig) {
        return KycResourceApiFp(this.configuration).resendNinOtp(resendNinOtp, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * MonoResourceApi - axios parameter creator
 * @export
 */
export const MonoResourceApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Resource to get average monthly income
         * @summary Get average monthly income
         * @param {string} accountId Mono account id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAverageMonthlyIncome: async (accountId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('getAverageMonthlyIncome', 'accountId', accountId)
            const localVarPath = `/api/v1/mono/avg-monthly-income`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (accountId !== undefined) {
                localVarQueryParameter['accountId'] = accountId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Resource to metrics and analytics for DailyPay wallet
         * @summary Get metrics and analytics for DailyPay wallet
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDailyPayWalletMetrics: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/dashboard/metrics/dailypay-wallet`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Resource to metrics and analytics for main wallet
         * @summary Get metrics and analytics for main wallet
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMailWalletMetrics: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/dashboard/metrics/main-wallet`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Resource to get account statement records
         * @summary Get account statement records
         * @param {string} accountId Mono account id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStatementRecord: async (accountId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('getStatementRecord', 'accountId', accountId)
            const localVarPath = `/api/v1/mono/statement`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (accountId !== undefined) {
                localVarQueryParameter['accountId'] = accountId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Resource to get account transactions records
         * @summary Get account transactions records
         * @param {string} accountId Mono account id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTransactionsRecord: async (accountId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('getTransactionsRecord', 'accountId', accountId)
            const localVarPath = `/api/v1/mono/transaction`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (accountId !== undefined) {
                localVarQueryParameter['accountId'] = accountId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MonoResourceApi - functional programming interface
 * @export
 */
export const MonoResourceApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = MonoResourceApiAxiosParamCreator(configuration)
    return {
        /**
         * Resource to get average monthly income
         * @summary Get average monthly income
         * @param {string} accountId Mono account id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAverageMonthlyIncome(accountId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAverageMonthlyIncome(accountId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MonoResourceApi.getAverageMonthlyIncome']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Resource to metrics and analytics for DailyPay wallet
         * @summary Get metrics and analytics for DailyPay wallet
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDailyPayWalletMetrics(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiResponseDtoDailyPayWalletMetrics>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDailyPayWalletMetrics(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MonoResourceApi.getDailyPayWalletMetrics']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Resource to metrics and analytics for main wallet
         * @summary Get metrics and analytics for main wallet
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMailWalletMetrics(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiResponseDtoMainWalletMetrics>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMailWalletMetrics(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MonoResourceApi.getMailWalletMetrics']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Resource to get account statement records
         * @summary Get account statement records
         * @param {string} accountId Mono account id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getStatementRecord(accountId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getStatementRecord(accountId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MonoResourceApi.getStatementRecord']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Resource to get account transactions records
         * @summary Get account transactions records
         * @param {string} accountId Mono account id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTransactionsRecord(accountId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTransactionsRecord(accountId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MonoResourceApi.getTransactionsRecord']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * MonoResourceApi - factory interface
 * @export
 */
export const MonoResourceApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = MonoResourceApiFp(configuration)
    return {
        /**
         * Resource to get average monthly income
         * @summary Get average monthly income
         * @param {string} accountId Mono account id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAverageMonthlyIncome(accountId: string, options?: RawAxiosRequestConfig): AxiosPromise<ApiResponseDto> {
            return localVarFp.getAverageMonthlyIncome(accountId, options).then((request) => request(axios, basePath));
        },
        /**
         * Resource to metrics and analytics for DailyPay wallet
         * @summary Get metrics and analytics for DailyPay wallet
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDailyPayWalletMetrics(options?: RawAxiosRequestConfig): AxiosPromise<ApiResponseDtoDailyPayWalletMetrics> {
            return localVarFp.getDailyPayWalletMetrics(options).then((request) => request(axios, basePath));
        },
        /**
         * Resource to metrics and analytics for main wallet
         * @summary Get metrics and analytics for main wallet
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMailWalletMetrics(options?: RawAxiosRequestConfig): AxiosPromise<ApiResponseDtoMainWalletMetrics> {
            return localVarFp.getMailWalletMetrics(options).then((request) => request(axios, basePath));
        },
        /**
         * Resource to get account statement records
         * @summary Get account statement records
         * @param {string} accountId Mono account id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStatementRecord(accountId: string, options?: RawAxiosRequestConfig): AxiosPromise<ApiResponseDto> {
            return localVarFp.getStatementRecord(accountId, options).then((request) => request(axios, basePath));
        },
        /**
         * Resource to get account transactions records
         * @summary Get account transactions records
         * @param {string} accountId Mono account id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTransactionsRecord(accountId: string, options?: RawAxiosRequestConfig): AxiosPromise<ApiResponseDto> {
            return localVarFp.getTransactionsRecord(accountId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * MonoResourceApi - object-oriented interface
 * @export
 * @class MonoResourceApi
 * @extends {BaseAPI}
 */
export class MonoResourceApi extends BaseAPI {
    /**
     * Resource to get average monthly income
     * @summary Get average monthly income
     * @param {string} accountId Mono account id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MonoResourceApi
     */
    public getAverageMonthlyIncome(accountId: string, options?: RawAxiosRequestConfig) {
        return MonoResourceApiFp(this.configuration).getAverageMonthlyIncome(accountId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Resource to metrics and analytics for DailyPay wallet
     * @summary Get metrics and analytics for DailyPay wallet
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MonoResourceApi
     */
    public getDailyPayWalletMetrics(options?: RawAxiosRequestConfig) {
        return MonoResourceApiFp(this.configuration).getDailyPayWalletMetrics(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Resource to metrics and analytics for main wallet
     * @summary Get metrics and analytics for main wallet
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MonoResourceApi
     */
    public getMailWalletMetrics(options?: RawAxiosRequestConfig) {
        return MonoResourceApiFp(this.configuration).getMailWalletMetrics(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Resource to get account statement records
     * @summary Get account statement records
     * @param {string} accountId Mono account id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MonoResourceApi
     */
    public getStatementRecord(accountId: string, options?: RawAxiosRequestConfig) {
        return MonoResourceApiFp(this.configuration).getStatementRecord(accountId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Resource to get account transactions records
     * @summary Get account transactions records
     * @param {string} accountId Mono account id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MonoResourceApi
     */
    public getTransactionsRecord(accountId: string, options?: RawAxiosRequestConfig) {
        return MonoResourceApiFp(this.configuration).getTransactionsRecord(accountId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * PaymentResourceApi - axios parameter creator
 * @export
 */
export const PaymentResourceApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Resource to get list of banks
         * @summary Get list of banks
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBankList: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/payment/transfer/bank-list`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Resource to validate account number and fetch account details
         * @summary Validate account number and fetch account details
         * @param {NameEnquiry} nameEnquiry 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        nameEnquiry: async (nameEnquiry: NameEnquiry, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'nameEnquiry' is not null or undefined
            assertParamExists('nameEnquiry', 'nameEnquiry', nameEnquiry)
            const localVarPath = `/api/v1/payment/transfer/name-enquiry`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(nameEnquiry, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Resource to transfer funds from main wallet to bank
         * @summary Transfer funds from main wallet to bank
         * @param {WalletToBankTransfer} walletToBankTransfer 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        walletToBankTransfer: async (walletToBankTransfer: WalletToBankTransfer, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'walletToBankTransfer' is not null or undefined
            assertParamExists('walletToBankTransfer', 'walletToBankTransfer', walletToBankTransfer)
            const localVarPath = `/api/v1/payment/transfer/wallet-to-bank`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(walletToBankTransfer, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PaymentResourceApi - functional programming interface
 * @export
 */
export const PaymentResourceApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PaymentResourceApiAxiosParamCreator(configuration)
    return {
        /**
         * Resource to get list of banks
         * @summary Get list of banks
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBankList(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiResponseDtoListBank>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getBankList(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PaymentResourceApi.getBankList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Resource to validate account number and fetch account details
         * @summary Validate account number and fetch account details
         * @param {NameEnquiry} nameEnquiry 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async nameEnquiry(nameEnquiry: NameEnquiry, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiResponseDtoNameEnquiryDataResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.nameEnquiry(nameEnquiry, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PaymentResourceApi.nameEnquiry']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Resource to transfer funds from main wallet to bank
         * @summary Transfer funds from main wallet to bank
         * @param {WalletToBankTransfer} walletToBankTransfer 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async walletToBankTransfer(walletToBankTransfer: WalletToBankTransfer, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.walletToBankTransfer(walletToBankTransfer, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PaymentResourceApi.walletToBankTransfer']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * PaymentResourceApi - factory interface
 * @export
 */
export const PaymentResourceApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PaymentResourceApiFp(configuration)
    return {
        /**
         * Resource to get list of banks
         * @summary Get list of banks
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBankList(options?: RawAxiosRequestConfig): AxiosPromise<ApiResponseDtoListBank> {
            return localVarFp.getBankList(options).then((request) => request(axios, basePath));
        },
        /**
         * Resource to validate account number and fetch account details
         * @summary Validate account number and fetch account details
         * @param {NameEnquiry} nameEnquiry 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        nameEnquiry(nameEnquiry: NameEnquiry, options?: RawAxiosRequestConfig): AxiosPromise<ApiResponseDtoNameEnquiryDataResponse> {
            return localVarFp.nameEnquiry(nameEnquiry, options).then((request) => request(axios, basePath));
        },
        /**
         * Resource to transfer funds from main wallet to bank
         * @summary Transfer funds from main wallet to bank
         * @param {WalletToBankTransfer} walletToBankTransfer 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        walletToBankTransfer(walletToBankTransfer: WalletToBankTransfer, options?: RawAxiosRequestConfig): AxiosPromise<ApiResponseDto> {
            return localVarFp.walletToBankTransfer(walletToBankTransfer, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PaymentResourceApi - object-oriented interface
 * @export
 * @class PaymentResourceApi
 * @extends {BaseAPI}
 */
export class PaymentResourceApi extends BaseAPI {
    /**
     * Resource to get list of banks
     * @summary Get list of banks
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentResourceApi
     */
    public getBankList(options?: RawAxiosRequestConfig) {
        return PaymentResourceApiFp(this.configuration).getBankList(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Resource to validate account number and fetch account details
     * @summary Validate account number and fetch account details
     * @param {NameEnquiry} nameEnquiry 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentResourceApi
     */
    public nameEnquiry(nameEnquiry: NameEnquiry, options?: RawAxiosRequestConfig) {
        return PaymentResourceApiFp(this.configuration).nameEnquiry(nameEnquiry, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Resource to transfer funds from main wallet to bank
     * @summary Transfer funds from main wallet to bank
     * @param {WalletToBankTransfer} walletToBankTransfer 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentResourceApi
     */
    public walletToBankTransfer(walletToBankTransfer: WalletToBankTransfer, options?: RawAxiosRequestConfig) {
        return PaymentResourceApiFp(this.configuration).walletToBankTransfer(walletToBankTransfer, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * SigninResourceApi - axios parameter creator
 * @export
 */
export const SigninResourceApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Resource to complete password reset with link
         * @summary Complete password reset with link
         * @param {CompletePasswordResetLink} completePasswordResetLink 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        completePasswordResetLink: async (completePasswordResetLink: CompletePasswordResetLink, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'completePasswordResetLink' is not null or undefined
            assertParamExists('completePasswordResetLink', 'completePasswordResetLink', completePasswordResetLink)
            const localVarPath = `/api/v1/signin/reset-password/link/complete`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(completePasswordResetLink, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Resource to complete password reset with OTP
         * @summary Complete password reset with OTP
         * @param {CompletePasswordResetOtp} completePasswordResetOtp 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        completePasswordResetOTP: async (completePasswordResetOtp: CompletePasswordResetOtp, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'completePasswordResetOtp' is not null or undefined
            assertParamExists('completePasswordResetOTP', 'completePasswordResetOtp', completePasswordResetOtp)
            const localVarPath = `/api/v1/signin/reset-password/otp/complete`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(completePasswordResetOtp, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Resource to reset password with link
         * @summary Reset password with link
         * @param {InitiateResetPassword} initiateResetPassword 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resetPasswordLink: async (initiateResetPassword: InitiateResetPassword, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'initiateResetPassword' is not null or undefined
            assertParamExists('resetPasswordLink', 'initiateResetPassword', initiateResetPassword)
            const localVarPath = `/api/v1/signin/reset-password/link/initiate`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(initiateResetPassword, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Resource to reset password with OTP
         * @summary Reset password with OTP
         * @param {InitiateResetPassword} initiateResetPassword 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resetPasswordOtp: async (initiateResetPassword: InitiateResetPassword, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'initiateResetPassword' is not null or undefined
            assertParamExists('resetPasswordOtp', 'initiateResetPassword', initiateResetPassword)
            const localVarPath = `/api/v1/signin/reset-password/otp/initiate`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(initiateResetPassword, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Resource to signin
         * @summary Signin
         * @param {Credentials} credentials 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        signIn: async (credentials: Credentials, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'credentials' is not null or undefined
            assertParamExists('signIn', 'credentials', credentials)
            const localVarPath = `/api/v1/signin`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(credentials, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SigninResourceApi - functional programming interface
 * @export
 */
export const SigninResourceApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SigninResourceApiAxiosParamCreator(configuration)
    return {
        /**
         * Resource to complete password reset with link
         * @summary Complete password reset with link
         * @param {CompletePasswordResetLink} completePasswordResetLink 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async completePasswordResetLink(completePasswordResetLink: CompletePasswordResetLink, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.completePasswordResetLink(completePasswordResetLink, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SigninResourceApi.completePasswordResetLink']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Resource to complete password reset with OTP
         * @summary Complete password reset with OTP
         * @param {CompletePasswordResetOtp} completePasswordResetOtp 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async completePasswordResetOTP(completePasswordResetOtp: CompletePasswordResetOtp, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.completePasswordResetOTP(completePasswordResetOtp, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SigninResourceApi.completePasswordResetOTP']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Resource to reset password with link
         * @summary Reset password with link
         * @param {InitiateResetPassword} initiateResetPassword 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async resetPasswordLink(initiateResetPassword: InitiateResetPassword, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.resetPasswordLink(initiateResetPassword, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SigninResourceApi.resetPasswordLink']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Resource to reset password with OTP
         * @summary Reset password with OTP
         * @param {InitiateResetPassword} initiateResetPassword 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async resetPasswordOtp(initiateResetPassword: InitiateResetPassword, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.resetPasswordOtp(initiateResetPassword, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SigninResourceApi.resetPasswordOtp']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Resource to signin
         * @summary Signin
         * @param {Credentials} credentials 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async signIn(credentials: Credentials, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiResponseDtoSignInResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.signIn(credentials, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SigninResourceApi.signIn']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * SigninResourceApi - factory interface
 * @export
 */
export const SigninResourceApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SigninResourceApiFp(configuration)
    return {
        /**
         * Resource to complete password reset with link
         * @summary Complete password reset with link
         * @param {CompletePasswordResetLink} completePasswordResetLink 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        completePasswordResetLink(completePasswordResetLink: CompletePasswordResetLink, options?: RawAxiosRequestConfig): AxiosPromise<ApiResponseDto> {
            return localVarFp.completePasswordResetLink(completePasswordResetLink, options).then((request) => request(axios, basePath));
        },
        /**
         * Resource to complete password reset with OTP
         * @summary Complete password reset with OTP
         * @param {CompletePasswordResetOtp} completePasswordResetOtp 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        completePasswordResetOTP(completePasswordResetOtp: CompletePasswordResetOtp, options?: RawAxiosRequestConfig): AxiosPromise<ApiResponseDto> {
            return localVarFp.completePasswordResetOTP(completePasswordResetOtp, options).then((request) => request(axios, basePath));
        },
        /**
         * Resource to reset password with link
         * @summary Reset password with link
         * @param {InitiateResetPassword} initiateResetPassword 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resetPasswordLink(initiateResetPassword: InitiateResetPassword, options?: RawAxiosRequestConfig): AxiosPromise<ApiResponseDto> {
            return localVarFp.resetPasswordLink(initiateResetPassword, options).then((request) => request(axios, basePath));
        },
        /**
         * Resource to reset password with OTP
         * @summary Reset password with OTP
         * @param {InitiateResetPassword} initiateResetPassword 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resetPasswordOtp(initiateResetPassword: InitiateResetPassword, options?: RawAxiosRequestConfig): AxiosPromise<ApiResponseDto> {
            return localVarFp.resetPasswordOtp(initiateResetPassword, options).then((request) => request(axios, basePath));
        },
        /**
         * Resource to signin
         * @summary Signin
         * @param {Credentials} credentials 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        signIn(credentials: Credentials, options?: RawAxiosRequestConfig): AxiosPromise<ApiResponseDtoSignInResponse> {
            return localVarFp.signIn(credentials, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SigninResourceApi - object-oriented interface
 * @export
 * @class SigninResourceApi
 * @extends {BaseAPI}
 */
export class SigninResourceApi extends BaseAPI {
    /**
     * Resource to complete password reset with link
     * @summary Complete password reset with link
     * @param {CompletePasswordResetLink} completePasswordResetLink 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SigninResourceApi
     */
    public completePasswordResetLink(completePasswordResetLink: CompletePasswordResetLink, options?: RawAxiosRequestConfig) {
        return SigninResourceApiFp(this.configuration).completePasswordResetLink(completePasswordResetLink, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Resource to complete password reset with OTP
     * @summary Complete password reset with OTP
     * @param {CompletePasswordResetOtp} completePasswordResetOtp 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SigninResourceApi
     */
    public completePasswordResetOTP(completePasswordResetOtp: CompletePasswordResetOtp, options?: RawAxiosRequestConfig) {
        return SigninResourceApiFp(this.configuration).completePasswordResetOTP(completePasswordResetOtp, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Resource to reset password with link
     * @summary Reset password with link
     * @param {InitiateResetPassword} initiateResetPassword 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SigninResourceApi
     */
    public resetPasswordLink(initiateResetPassword: InitiateResetPassword, options?: RawAxiosRequestConfig) {
        return SigninResourceApiFp(this.configuration).resetPasswordLink(initiateResetPassword, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Resource to reset password with OTP
     * @summary Reset password with OTP
     * @param {InitiateResetPassword} initiateResetPassword 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SigninResourceApi
     */
    public resetPasswordOtp(initiateResetPassword: InitiateResetPassword, options?: RawAxiosRequestConfig) {
        return SigninResourceApiFp(this.configuration).resetPasswordOtp(initiateResetPassword, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Resource to signin
     * @summary Signin
     * @param {Credentials} credentials 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SigninResourceApi
     */
    public signIn(credentials: Credentials, options?: RawAxiosRequestConfig) {
        return SigninResourceApiFp(this.configuration).signIn(credentials, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * SignupResourceApi - axios parameter creator
 * @export
 */
export const SignupResourceApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Resource to send OTP
         * @summary Send OTP
         * @param {SendOTPRequest} sendOTPRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendOTP: async (sendOTPRequest: SendOTPRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sendOTPRequest' is not null or undefined
            assertParamExists('sendOTP', 'sendOTPRequest', sendOTPRequest)
            const localVarPath = `/api/v1/signup/send-otp`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(sendOTPRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Resource to register new user
         * @summary Register new user
         * @param {SignUpRequest} signUpRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        signUp: async (signUpRequest: SignUpRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'signUpRequest' is not null or undefined
            assertParamExists('signUp', 'signUpRequest', signUpRequest)
            const localVarPath = `/api/v1/signup`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(signUpRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Resource to verify email
         * @summary Verify email
         * @param {string} email Email to verify
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        verifyEmail: async (email: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'email' is not null or undefined
            assertParamExists('verifyEmail', 'email', email)
            const localVarPath = `/api/v1/signup/verify-email`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (email !== undefined) {
                localVarQueryParameter['email'] = email;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Resource to verify OTP
         * @summary Verify OTP
         * @param {VerifyOTPRequest} verifyOTPRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        verifyOTP: async (verifyOTPRequest: VerifyOTPRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'verifyOTPRequest' is not null or undefined
            assertParamExists('verifyOTP', 'verifyOTPRequest', verifyOTPRequest)
            const localVarPath = `/api/v1/signup/verify-otp`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(verifyOTPRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SignupResourceApi - functional programming interface
 * @export
 */
export const SignupResourceApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SignupResourceApiAxiosParamCreator(configuration)
    return {
        /**
         * Resource to send OTP
         * @summary Send OTP
         * @param {SendOTPRequest} sendOTPRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sendOTP(sendOTPRequest: SendOTPRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.sendOTP(sendOTPRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SignupResourceApi.sendOTP']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Resource to register new user
         * @summary Register new user
         * @param {SignUpRequest} signUpRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async signUp(signUpRequest: SignUpRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.signUp(signUpRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SignupResourceApi.signUp']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Resource to verify email
         * @summary Verify email
         * @param {string} email Email to verify
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async verifyEmail(email: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.verifyEmail(email, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SignupResourceApi.verifyEmail']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Resource to verify OTP
         * @summary Verify OTP
         * @param {VerifyOTPRequest} verifyOTPRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async verifyOTP(verifyOTPRequest: VerifyOTPRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.verifyOTP(verifyOTPRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SignupResourceApi.verifyOTP']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * SignupResourceApi - factory interface
 * @export
 */
export const SignupResourceApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SignupResourceApiFp(configuration)
    return {
        /**
         * Resource to send OTP
         * @summary Send OTP
         * @param {SendOTPRequest} sendOTPRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendOTP(sendOTPRequest: SendOTPRequest, options?: RawAxiosRequestConfig): AxiosPromise<ApiResponseDto> {
            return localVarFp.sendOTP(sendOTPRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Resource to register new user
         * @summary Register new user
         * @param {SignUpRequest} signUpRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        signUp(signUpRequest: SignUpRequest, options?: RawAxiosRequestConfig): AxiosPromise<ApiResponseDto> {
            return localVarFp.signUp(signUpRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Resource to verify email
         * @summary Verify email
         * @param {string} email Email to verify
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        verifyEmail(email: string, options?: RawAxiosRequestConfig): AxiosPromise<ApiResponseDto> {
            return localVarFp.verifyEmail(email, options).then((request) => request(axios, basePath));
        },
        /**
         * Resource to verify OTP
         * @summary Verify OTP
         * @param {VerifyOTPRequest} verifyOTPRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        verifyOTP(verifyOTPRequest: VerifyOTPRequest, options?: RawAxiosRequestConfig): AxiosPromise<ApiResponseDto> {
            return localVarFp.verifyOTP(verifyOTPRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SignupResourceApi - object-oriented interface
 * @export
 * @class SignupResourceApi
 * @extends {BaseAPI}
 */
export class SignupResourceApi extends BaseAPI {
    /**
     * Resource to send OTP
     * @summary Send OTP
     * @param {SendOTPRequest} sendOTPRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SignupResourceApi
     */
    public sendOTP(sendOTPRequest: SendOTPRequest, options?: RawAxiosRequestConfig) {
        return SignupResourceApiFp(this.configuration).sendOTP(sendOTPRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Resource to register new user
     * @summary Register new user
     * @param {SignUpRequest} signUpRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SignupResourceApi
     */
    public signUp(signUpRequest: SignUpRequest, options?: RawAxiosRequestConfig) {
        return SignupResourceApiFp(this.configuration).signUp(signUpRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Resource to verify email
     * @summary Verify email
     * @param {string} email Email to verify
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SignupResourceApi
     */
    public verifyEmail(email: string, options?: RawAxiosRequestConfig) {
        return SignupResourceApiFp(this.configuration).verifyEmail(email, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Resource to verify OTP
     * @summary Verify OTP
     * @param {VerifyOTPRequest} verifyOTPRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SignupResourceApi
     */
    public verifyOTP(verifyOTPRequest: VerifyOTPRequest, options?: RawAxiosRequestConfig) {
        return SignupResourceApiFp(this.configuration).verifyOTP(verifyOTPRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * TestResourceApi - axios parameter creator
 * @export
 */
export const TestResourceApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Resource to test authentication and authorization
         * @summary Test
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        testApi: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/test`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Resource to test push notification
         * @summary Test
         * @param {string} userId ID of the user to retrieve
         * @param {string} fcmToken FcmToken of the user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        testPushNotification: async (userId: string, fcmToken: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('testPushNotification', 'userId', userId)
            // verify required parameter 'fcmToken' is not null or undefined
            assertParamExists('testPushNotification', 'fcmToken', fcmToken)
            const localVarPath = `/api/v1/test/notification`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }

            if (fcmToken !== undefined) {
                localVarQueryParameter['fcmToken'] = fcmToken;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Resource to validate HR LinkedIn profile
         * @summary Validate HR LinkedIn profile
         * @param {HrDataRequest} hrDataRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        validateLinkedInProfile: async (hrDataRequest: HrDataRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'hrDataRequest' is not null or undefined
            assertParamExists('validateLinkedInProfile', 'hrDataRequest', hrDataRequest)
            const localVarPath = `/api/v1/test/validate/liknedin-profile`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(hrDataRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TestResourceApi - functional programming interface
 * @export
 */
export const TestResourceApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TestResourceApiAxiosParamCreator(configuration)
    return {
        /**
         * Resource to test authentication and authorization
         * @summary Test
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async testApi(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.testApi(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TestResourceApi.testApi']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Resource to test push notification
         * @summary Test
         * @param {string} userId ID of the user to retrieve
         * @param {string} fcmToken FcmToken of the user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async testPushNotification(userId: string, fcmToken: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.testPushNotification(userId, fcmToken, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TestResourceApi.testPushNotification']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Resource to validate HR LinkedIn profile
         * @summary Validate HR LinkedIn profile
         * @param {HrDataRequest} hrDataRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async validateLinkedInProfile(hrDataRequest: HrDataRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiResponseDtoHrLinkedInValidationResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.validateLinkedInProfile(hrDataRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TestResourceApi.validateLinkedInProfile']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * TestResourceApi - factory interface
 * @export
 */
export const TestResourceApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TestResourceApiFp(configuration)
    return {
        /**
         * Resource to test authentication and authorization
         * @summary Test
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        testApi(options?: RawAxiosRequestConfig): AxiosPromise<ApiResponseDto> {
            return localVarFp.testApi(options).then((request) => request(axios, basePath));
        },
        /**
         * Resource to test push notification
         * @summary Test
         * @param {string} userId ID of the user to retrieve
         * @param {string} fcmToken FcmToken of the user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        testPushNotification(userId: string, fcmToken: string, options?: RawAxiosRequestConfig): AxiosPromise<ApiResponseDto> {
            return localVarFp.testPushNotification(userId, fcmToken, options).then((request) => request(axios, basePath));
        },
        /**
         * Resource to validate HR LinkedIn profile
         * @summary Validate HR LinkedIn profile
         * @param {HrDataRequest} hrDataRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        validateLinkedInProfile(hrDataRequest: HrDataRequest, options?: RawAxiosRequestConfig): AxiosPromise<ApiResponseDtoHrLinkedInValidationResponse> {
            return localVarFp.validateLinkedInProfile(hrDataRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TestResourceApi - object-oriented interface
 * @export
 * @class TestResourceApi
 * @extends {BaseAPI}
 */
export class TestResourceApi extends BaseAPI {
    /**
     * Resource to test authentication and authorization
     * @summary Test
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TestResourceApi
     */
    public testApi(options?: RawAxiosRequestConfig) {
        return TestResourceApiFp(this.configuration).testApi(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Resource to test push notification
     * @summary Test
     * @param {string} userId ID of the user to retrieve
     * @param {string} fcmToken FcmToken of the user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TestResourceApi
     */
    public testPushNotification(userId: string, fcmToken: string, options?: RawAxiosRequestConfig) {
        return TestResourceApiFp(this.configuration).testPushNotification(userId, fcmToken, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Resource to validate HR LinkedIn profile
     * @summary Validate HR LinkedIn profile
     * @param {HrDataRequest} hrDataRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TestResourceApi
     */
    public validateLinkedInProfile(hrDataRequest: HrDataRequest, options?: RawAxiosRequestConfig) {
        return TestResourceApiFp(this.configuration).validateLinkedInProfile(hrDataRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * TransactionResourceApi - axios parameter creator
 * @export
 */
export const TransactionResourceApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Resource to download transaction receipt by transaction id
         * @summary Download transaction receipt by transaction id
         * @param {string} transactionId Transaction Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadTransactionReceiptById: async (transactionId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'transactionId' is not null or undefined
            assertParamExists('downloadTransactionReceiptById', 'transactionId', transactionId)
            const localVarPath = `/api/v1/transaction/download/receipt/trans-id`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (transactionId !== undefined) {
                localVarQueryParameter['transactionId'] = transactionId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Resource to download transaction receipt by transaction reference
         * @summary Download transaction receipt by transaction reference
         * @param {string} transactionRef Transaction Reference
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadTransactionReceiptByRef: async (transactionRef: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'transactionRef' is not null or undefined
            assertParamExists('downloadTransactionReceiptByRef', 'transactionRef', transactionRef)
            const localVarPath = `/api/v1/transaction/download/receipt/trans-ref`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (transactionRef !== undefined) {
                localVarQueryParameter['transactionRef'] = transactionRef;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Resource to filter transactions
         * @summary Filter transactions
         * @param {FilterAllUserTransactionsFilterTypeEnum} filterType Transaction Filter Type
         * @param {string} filterKeyword Filter Keyword
         * @param {FilterAllUserTransactionsDirectionEnum} direction Sort Direction
         * @param {number} [page] Page
         * @param {number} [size] Size
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        filterAllUserTransactions: async (filterType: FilterAllUserTransactionsFilterTypeEnum, filterKeyword: string, direction: FilterAllUserTransactionsDirectionEnum, page?: number, size?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'filterType' is not null or undefined
            assertParamExists('filterAllUserTransactions', 'filterType', filterType)
            // verify required parameter 'filterKeyword' is not null or undefined
            assertParamExists('filterAllUserTransactions', 'filterKeyword', filterKeyword)
            // verify required parameter 'direction' is not null or undefined
            assertParamExists('filterAllUserTransactions', 'direction', direction)
            const localVarPath = `/api/v1/transaction/filter`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (filterType !== undefined) {
                localVarQueryParameter['filterType'] = filterType;
            }

            if (filterKeyword !== undefined) {
                localVarQueryParameter['filterKeyword'] = filterKeyword;
            }

            if (direction !== undefined) {
                localVarQueryParameter['direction'] = direction;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Resource to retrieve all user transactions
         * @summary Retrieve all user transactions
         * @param {number} [page] Page
         * @param {number} [size] Size
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findAllUserTransactions: async (page?: number, size?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/transaction/find-all`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Resource to retrieve transaction by transaction id
         * @summary Retrieve transaction by transaction id
         * @param {string} transactionId Transaction Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findTransactionById: async (transactionId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'transactionId' is not null or undefined
            assertParamExists('findTransactionById', 'transactionId', transactionId)
            const localVarPath = `/api/v1/transaction/find/trans-id`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (transactionId !== undefined) {
                localVarQueryParameter['transactionId'] = transactionId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Resource to retrieve transaction by transaction number
         * @summary Retrieve transaction by transaction number
         * @param {string} transactionNo Transaction number
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findTransactionByNo: async (transactionNo: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'transactionNo' is not null or undefined
            assertParamExists('findTransactionByNo', 'transactionNo', transactionNo)
            const localVarPath = `/api/v1/transaction/find/trans-no`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (transactionNo !== undefined) {
                localVarQueryParameter['transactionNo'] = transactionNo;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Resource to retrieve transaction by transaction reference
         * @summary Retrieve transaction by transaction reference
         * @param {string} transactionRef Transaction Reference
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findTransactionByRef: async (transactionRef: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'transactionRef' is not null or undefined
            assertParamExists('findTransactionByRef', 'transactionRef', transactionRef)
            const localVarPath = `/api/v1/transaction/find/trans-ref`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (transactionRef !== undefined) {
                localVarQueryParameter['transactionRef'] = transactionRef;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Resource to generate user callback keys
         * @summary Generate user callback keys
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        generateKeys: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/transaction/callback/safe-haven/generate-keys`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TransactionResourceApi - functional programming interface
 * @export
 */
export const TransactionResourceApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TransactionResourceApiAxiosParamCreator(configuration)
    return {
        /**
         * Resource to download transaction receipt by transaction id
         * @summary Download transaction receipt by transaction id
         * @param {string} transactionId Transaction Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async downloadTransactionReceiptById(transactionId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.downloadTransactionReceiptById(transactionId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TransactionResourceApi.downloadTransactionReceiptById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Resource to download transaction receipt by transaction reference
         * @summary Download transaction receipt by transaction reference
         * @param {string} transactionRef Transaction Reference
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async downloadTransactionReceiptByRef(transactionRef: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.downloadTransactionReceiptByRef(transactionRef, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TransactionResourceApi.downloadTransactionReceiptByRef']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Resource to filter transactions
         * @summary Filter transactions
         * @param {FilterAllUserTransactionsFilterTypeEnum} filterType Transaction Filter Type
         * @param {string} filterKeyword Filter Keyword
         * @param {FilterAllUserTransactionsDirectionEnum} direction Sort Direction
         * @param {number} [page] Page
         * @param {number} [size] Size
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async filterAllUserTransactions(filterType: FilterAllUserTransactionsFilterTypeEnum, filterKeyword: string, direction: FilterAllUserTransactionsDirectionEnum, page?: number, size?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiResponseDtoListTransactionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.filterAllUserTransactions(filterType, filterKeyword, direction, page, size, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TransactionResourceApi.filterAllUserTransactions']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Resource to retrieve all user transactions
         * @summary Retrieve all user transactions
         * @param {number} [page] Page
         * @param {number} [size] Size
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findAllUserTransactions(page?: number, size?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiResponseDtoListTransactionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findAllUserTransactions(page, size, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TransactionResourceApi.findAllUserTransactions']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Resource to retrieve transaction by transaction id
         * @summary Retrieve transaction by transaction id
         * @param {string} transactionId Transaction Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findTransactionById(transactionId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiResponseDtoTransactionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findTransactionById(transactionId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TransactionResourceApi.findTransactionById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Resource to retrieve transaction by transaction number
         * @summary Retrieve transaction by transaction number
         * @param {string} transactionNo Transaction number
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findTransactionByNo(transactionNo: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiResponseDtoTransactionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findTransactionByNo(transactionNo, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TransactionResourceApi.findTransactionByNo']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Resource to retrieve transaction by transaction reference
         * @summary Retrieve transaction by transaction reference
         * @param {string} transactionRef Transaction Reference
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findTransactionByRef(transactionRef: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiResponseDtoTransactionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findTransactionByRef(transactionRef, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TransactionResourceApi.findTransactionByRef']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Resource to generate user callback keys
         * @summary Generate user callback keys
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async generateKeys(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.generateKeys(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TransactionResourceApi.generateKeys']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * TransactionResourceApi - factory interface
 * @export
 */
export const TransactionResourceApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TransactionResourceApiFp(configuration)
    return {
        /**
         * Resource to download transaction receipt by transaction id
         * @summary Download transaction receipt by transaction id
         * @param {string} transactionId Transaction Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadTransactionReceiptById(transactionId: string, options?: RawAxiosRequestConfig): AxiosPromise<string> {
            return localVarFp.downloadTransactionReceiptById(transactionId, options).then((request) => request(axios, basePath));
        },
        /**
         * Resource to download transaction receipt by transaction reference
         * @summary Download transaction receipt by transaction reference
         * @param {string} transactionRef Transaction Reference
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadTransactionReceiptByRef(transactionRef: string, options?: RawAxiosRequestConfig): AxiosPromise<string> {
            return localVarFp.downloadTransactionReceiptByRef(transactionRef, options).then((request) => request(axios, basePath));
        },
        /**
         * Resource to filter transactions
         * @summary Filter transactions
         * @param {FilterAllUserTransactionsFilterTypeEnum} filterType Transaction Filter Type
         * @param {string} filterKeyword Filter Keyword
         * @param {FilterAllUserTransactionsDirectionEnum} direction Sort Direction
         * @param {number} [page] Page
         * @param {number} [size] Size
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        filterAllUserTransactions(filterType: FilterAllUserTransactionsFilterTypeEnum, filterKeyword: string, direction: FilterAllUserTransactionsDirectionEnum, page?: number, size?: number, options?: RawAxiosRequestConfig): AxiosPromise<ApiResponseDtoListTransactionResponse> {
            return localVarFp.filterAllUserTransactions(filterType, filterKeyword, direction, page, size, options).then((request) => request(axios, basePath));
        },
        /**
         * Resource to retrieve all user transactions
         * @summary Retrieve all user transactions
         * @param {number} [page] Page
         * @param {number} [size] Size
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findAllUserTransactions(page?: number, size?: number, options?: RawAxiosRequestConfig): AxiosPromise<ApiResponseDtoListTransactionResponse> {
            return localVarFp.findAllUserTransactions(page, size, options).then((request) => request(axios, basePath));
        },
        /**
         * Resource to retrieve transaction by transaction id
         * @summary Retrieve transaction by transaction id
         * @param {string} transactionId Transaction Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findTransactionById(transactionId: string, options?: RawAxiosRequestConfig): AxiosPromise<ApiResponseDtoTransactionResponse> {
            return localVarFp.findTransactionById(transactionId, options).then((request) => request(axios, basePath));
        },
        /**
         * Resource to retrieve transaction by transaction number
         * @summary Retrieve transaction by transaction number
         * @param {string} transactionNo Transaction number
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findTransactionByNo(transactionNo: string, options?: RawAxiosRequestConfig): AxiosPromise<ApiResponseDtoTransactionResponse> {
            return localVarFp.findTransactionByNo(transactionNo, options).then((request) => request(axios, basePath));
        },
        /**
         * Resource to retrieve transaction by transaction reference
         * @summary Retrieve transaction by transaction reference
         * @param {string} transactionRef Transaction Reference
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findTransactionByRef(transactionRef: string, options?: RawAxiosRequestConfig): AxiosPromise<ApiResponseDtoTransactionResponse> {
            return localVarFp.findTransactionByRef(transactionRef, options).then((request) => request(axios, basePath));
        },
        /**
         * Resource to generate user callback keys
         * @summary Generate user callback keys
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        generateKeys(options?: RawAxiosRequestConfig): AxiosPromise<ApiResponseDto> {
            return localVarFp.generateKeys(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TransactionResourceApi - object-oriented interface
 * @export
 * @class TransactionResourceApi
 * @extends {BaseAPI}
 */
export class TransactionResourceApi extends BaseAPI {
    /**
     * Resource to download transaction receipt by transaction id
     * @summary Download transaction receipt by transaction id
     * @param {string} transactionId Transaction Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionResourceApi
     */
    public downloadTransactionReceiptById(transactionId: string, options?: RawAxiosRequestConfig) {
        return TransactionResourceApiFp(this.configuration).downloadTransactionReceiptById(transactionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Resource to download transaction receipt by transaction reference
     * @summary Download transaction receipt by transaction reference
     * @param {string} transactionRef Transaction Reference
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionResourceApi
     */
    public downloadTransactionReceiptByRef(transactionRef: string, options?: RawAxiosRequestConfig) {
        return TransactionResourceApiFp(this.configuration).downloadTransactionReceiptByRef(transactionRef, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Resource to filter transactions
     * @summary Filter transactions
     * @param {FilterAllUserTransactionsFilterTypeEnum} filterType Transaction Filter Type
     * @param {string} filterKeyword Filter Keyword
     * @param {FilterAllUserTransactionsDirectionEnum} direction Sort Direction
     * @param {number} [page] Page
     * @param {number} [size] Size
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionResourceApi
     */
    public filterAllUserTransactions(filterType: FilterAllUserTransactionsFilterTypeEnum, filterKeyword: string, direction: FilterAllUserTransactionsDirectionEnum, page?: number, size?: number, options?: RawAxiosRequestConfig) {
        return TransactionResourceApiFp(this.configuration).filterAllUserTransactions(filterType, filterKeyword, direction, page, size, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Resource to retrieve all user transactions
     * @summary Retrieve all user transactions
     * @param {number} [page] Page
     * @param {number} [size] Size
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionResourceApi
     */
    public findAllUserTransactions(page?: number, size?: number, options?: RawAxiosRequestConfig) {
        return TransactionResourceApiFp(this.configuration).findAllUserTransactions(page, size, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Resource to retrieve transaction by transaction id
     * @summary Retrieve transaction by transaction id
     * @param {string} transactionId Transaction Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionResourceApi
     */
    public findTransactionById(transactionId: string, options?: RawAxiosRequestConfig) {
        return TransactionResourceApiFp(this.configuration).findTransactionById(transactionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Resource to retrieve transaction by transaction number
     * @summary Retrieve transaction by transaction number
     * @param {string} transactionNo Transaction number
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionResourceApi
     */
    public findTransactionByNo(transactionNo: string, options?: RawAxiosRequestConfig) {
        return TransactionResourceApiFp(this.configuration).findTransactionByNo(transactionNo, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Resource to retrieve transaction by transaction reference
     * @summary Retrieve transaction by transaction reference
     * @param {string} transactionRef Transaction Reference
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionResourceApi
     */
    public findTransactionByRef(transactionRef: string, options?: RawAxiosRequestConfig) {
        return TransactionResourceApiFp(this.configuration).findTransactionByRef(transactionRef, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Resource to generate user callback keys
     * @summary Generate user callback keys
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionResourceApi
     */
    public generateKeys(options?: RawAxiosRequestConfig) {
        return TransactionResourceApiFp(this.configuration).generateKeys(options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const FilterAllUserTransactionsFilterTypeEnum = {
    TransactionType: 'TRANSACTION_TYPE',
    TransactionDate: 'TRANSACTION_DATE',
    PaymentType: 'PAYMENT_TYPE',
    Medium: 'MEDIUM',
    Category: 'CATEGORY',
    Narration: 'NARRATION',
    Remark: 'REMARK'
} as const;
export type FilterAllUserTransactionsFilterTypeEnum = typeof FilterAllUserTransactionsFilterTypeEnum[keyof typeof FilterAllUserTransactionsFilterTypeEnum];
/**
 * @export
 */
export const FilterAllUserTransactionsDirectionEnum = {
    Descending: 'DESCENDING',
    Ascending: 'ASCENDING'
} as const;
export type FilterAllUserTransactionsDirectionEnum = typeof FilterAllUserTransactionsDirectionEnum[keyof typeof FilterAllUserTransactionsDirectionEnum];


/**
 * UserProfileResourceApi - axios parameter creator
 * @export
 */
export const UserProfileResourceApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Resource to change user password
         * @summary Change user password
         * @param {ChangePassword} changePassword 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changePassword: async (changePassword: ChangePassword, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'changePassword' is not null or undefined
            assertParamExists('changePassword', 'changePassword', changePassword)
            const localVarPath = `/api/v1/user/change-password`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(changePassword, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Resource to update transaction pin
         * @summary Update transaction pin
         * @param {ChangeTransactionPin} changeTransactionPin 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changeTransactionPin: async (changeTransactionPin: ChangeTransactionPin, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'changeTransactionPin' is not null or undefined
            assertParamExists('changeTransactionPin', 'changeTransactionPin', changeTransactionPin)
            const localVarPath = `/api/v1/user/transaction-pin/update`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(changeTransactionPin, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Resource to delete user account
         * @summary Delete user account
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAccount: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/user/delete-account`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Resource to retrieve user by id
         * @summary Retrieve user by id
         * @param {string} userId ID of the user to retrieve
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveUserById: async (userId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('retrieveUserById', 'userId', userId)
            const localVarPath = `/api/v1/user`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Resource to retrieve user user profile
         * @summary Retrieve user user profile
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveUserProfile: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/user/profile`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Resource to setup new transaction pin for your account
         * @summary Setup new transaction pin for your account
         * @param {SetTransactionPin} setTransactionPin 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setTransactionPin: async (setTransactionPin: SetTransactionPin, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'setTransactionPin' is not null or undefined
            assertParamExists('setTransactionPin', 'setTransactionPin', setTransactionPin)
            const localVarPath = `/api/v1/user/transaction-pin/setup`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(setTransactionPin, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Resource to sign out a user
         * @summary Sign out a user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        signOut: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/user/signout`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Resource to update user user profile
         * @summary Update user user profile
         * @param {UpdateUserProfile} updateUserProfile 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserProfile: async (updateUserProfile: UpdateUserProfile, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'updateUserProfile' is not null or undefined
            assertParamExists('updateUserProfile', 'updateUserProfile', updateUserProfile)
            const localVarPath = `/api/v1/user/profile`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateUserProfile, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Resource to update user user profile photo from multipart file
         * @summary Update user profile photo from multipart file
         * @param {UpdateUserProfilePhotoRequest} [updateUserProfilePhotoRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserProfilePhoto: async (updateUserProfilePhotoRequest?: UpdateUserProfilePhotoRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/user/profile/update-photo`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateUserProfilePhotoRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Resource to update user user profile photo from based64 string
         * @summary Update user profile photo from based64 string
         * @param {UpdateUserProfilePhoto} updateUserProfilePhoto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserProfileUpdatePhotoBased64: async (updateUserProfilePhoto: UpdateUserProfilePhoto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'updateUserProfilePhoto' is not null or undefined
            assertParamExists('updateUserProfileUpdatePhotoBased64', 'updateUserProfilePhoto', updateUserProfilePhoto)
            const localVarPath = `/api/v1/user/profile/update-photo/based64`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateUserProfilePhoto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UserProfileResourceApi - functional programming interface
 * @export
 */
export const UserProfileResourceApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UserProfileResourceApiAxiosParamCreator(configuration)
    return {
        /**
         * Resource to change user password
         * @summary Change user password
         * @param {ChangePassword} changePassword 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async changePassword(changePassword: ChangePassword, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.changePassword(changePassword, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserProfileResourceApi.changePassword']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Resource to update transaction pin
         * @summary Update transaction pin
         * @param {ChangeTransactionPin} changeTransactionPin 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async changeTransactionPin(changeTransactionPin: ChangeTransactionPin, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.changeTransactionPin(changeTransactionPin, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserProfileResourceApi.changeTransactionPin']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Resource to delete user account
         * @summary Delete user account
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteAccount(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteAccount(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserProfileResourceApi.deleteAccount']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Resource to retrieve user by id
         * @summary Retrieve user by id
         * @param {string} userId ID of the user to retrieve
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieveUserById(userId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiResponseDtoUsersResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrieveUserById(userId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserProfileResourceApi.retrieveUserById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Resource to retrieve user user profile
         * @summary Retrieve user user profile
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieveUserProfile(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiResponseDtoUsersResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrieveUserProfile(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserProfileResourceApi.retrieveUserProfile']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Resource to setup new transaction pin for your account
         * @summary Setup new transaction pin for your account
         * @param {SetTransactionPin} setTransactionPin 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setTransactionPin(setTransactionPin: SetTransactionPin, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setTransactionPin(setTransactionPin, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserProfileResourceApi.setTransactionPin']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Resource to sign out a user
         * @summary Sign out a user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async signOut(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.signOut(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserProfileResourceApi.signOut']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Resource to update user user profile
         * @summary Update user user profile
         * @param {UpdateUserProfile} updateUserProfile 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateUserProfile(updateUserProfile: UpdateUserProfile, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiResponseDtoUsersResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateUserProfile(updateUserProfile, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserProfileResourceApi.updateUserProfile']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Resource to update user user profile photo from multipart file
         * @summary Update user profile photo from multipart file
         * @param {UpdateUserProfilePhotoRequest} [updateUserProfilePhotoRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateUserProfilePhoto(updateUserProfilePhotoRequest?: UpdateUserProfilePhotoRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiResponseDtoUsersResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateUserProfilePhoto(updateUserProfilePhotoRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserProfileResourceApi.updateUserProfilePhoto']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Resource to update user user profile photo from based64 string
         * @summary Update user profile photo from based64 string
         * @param {UpdateUserProfilePhoto} updateUserProfilePhoto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateUserProfileUpdatePhotoBased64(updateUserProfilePhoto: UpdateUserProfilePhoto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiResponseDtoUsersResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateUserProfileUpdatePhotoBased64(updateUserProfilePhoto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserProfileResourceApi.updateUserProfileUpdatePhotoBased64']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * UserProfileResourceApi - factory interface
 * @export
 */
export const UserProfileResourceApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UserProfileResourceApiFp(configuration)
    return {
        /**
         * Resource to change user password
         * @summary Change user password
         * @param {ChangePassword} changePassword 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changePassword(changePassword: ChangePassword, options?: RawAxiosRequestConfig): AxiosPromise<ApiResponseDto> {
            return localVarFp.changePassword(changePassword, options).then((request) => request(axios, basePath));
        },
        /**
         * Resource to update transaction pin
         * @summary Update transaction pin
         * @param {ChangeTransactionPin} changeTransactionPin 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changeTransactionPin(changeTransactionPin: ChangeTransactionPin, options?: RawAxiosRequestConfig): AxiosPromise<ApiResponseDto> {
            return localVarFp.changeTransactionPin(changeTransactionPin, options).then((request) => request(axios, basePath));
        },
        /**
         * Resource to delete user account
         * @summary Delete user account
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAccount(options?: RawAxiosRequestConfig): AxiosPromise<ApiResponseDto> {
            return localVarFp.deleteAccount(options).then((request) => request(axios, basePath));
        },
        /**
         * Resource to retrieve user by id
         * @summary Retrieve user by id
         * @param {string} userId ID of the user to retrieve
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveUserById(userId: string, options?: RawAxiosRequestConfig): AxiosPromise<ApiResponseDtoUsersResponse> {
            return localVarFp.retrieveUserById(userId, options).then((request) => request(axios, basePath));
        },
        /**
         * Resource to retrieve user user profile
         * @summary Retrieve user user profile
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveUserProfile(options?: RawAxiosRequestConfig): AxiosPromise<ApiResponseDtoUsersResponse> {
            return localVarFp.retrieveUserProfile(options).then((request) => request(axios, basePath));
        },
        /**
         * Resource to setup new transaction pin for your account
         * @summary Setup new transaction pin for your account
         * @param {SetTransactionPin} setTransactionPin 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setTransactionPin(setTransactionPin: SetTransactionPin, options?: RawAxiosRequestConfig): AxiosPromise<ApiResponseDto> {
            return localVarFp.setTransactionPin(setTransactionPin, options).then((request) => request(axios, basePath));
        },
        /**
         * Resource to sign out a user
         * @summary Sign out a user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        signOut(options?: RawAxiosRequestConfig): AxiosPromise<ApiResponseDto> {
            return localVarFp.signOut(options).then((request) => request(axios, basePath));
        },
        /**
         * Resource to update user user profile
         * @summary Update user user profile
         * @param {UpdateUserProfile} updateUserProfile 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserProfile(updateUserProfile: UpdateUserProfile, options?: RawAxiosRequestConfig): AxiosPromise<ApiResponseDtoUsersResponse> {
            return localVarFp.updateUserProfile(updateUserProfile, options).then((request) => request(axios, basePath));
        },
        /**
         * Resource to update user user profile photo from multipart file
         * @summary Update user profile photo from multipart file
         * @param {UpdateUserProfilePhotoRequest} [updateUserProfilePhotoRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserProfilePhoto(updateUserProfilePhotoRequest?: UpdateUserProfilePhotoRequest, options?: RawAxiosRequestConfig): AxiosPromise<ApiResponseDtoUsersResponse> {
            return localVarFp.updateUserProfilePhoto(updateUserProfilePhotoRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Resource to update user user profile photo from based64 string
         * @summary Update user profile photo from based64 string
         * @param {UpdateUserProfilePhoto} updateUserProfilePhoto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserProfileUpdatePhotoBased64(updateUserProfilePhoto: UpdateUserProfilePhoto, options?: RawAxiosRequestConfig): AxiosPromise<ApiResponseDtoUsersResponse> {
            return localVarFp.updateUserProfileUpdatePhotoBased64(updateUserProfilePhoto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UserProfileResourceApi - object-oriented interface
 * @export
 * @class UserProfileResourceApi
 * @extends {BaseAPI}
 */
export class UserProfileResourceApi extends BaseAPI {
    /**
     * Resource to change user password
     * @summary Change user password
     * @param {ChangePassword} changePassword 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserProfileResourceApi
     */
    public changePassword(changePassword: ChangePassword, options?: RawAxiosRequestConfig) {
        return UserProfileResourceApiFp(this.configuration).changePassword(changePassword, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Resource to update transaction pin
     * @summary Update transaction pin
     * @param {ChangeTransactionPin} changeTransactionPin 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserProfileResourceApi
     */
    public changeTransactionPin(changeTransactionPin: ChangeTransactionPin, options?: RawAxiosRequestConfig) {
        return UserProfileResourceApiFp(this.configuration).changeTransactionPin(changeTransactionPin, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Resource to delete user account
     * @summary Delete user account
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserProfileResourceApi
     */
    public deleteAccount(options?: RawAxiosRequestConfig) {
        return UserProfileResourceApiFp(this.configuration).deleteAccount(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Resource to retrieve user by id
     * @summary Retrieve user by id
     * @param {string} userId ID of the user to retrieve
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserProfileResourceApi
     */
    public retrieveUserById(userId: string, options?: RawAxiosRequestConfig) {
        return UserProfileResourceApiFp(this.configuration).retrieveUserById(userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Resource to retrieve user user profile
     * @summary Retrieve user user profile
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserProfileResourceApi
     */
    public retrieveUserProfile(options?: RawAxiosRequestConfig) {
        return UserProfileResourceApiFp(this.configuration).retrieveUserProfile(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Resource to setup new transaction pin for your account
     * @summary Setup new transaction pin for your account
     * @param {SetTransactionPin} setTransactionPin 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserProfileResourceApi
     */
    public setTransactionPin(setTransactionPin: SetTransactionPin, options?: RawAxiosRequestConfig) {
        return UserProfileResourceApiFp(this.configuration).setTransactionPin(setTransactionPin, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Resource to sign out a user
     * @summary Sign out a user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserProfileResourceApi
     */
    public signOut(options?: RawAxiosRequestConfig) {
        return UserProfileResourceApiFp(this.configuration).signOut(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Resource to update user user profile
     * @summary Update user user profile
     * @param {UpdateUserProfile} updateUserProfile 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserProfileResourceApi
     */
    public updateUserProfile(updateUserProfile: UpdateUserProfile, options?: RawAxiosRequestConfig) {
        return UserProfileResourceApiFp(this.configuration).updateUserProfile(updateUserProfile, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Resource to update user user profile photo from multipart file
     * @summary Update user profile photo from multipart file
     * @param {UpdateUserProfilePhotoRequest} [updateUserProfilePhotoRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserProfileResourceApi
     */
    public updateUserProfilePhoto(updateUserProfilePhotoRequest?: UpdateUserProfilePhotoRequest, options?: RawAxiosRequestConfig) {
        return UserProfileResourceApiFp(this.configuration).updateUserProfilePhoto(updateUserProfilePhotoRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Resource to update user user profile photo from based64 string
     * @summary Update user profile photo from based64 string
     * @param {UpdateUserProfilePhoto} updateUserProfilePhoto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserProfileResourceApi
     */
    public updateUserProfileUpdatePhotoBased64(updateUserProfilePhoto: UpdateUserProfilePhoto, options?: RawAxiosRequestConfig) {
        return UserProfileResourceApiFp(this.configuration).updateUserProfileUpdatePhotoBased64(updateUserProfilePhoto, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * UtilitiesResourceApi - axios parameter creator
 * @export
 */
export const UtilitiesResourceApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Resource to retrieve country list
         * @summary Retrieve country list
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAllCountries: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/utilities/countries`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Resource to retrieve language list
         * @summary Retrieve language list
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAllLanguages: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/utilities/languages`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Resource to retrieve organization types
         * @summary Retrieve organization types
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAllOrganizationTypes: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/utilities/organization-types`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Resource to retrieve transaction categories
         * @summary Retrieve transaction categories
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAllTransactionsCategories: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/utilities/transaction-categories`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        testConnection: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/utilities/test/redis`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UtilitiesResourceApi - functional programming interface
 * @export
 */
export const UtilitiesResourceApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UtilitiesResourceApiAxiosParamCreator(configuration)
    return {
        /**
         * Resource to retrieve country list
         * @summary Retrieve country list
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listAllCountries(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiResponseDtoListCountry>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listAllCountries(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UtilitiesResourceApi.listAllCountries']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Resource to retrieve language list
         * @summary Retrieve language list
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listAllLanguages(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiResponseDtoListLanguage>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listAllLanguages(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UtilitiesResourceApi.listAllLanguages']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Resource to retrieve organization types
         * @summary Retrieve organization types
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listAllOrganizationTypes(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiResponseDtoListOrganizationType>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listAllOrganizationTypes(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UtilitiesResourceApi.listAllOrganizationTypes']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Resource to retrieve transaction categories
         * @summary Retrieve transaction categories
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listAllTransactionsCategories(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiResponseDtoListString>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listAllTransactionsCategories(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UtilitiesResourceApi.listAllTransactionsCategories']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async testConnection(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.testConnection(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UtilitiesResourceApi.testConnection']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * UtilitiesResourceApi - factory interface
 * @export
 */
export const UtilitiesResourceApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UtilitiesResourceApiFp(configuration)
    return {
        /**
         * Resource to retrieve country list
         * @summary Retrieve country list
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAllCountries(options?: RawAxiosRequestConfig): AxiosPromise<ApiResponseDtoListCountry> {
            return localVarFp.listAllCountries(options).then((request) => request(axios, basePath));
        },
        /**
         * Resource to retrieve language list
         * @summary Retrieve language list
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAllLanguages(options?: RawAxiosRequestConfig): AxiosPromise<ApiResponseDtoListLanguage> {
            return localVarFp.listAllLanguages(options).then((request) => request(axios, basePath));
        },
        /**
         * Resource to retrieve organization types
         * @summary Retrieve organization types
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAllOrganizationTypes(options?: RawAxiosRequestConfig): AxiosPromise<ApiResponseDtoListOrganizationType> {
            return localVarFp.listAllOrganizationTypes(options).then((request) => request(axios, basePath));
        },
        /**
         * Resource to retrieve transaction categories
         * @summary Retrieve transaction categories
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAllTransactionsCategories(options?: RawAxiosRequestConfig): AxiosPromise<ApiResponseDtoListString> {
            return localVarFp.listAllTransactionsCategories(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        testConnection(options?: RawAxiosRequestConfig): AxiosPromise<string> {
            return localVarFp.testConnection(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UtilitiesResourceApi - object-oriented interface
 * @export
 * @class UtilitiesResourceApi
 * @extends {BaseAPI}
 */
export class UtilitiesResourceApi extends BaseAPI {
    /**
     * Resource to retrieve country list
     * @summary Retrieve country list
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UtilitiesResourceApi
     */
    public listAllCountries(options?: RawAxiosRequestConfig) {
        return UtilitiesResourceApiFp(this.configuration).listAllCountries(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Resource to retrieve language list
     * @summary Retrieve language list
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UtilitiesResourceApi
     */
    public listAllLanguages(options?: RawAxiosRequestConfig) {
        return UtilitiesResourceApiFp(this.configuration).listAllLanguages(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Resource to retrieve organization types
     * @summary Retrieve organization types
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UtilitiesResourceApi
     */
    public listAllOrganizationTypes(options?: RawAxiosRequestConfig) {
        return UtilitiesResourceApiFp(this.configuration).listAllOrganizationTypes(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Resource to retrieve transaction categories
     * @summary Retrieve transaction categories
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UtilitiesResourceApi
     */
    public listAllTransactionsCategories(options?: RawAxiosRequestConfig) {
        return UtilitiesResourceApiFp(this.configuration).listAllTransactionsCategories(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UtilitiesResourceApi
     */
    public testConnection(options?: RawAxiosRequestConfig) {
        return UtilitiesResourceApiFp(this.configuration).testConnection(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * WalletResourceApi - axios parameter creator
 * @export
 */
export const WalletResourceApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Resource to retrieve user main wallet information
         * @summary Retrieve user main wallet information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveMainWalletInfo: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/wallet/main`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * WalletResourceApi - functional programming interface
 * @export
 */
export const WalletResourceApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = WalletResourceApiAxiosParamCreator(configuration)
    return {
        /**
         * Resource to retrieve user main wallet information
         * @summary Retrieve user main wallet information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieveMainWalletInfo(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiResponseDtoWalletResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrieveMainWalletInfo(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WalletResourceApi.retrieveMainWalletInfo']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * WalletResourceApi - factory interface
 * @export
 */
export const WalletResourceApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = WalletResourceApiFp(configuration)
    return {
        /**
         * Resource to retrieve user main wallet information
         * @summary Retrieve user main wallet information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveMainWalletInfo(options?: RawAxiosRequestConfig): AxiosPromise<ApiResponseDtoWalletResponse> {
            return localVarFp.retrieveMainWalletInfo(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * WalletResourceApi - object-oriented interface
 * @export
 * @class WalletResourceApi
 * @extends {BaseAPI}
 */
export class WalletResourceApi extends BaseAPI {
    /**
     * Resource to retrieve user main wallet information
     * @summary Retrieve user main wallet information
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WalletResourceApi
     */
    public retrieveMainWalletInfo(options?: RawAxiosRequestConfig) {
        return WalletResourceApiFp(this.configuration).retrieveMainWalletInfo(options).then((request) => request(this.axios, this.basePath));
    }
}



